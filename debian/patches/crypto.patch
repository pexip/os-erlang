diff --git a/lib/crypto/c_src/crypto.c b/lib/crypto/c_src/crypto.c
index e7215ee..ec052fd 100644
--- a/lib/crypto/c_src/crypto.c
+++ b/lib/crypto/c_src/crypto.c
@@ -400,7 +400,7 @@ ERL_NIF_INIT(crypto,nif_funcs,load,NULL,upgrade,unload)
 #define MD4_LEN         16
 #define RIPEMD160_CTX_LEN (sizeof(RIPEMD160_CTX))
 #define RIPEMD160_LEN   20
-#define SHA_CTX_LEN     (sizeof(SHA_CTX))
+#define SHA_CTX_LEN     (sizeof(EVP_MD_CTX))
 #define SHA_LEN         20
 #define SHA_LEN_96      12
 #define SHA224_LEN	(224/8)
@@ -909,27 +909,34 @@ static ERL_NIF_TERM ripemd160_final(ErlNifEnv* env, int argc, const ERL_NIF_TERM
 
 static ERL_NIF_TERM sha(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 {/* (Data) */    
+    EVP_MD_CTX ctx;
     ErlNifBinary ibin;
     ERL_NIF_TERM ret;
     CHECK_OSE_CRYPTO();
     if (!enif_inspect_iolist_as_binary(env, argv[0], &ibin)) {
 	return enif_make_badarg(env);
     }
-    SHA1((unsigned char *) ibin.data, ibin.size,
-	 enif_make_new_binary(env,SHA_LEN, &ret));
+    EVP_MD_CTX_init(&ctx);
+    EVP_DigestInit_ex(&ctx, EVP_sha1(), NULL);
+    EVP_DigestUpdate(&ctx, ibin.data, ibin.size);
+    EVP_DigestFinal_ex(&ctx, enif_make_new_binary(env, SHA_LEN, &ret), NULL);
+    EVP_MD_CTX_cleanup(&ctx);
     CONSUME_REDS(env,ibin);
     return ret;
 }
 static ERL_NIF_TERM sha_init(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 {/* () */   
+    EVP_MD_CTX* ctx;
     ERL_NIF_TERM ret;
     CHECK_OSE_CRYPTO();
-    SHA1_Init((SHA_CTX *) enif_make_new_binary(env, SHA_CTX_LEN, &ret));
+    ctx = (EVP_MD_CTX *) enif_make_new_binary(env, SHA_CTX_LEN, &ret);
+    EVP_MD_CTX_init(ctx);
+    EVP_DigestInit_ex(ctx, EVP_sha1(), NULL);
     return ret;
 }
 static ERL_NIF_TERM sha_update(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 {/* (Context, Data) */
-    SHA_CTX* new_ctx;
+    EVP_MD_CTX* new_ctx;
     ErlNifBinary ctx_bin, data_bin;
     ERL_NIF_TERM ret;
     CHECK_OSE_CRYPTO();
@@ -937,23 +944,24 @@ static ERL_NIF_TERM sha_update(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv
 	|| !enif_inspect_iolist_as_binary(env, argv[1], &data_bin)) {
 	return enif_make_badarg(env);
     }
-    new_ctx = (SHA_CTX*) enif_make_new_binary(env,SHA_CTX_LEN, &ret);
+    new_ctx = (EVP_MD_CTX*) enif_make_new_binary(env,SHA_CTX_LEN, &ret);
     memcpy(new_ctx, ctx_bin.data, SHA_CTX_LEN);
-    SHA1_Update(new_ctx, data_bin.data, data_bin.size);
+    EVP_DigestUpdate(new_ctx, data_bin.data, data_bin.size);
     CONSUME_REDS(env,data_bin);
     return ret;
 }
 static ERL_NIF_TERM sha_final(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 {/* (Context) */
     ErlNifBinary ctx_bin;
-    SHA_CTX ctx_clone;
+    EVP_MD_CTX ctx_clone;
     ERL_NIF_TERM ret;
     CHECK_OSE_CRYPTO();
     if (!enif_inspect_binary(env, argv[0], &ctx_bin) || ctx_bin.size != SHA_CTX_LEN) {
 	return enif_make_badarg(env);
     }
     memcpy(&ctx_clone, ctx_bin.data, SHA_CTX_LEN); /* writable */
-    SHA1_Final(enif_make_new_binary(env, SHA_LEN, &ret), &ctx_clone);    
+    EVP_DigestFinal_ex(&ctx_clone, enif_make_new_binary(env, SHA_LEN, &ret), NULL);
+    EVP_MD_CTX_cleanup(&ctx_clone);
     return ret;
 }
 
