diff --git a/lib/crypto/c_src/Makefile.in b/lib/crypto/c_src/Makefile.in
index 4478ed7d9c..25167a8a3a 100644
--- a/lib/crypto/c_src/Makefile.in
+++ b/lib/crypto/c_src/Makefile.in
@@ -42,6 +42,7 @@ SSL_LIBDIR = @SSL_LIBDIR@
 SSL_INCLUDE = @SSL_INCLUDE@
 SSL_CRYPTO_LIBNAME = @SSL_CRYPTO_LIBNAME@
 SSL_SSL_LIBNAME = @SSL_SSL_LIBNAME@
+CRYPTO_NO_DEPRECATE_WARN = @CRYPTO_NO_DEPRECATE_WARN@
 
 INCLUDES = $(SSL_INCLUDE) @DED_INCLUDE@
 SSL_EXTRA_LIBS=@SSL_EXTRA_LIBS@
@@ -112,6 +113,7 @@ CRYPTO_OBJS = $(OBJDIR)/crypto$(TYPEMARKER).o \
 	$(OBJDIR)/rand$(TYPEMARKER).o \
 	$(OBJDIR)/rsa$(TYPEMARKER).o \
 	$(OBJDIR)/srp$(TYPEMARKER).o \
+	$(OBJDIR)/hash_equals$(TYPEMARKER).o \
 	$(OBJDIR)/pbkdf2_hmac$(TYPEMARKER).o
 
 CALLBACK_OBJS = $(OBJDIR)/crypto_callback$(TYPEMARKER).o
@@ -150,7 +152,7 @@ CRYPTO_LINK_LIB=$(SSL_DED_LD_RUNTIME_LIBRARY_PATH) -L$(SSL_LIBDIR) -l$(SSL_CRYPT
 EXTRA_FLAGS = -DHAVE_DYNAMIC_CRYPTO_LIB
 else
 SSL_DED_LD_RUNTIME_LIBRARY_PATH=
-CRYPTO_LINK_LIB=$(SSL_LIBDIR)/lib$(SSL_CRYPTO_LIBNAME).a 
+CRYPTO_LINK_LIB=$(SSL_LIBDIR)/lib$(SSL_CRYPTO_LIBNAME).a
 EXTRA_FLAGS =
 CRYPTO_OBJS := $(CRYPTO_OBJS) $(CALLBACK_OBJS)
 CALLBACK_OBJS =
@@ -192,7 +194,7 @@ ifeq ($(DISABLE_OTP_TEST_ENGINE),yes)
 else
 $(OBJDIR)/otp_test_engine$(TYPEMARKER).o: otp_test_engine.c
 	$(V_at)$(INSTALL_DIR) $(OBJDIR)
-	$(V_CC) -c -o $@ $(filter-out -Wmissing-prototypes,$(ALL_CFLAGS)) $<
+	$(V_CC) -c -o $@ $(filter-out -Wmissing-prototypes,$(ALL_CFLAGS) $(CRYPTO_NO_DEPRECATE_WARN)) $<
 
 $(LIBDIR)/otp_test_engine$(TYPEMARKER).so: $(TEST_ENGINE_OBJS)
 	$(V_at)$(INSTALL_DIR) $(LIBDIR)
@@ -203,6 +205,10 @@ $(LIBDIR)/otp_test_engine$(TYPEMARKER).dll: $(TEST_ENGINE_OBJS)
 	$(V_LD) $(LDFLAGS) -o $@  $(SSL_DED_LD_RUNTIME_LIBRARY_PATH) -L$(SSL_LIBDIR) $(TEST_ENGINE_OBJS) -l$(SSL_CRYPTO_LIBNAME) -l$(SSL_SSL_LIBNAME) $(SSL_EXTRA_LIBS)
 endif
 
+$(OBJDIR)/ec$(TYPEMARKER).o: ec.c
+	$(V_at)$(INSTALL_DIR) $(OBJDIR)
+	$(V_CC) -c -o $@ $(ALL_CFLAGS) $(CRYPTO_NO_DEPRECATE_WARN) $<
+
 $(OBJDIR)/%$(TYPEMARKER).o: %.c
 	$(V_at)$(INSTALL_DIR) $(OBJDIR)
 	$(V_CC) -c -o $@ $(ALL_CFLAGS) $<
@@ -255,7 +261,7 @@ docs:
 
 # ----------------------------------------------------
 # Release Target
-# ---------------------------------------------------- 
+# ----------------------------------------------------
 include $(ERL_TOP)/make/otp_release_targets.mk
 
 release_spec: opt
diff --git a/lib/crypto/c_src/bn.c b/lib/crypto/c_src/bn.c
index 4c2167703a..f06ed9002e 100644
--- a/lib/crypto/c_src/bn.c
+++ b/lib/crypto/c_src/bn.c
@@ -1,7 +1,7 @@
 /*
  * %CopyrightBegin%
  *
- * Copyright Ericsson AB 2010-2021. All Rights Reserved.
+ * Copyright Ericsson AB 2010-2022. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -192,3 +192,58 @@ ERL_NIF_TERM bn2term(ErlNifEnv* env, size_t size, const BIGNUM *bn)
     return enif_make_badarg(env);
 }
 #endif
+
+
+#ifdef HAS_3_0_API
+
+int get_ossl_octet_string_param_from_bin(ErlNifEnv* env, char* key, ERL_NIF_TERM bin, OSSL_PARAM *dest)
+{
+    ErlNifBinary tmp;
+
+    if (!enif_inspect_binary(env, bin, &tmp)) return 0;
+    
+    *dest = OSSL_PARAM_construct_octet_string(key, tmp.data, tmp.size);
+    return 1;
+}
+
+
+int get_ossl_BN_param_from_bin(ErlNifEnv* env, char* key, ERL_NIF_TERM bin, OSSL_PARAM *dest)
+{
+    return get_ossl_BN_param_from_bin_sz(env, key, bin, dest, NULL);
+}
+
+int get_ossl_BN_param_from_bin_sz(ErlNifEnv* env, char* key, ERL_NIF_TERM bin, OSSL_PARAM *dest, size_t *size)
+{
+    BIGNUM *bn = NULL;
+    ErlNifBinary tmp;
+
+    if (!get_bn_from_bin_sz(env, bin, &bn, size) ||
+        !enif_inspect_binary(env, bin_from_bn(env,bn), &tmp) || // Allocate buf
+        BN_bn2nativepad(bn, tmp.data, tmp.size) < 0) {// Fill with BN in right endianity
+        if (bn) BN_free(bn);
+        return 0;
+    }
+    
+    *dest = OSSL_PARAM_construct_BN(key, tmp.data, tmp.size);
+    if (bn) BN_free(bn);
+    return 1;
+}
+
+int get_ossl_param_from_bin_in_list(ErlNifEnv* env, char* key, ERL_NIF_TERM *listcell, OSSL_PARAM *dest)
+{
+    ERL_NIF_TERM head;
+    
+    return
+        enif_get_list_cell(env, *listcell, &head, listcell) &&
+        get_ossl_BN_param_from_bin(env, key, head, dest);
+}
+
+#endif
+
+
+
+
+
+
+
+
diff --git a/lib/crypto/c_src/bn.h b/lib/crypto/c_src/bn.h
index 8b309db089..5e207aed2d 100644
--- a/lib/crypto/c_src/bn.h
+++ b/lib/crypto/c_src/bn.h
@@ -1,7 +1,7 @@
 /*
  * %CopyrightBegin%
  *
- * Copyright Ericsson AB 2010-2021. All Rights Reserved.
+ * Copyright Ericsson AB 2010-2022. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -34,4 +34,13 @@ int get_bn_from_mpint(ErlNifEnv* env, ERL_NIF_TERM term, BIGNUM** bnp);
 int get_bn_from_bin(ErlNifEnv* env, ERL_NIF_TERM term, BIGNUM** bnp);
 int get_bn_from_bin_sz(ErlNifEnv* env, ERL_NIF_TERM term, BIGNUM** bnp, size_t* binsize);
 
+#ifdef HAS_3_0_API
+int get_ossl_octet_string_param_from_bin(ErlNifEnv* env, char* key, ERL_NIF_TERM bin, OSSL_PARAM *dest);
+int get_ossl_BN_param_from_bin(ErlNifEnv* env, char* key, ERL_NIF_TERM bin, OSSL_PARAM *dest);
+int get_ossl_BN_param_from_bin_sz(ErlNifEnv* env, char* key, ERL_NIF_TERM bin, OSSL_PARAM *dest, size_t *size);
+
+int get_ossl_param_from_bin_in_list(ErlNifEnv* env, char* key, ERL_NIF_TERM *listcell, OSSL_PARAM *dest);
+#endif
+
 #endif /* E_BN_H__ */
+
diff --git a/lib/crypto/c_src/cipher.c b/lib/crypto/c_src/cipher.c
index 6862187d6b..30c0fbcdb7 100644
--- a/lib/crypto/c_src/cipher.c
+++ b/lib/crypto/c_src/cipher.c
@@ -1,7 +1,7 @@
 /*
  * %CopyrightBegin%
  *
- * Copyright Ericsson AB 2010-2021. All Rights Reserved.
+ * Copyright Ericsson AB 2010-2022. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -60,28 +60,32 @@ static struct cipher_type_t cipher_types[] =
 #endif
 
 #ifdef HAVE_BF
-    {{"blowfish_cbc"},   "BF-CBC",   {&EVP_bf_cbc},   0, NO_FIPS_CIPHER, NOT_AEAD},
-    {{"blowfish_cfb64"}, "BF-CFB64", {&EVP_bf_cfb64}, 0, NO_FIPS_CIPHER, NOT_AEAD},
-    {{"blowfish_ofb64"}, "BF-OFB64", {&EVP_bf_ofb},   0, NO_FIPS_CIPHER, NOT_AEAD},
-    {{"blowfish_ecb"},   "BF-ECB",   {&EVP_bf_ecb},   0, NO_FIPS_CIPHER | ECB_BUG_0_9_8L, NOT_AEAD},
+    {{"blowfish_cbc"},   "BF-CBC", {&EVP_bf_cbc},   0, NO_FIPS_CIPHER, NOT_AEAD},
+    {{"blowfish_cfb64"}, "BF-CFB", {&EVP_bf_cfb64}, 0, NO_FIPS_CIPHER, NOT_AEAD},
+    {{"blowfish_ofb64"}, "BF-OFB", {&EVP_bf_ofb},   0, NO_FIPS_CIPHER, NOT_AEAD},
+    {{"blowfish_ecb"},   "BF-ECB", {&EVP_bf_ecb},   0, NO_FIPS_CIPHER | ECB_BUG_0_9_8L, NOT_AEAD},
 #else
-    {{"blowfish_cbc"},   "BF-CBC",   {NULL}, 0, 0, NOT_AEAD},
-    {{"blowfish_cfb64"}, "BF-CFB64", {NULL}, 0, 0, NOT_AEAD},
-    {{"blowfish_ofb64"}, "BF-OFB64", {NULL}, 0, 0, NOT_AEAD},
-    {{"blowfish_ecb"},   "BF-ECB",   {NULL}, 0, 0, NOT_AEAD},
+    {{"blowfish_cbc"},   "BF-CBC", {NULL}, 0, 0, NOT_AEAD},
+    {{"blowfish_cfb64"}, "BF-CFB", {NULL}, 0, 0, NOT_AEAD},
+    {{"blowfish_ofb64"}, "BF-OFB", {NULL}, 0, 0, NOT_AEAD},
+    {{"blowfish_ecb"},   "BF-ECB", {NULL}, 0, 0, NOT_AEAD},
 #endif
 
     {{"aes_128_cbc"}, "aes-128-cbc", {&EVP_aes_128_cbc}, 16, 0, NOT_AEAD},
     {{"aes_192_cbc"}, "aes-192-cbc", {&EVP_aes_192_cbc}, 24, 0, NOT_AEAD},
     {{"aes_256_cbc"}, "aes-256-cbc", {&EVP_aes_256_cbc}, 32, 0, NOT_AEAD},
 
+    {{"aes_128_ofb"}, "aes-128-ofb", {&EVP_aes_128_ofb}, 16, 0, NOT_AEAD},
+    {{"aes_192_ofb"}, "aes-192-ofb", {&EVP_aes_192_ofb}, 24, 0, NOT_AEAD},
+    {{"aes_256_ofb"}, "aes-256-ofb", {&EVP_aes_256_ofb}, 32, 0, NOT_AEAD},
+
     {{"aes_128_cfb8"}, "aes-128-cfb8", {&EVP_aes_128_cfb8}, 16, AES_CFBx, NOT_AEAD},
     {{"aes_192_cfb8"}, "aes-192-cfb8", {&EVP_aes_192_cfb8}, 24, AES_CFBx, NOT_AEAD},
     {{"aes_256_cfb8"}, "aes-256-cfb8", {&EVP_aes_256_cfb8}, 32, AES_CFBx, NOT_AEAD},
 
-    {{"aes_128_cfb128"}, "aes-128-cfb128", {&EVP_aes_128_cfb128}, 16, AES_CFBx, NOT_AEAD},
-    {{"aes_192_cfb128"}, "aes-192-cfb128", {&EVP_aes_192_cfb128}, 24, AES_CFBx, NOT_AEAD},
-    {{"aes_256_cfb128"}, "aes-256-cfb128", {&EVP_aes_256_cfb128}, 32, AES_CFBx, NOT_AEAD},
+    {{"aes_128_cfb128"}, "aes-128-cfb", {&EVP_aes_128_cfb128}, 16, AES_CFBx, NOT_AEAD},
+    {{"aes_192_cfb128"}, "aes-192-cfb", {&EVP_aes_192_cfb128}, 24, AES_CFBx, NOT_AEAD},
+    {{"aes_256_cfb128"}, "aes-256-cfb", {&EVP_aes_256_cfb128}, 32, AES_CFBx, NOT_AEAD},
 
     {{"aes_128_ecb"}, "aes-128-ecb", {&EVP_aes_128_ecb}, 16, ECB_BUG_0_9_8L, NOT_AEAD},
     {{"aes_192_ecb"}, "aes-192-ecb", {&EVP_aes_192_ecb}, 24, ECB_BUG_0_9_8L, NOT_AEAD},
diff --git a/lib/crypto/c_src/common.h b/lib/crypto/c_src/common.h
index 593a58373f..5da20fd0c8 100644
--- a/lib/crypto/c_src/common.h
+++ b/lib/crypto/c_src/common.h
@@ -1,7 +1,7 @@
 /*
  * %CopyrightBegin%
  *
- * Copyright Ericsson AB 2010-2021. All Rights Reserved.
+ * Copyright Ericsson AB 2010-2022. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -46,4 +46,6 @@ ERL_NIF_TERM raise_exception(ErlNifEnv* env, ERL_NIF_TERM id, int arg_num, char*
 #define EXCP_NOTSUP_N(Env, ArgNum, Str) raise_exception((Env), atom_notsup, (ArgNum), (Str), __FILE__, __LINE__)
 #define EXCP_BADARG_N(Env, ArgNum, Str) raise_exception((Env), atom_badarg, (ArgNum), (Str), __FILE__, __LINE__)
 
+#define assign_goto(Var, Goto, CALL) {Var = (CALL); goto Goto;}
+
 #endif /* E_COMMON_H__ */
diff --git a/lib/crypto/c_src/crypto.c b/lib/crypto/c_src/crypto.c
index 5ebcd914b0..ef6d0bdc13 100644
--- a/lib/crypto/c_src/crypto.c
+++ b/lib/crypto/c_src/crypto.c
@@ -42,6 +42,7 @@
 #include "evp.h"
 #include "fips.h"
 #include "hash.h"
+#include "hash_equals.h"
 #include "hmac.h"
 #include "info.h"
 #include "math.h"
@@ -91,6 +92,9 @@ static ErlNifFunc nif_funcs[] = {
     {"rand_uniform_nif", 2, rand_uniform_nif, 0},
     {"mod_exp_nif", 4, mod_exp_nif, 0},
     {"do_exor", 2, do_exor, 0},
+
+    {"hash_equals_nif", 2, hash_equals_nif, 0},
+    
     {"pbkdf2_hmac_nif", 5, pbkdf2_hmac_nif, 0},
     {"pkey_sign_nif", 5, pkey_sign_nif, 0},
     {"pkey_verify_nif", 6, pkey_verify_nif, 0},
@@ -105,7 +109,7 @@ static ErlNifFunc nif_funcs[] = {
     {"srp_user_secret_nif", 7, srp_user_secret_nif, 0},
     {"srp_host_secret_nif", 5, srp_host_secret_nif, 0},
 
-    {"ec_key_generate", 2, ec_key_generate, 0},
+    {"ec_generate_key_nif", 2, ec_generate_key_nif, 0},
     {"ecdh_compute_key_nif", 3, ecdh_compute_key_nif, 0},
 
     {"rand_seed_nif", 1, rand_seed_nif, 0},
@@ -221,7 +225,7 @@ static int initialize(ErlNifEnv* env, ERL_NIF_TERM load_info)
 #endif
     if ((prov_cnt<MAX_NUM_PROVIDERS) && !(prov[prov_cnt++] = OSSL_PROVIDER_load(NULL, "default"))) return __LINE__;
     if ((prov_cnt<MAX_NUM_PROVIDERS) && !(prov[prov_cnt++] = OSSL_PROVIDER_load(NULL, "base"))) return __LINE__;
-    if ((prov_cnt<MAX_NUM_PROVIDERS) && !(prov[prov_cnt++] = OSSL_PROVIDER_load(NULL, "legacy"))) return __LINE__;
+    if (prov_cnt<MAX_NUM_PROVIDERS) {prov_cnt++; OSSL_PROVIDER_load(NULL, "legacy");}
 #endif
 
     if (library_initialized) {
@@ -338,3 +342,4 @@ static void unload(ErlNifEnv* env, void* priv_data)
 #endif
 
 }
+
diff --git a/lib/crypto/c_src/dh.c b/lib/crypto/c_src/dh.c
index 67be0c81f0..4bcab0ec6e 100644
--- a/lib/crypto/c_src/dh.c
+++ b/lib/crypto/c_src/dh.c
@@ -21,9 +21,248 @@
 #include "dh.h"
 #include "bn.h"
 
+
+#if !defined(HAVE_DH)
+ERL_NIF_TERM dh_generate_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
+{
+    return  enif_raise_exception(env, atom_notsup);
+}
+
+ERL_NIF_TERM dh_compute_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
+{
+    return  enif_raise_exception(env, atom_notsup);
+}
+
+#else /* HAVE_DH */
+
+
+# ifdef HAS_3_0_API
+
+/* Has 3_0 */
+ERL_NIF_TERM dh_generate_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
+{/* (PrivKey|undefined, DHParams=[P,G], 0, Len|0) */
+    unsigned long len = 0;
+    int i = 0;
+    OSSL_PARAM params[8];
+    EVP_PKEY *pkey = NULL, *pkey_gen = NULL;
+    EVP_PKEY_CTX *pctx = NULL, *pctx_gen = NULL;
+    BIGNUM *pub_key_gen = NULL, *priv_key_gen = NULL;
+    unsigned char *pub_ptr, *prv_ptr;
+    int pub_len, prv_len;
+    ERL_NIF_TERM ret_pub, ret_prv, ret = atom_undefined;
+
+    /* Fetch parameters and assign them to params[] */
+    if (argv[0] != atom_undefined)
+        if (!get_ossl_BN_param_from_bin(env, "priv",  argv[0], &params[i++]))  {
+            ret = EXCP_BADARG_N(env, 0, "PrivKeyIn");
+            goto done;
+        }
+
+    { /*argv[1] - the lists [P,G] */
+        ERL_NIF_TERM head, tail;
+
+        head = argv[1];
+        if (!get_ossl_param_from_bin_in_list(env, "p",  &head, &params[i++]) ) {
+            ret = EXCP_BADARG_N(env, 1, "Bad value of 'p'");
+            goto done;
+        }
+
+        if (!get_ossl_param_from_bin_in_list(env, "g",  &head, &params[i++]) ) {
+            ret = EXCP_BADARG_N(env, 1, "Bad value of 'g'");
+            goto done;
+        }
+
+        tail = head;
+        if (!enif_is_empty_list(env,tail)) {
+            ret = EXCP_BADARG_N(env, 1, "Not a two-element list");
+            goto done;
+        }
+    }
+
+    /* argv[2] is always hardcoded to 0 in crypto.erl. A left over from some older version?
+       Let's skip that one
+    */
+
+    /* argv[3] is the length of the private key that is to be generated */
+    if (!enif_get_ulong(env, argv[3], &len) ||
+        (len > LONG_MAX) ) {
+        ret = EXCP_BADARG_N(env, 3, "Bad value of length element");
+        goto done;
+    }
+    else if (len)
+        params[i++] = OSSL_PARAM_construct_uint64("priv_len", &len);
+
+    /* End of parameter fetching */
+    params[i++] = OSSL_PARAM_construct_end();
+
+    pctx = EVP_PKEY_CTX_new_from_name(NULL, "DH", NULL);
+
+    if (EVP_PKEY_fromdata_init(pctx) <= 0) {
+        ret = EXCP_ERROR(env, "Can't init fromdata");
+        goto done;
+    }
+    if (EVP_PKEY_fromdata(pctx, &pkey, EVP_PKEY_KEYPAIR, params) <= 0) {
+        ret = EXCP_ERROR(env, "Can't do fromdata");
+        goto done;
+    }
+
+    /* Generate a new pkey from the data in the old */
+    
+    pctx_gen = EVP_PKEY_CTX_new_from_pkey(NULL, pkey, NULL);
+        
+    if (!EVP_PKEY_keygen_init(pctx_gen)) {
+        ret = EXCP_ERROR(env, "Can't init DH generation");
+        goto done;
+    }
+
+    if (!EVP_PKEY_CTX_set_params(pctx_gen, params))  {
+        ret = EXCP_ERROR(env, "Can't set params");
+        goto done;
+    }
+
+    if (!EVP_PKEY_generate(pctx_gen, &pkey_gen)) {
+        ret = EXCP_ERROR(env, "Can't generate DH key pair");
+        goto done;
+    }
+    
+    /* Finally return the OTP representation of the keys: */
+
+    if (!EVP_PKEY_get_bn_param(pkey_gen, "pub",  &pub_key_gen)) {
+        ret = EXCP_ERROR(env, "Can't get public key");
+        goto done;
+    }
+    if ((pub_len = BN_num_bytes(pub_key_gen)) < 0 ||
+        (pub_ptr = enif_make_new_binary(env, (size_t)pub_len, &ret_pub)) == NULL ||
+        BN_bn2bin(pub_key_gen, pub_ptr) < 0)
+        {
+            ret = EXCP_ERROR(env, "Can't convert public key");
+            goto done;
+        }
+
+    if (!EVP_PKEY_get_bn_param(pkey_gen, "priv",  &priv_key_gen)) {
+        ret = EXCP_ERROR(env, "Can't get private key");
+        goto done;
+    }
+    if ((prv_len = BN_num_bytes(priv_key_gen)) < 0 ||
+        (prv_ptr = enif_make_new_binary(env, (size_t)prv_len, &ret_prv)) == NULL ||
+        BN_bn2bin(priv_key_gen, prv_ptr) < 0)
+        {
+            ret = EXCP_ERROR(env, "Can't convert private key");
+            goto done;
+        }
+
+    ERL_VALGRIND_MAKE_MEM_DEFINED(pub_ptr, pub_len);
+    ERL_VALGRIND_MAKE_MEM_DEFINED(prv_ptr, prv_len);
+
+    ret = enif_make_tuple2(env, ret_pub, ret_prv);
+
+ done:
+    if (pub_key_gen)  BN_free(pub_key_gen);
+    if (priv_key_gen) BN_free(priv_key_gen);
+    if (pkey) EVP_PKEY_free(pkey);
+    if (pkey_gen) EVP_PKEY_free(pkey_gen);
+    if (pctx) EVP_PKEY_CTX_free(pctx);
+    if (pctx_gen) EVP_PKEY_CTX_free(pctx_gen);
+
+    return ret;
+}
+
+/* Has 3_0 */
+ERL_NIF_TERM dh_compute_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
+{/* (OthersPublicKey, MyPrivateKey, DHParams=[P,G]) */
+    ERL_NIF_TERM ret;
+    ErlNifBinary ret_bin;
+    size_t sz;
+    int ret_bin_alloc = 0;
+    int i = 0;
+    OSSL_PARAM params[5];
+    EVP_PKEY_CTX *own_pctx = NULL, *peer_pctx = NULL, *pctx_gen = NULL;
+    EVP_PKEY *own_pkey = NULL, *peer_pkey = NULL;
+
+    /* Fetch parameters */
+
+    /* Build peer_pkey */
+    
+    if (!get_ossl_BN_param_from_bin(env, "pub",  argv[0], &params[i++]))
+        assign_goto(ret, err, EXCP_BADARG_N(env, 0, "Bad peer public key; binary expected"));
+
+    { /*argv[2] - the lists [P,G] */
+        ERL_NIF_TERM head, tail;
+
+        head = argv[2];
+        if (!get_ossl_param_from_bin_in_list(env, "p",  &head, &params[i++]))
+            assign_goto(ret, err, EXCP_BADARG_N(env, 2, "Bad value of 'p'"));
+
+        if (!get_ossl_param_from_bin_in_list(env, "g",  &head, &params[i++]))
+            assign_goto(ret, err, EXCP_BADARG_N(env, 2, "Bad value of 'g'"));
+
+        tail = head;
+        if (!enif_is_empty_list(env,tail))
+            assign_goto(ret, err, EXCP_BADARG_N(env, 2, "Not a two-element list"));
+    }
+
+    params[i++] = OSSL_PARAM_construct_end();
+
+    peer_pctx = EVP_PKEY_CTX_new_from_name(NULL, "DH", NULL);
+
+    if (EVP_PKEY_fromdata_init(peer_pctx) <= 0)
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't init fromdata"));
+    if (EVP_PKEY_fromdata(peer_pctx, &peer_pkey, EVP_PKEY_KEYPAIR, params) <= 0)
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't do fromdata"));
+
+    /* Build own_pkey. Just replace the pub key with the priv key in params */
+    if (!get_ossl_BN_param_from_bin(env, "priv",  argv[1], &params[0]))
+        assign_goto(ret, err, EXCP_BADARG_N(env, 0, "Bad peer public key; binary expected"));
+
+    own_pctx = EVP_PKEY_CTX_new_from_name(NULL, "DH", NULL);
+
+    if (EVP_PKEY_fromdata_init(own_pctx) <= 0)
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't init fromdata"));
+
+    if (EVP_PKEY_fromdata(own_pctx, &own_pkey, EVP_PKEY_KEYPAIR, params) <= 0)
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't do fromdata"));
+
+
+    /* Derive the common secret */
+    pctx_gen = EVP_PKEY_CTX_new(own_pkey, NULL);
+    
+    if (!EVP_PKEY_derive_init(pctx_gen))
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_derive_init"));
+
+    if (!EVP_PKEY_derive_set_peer(pctx_gen, peer_pkey))
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't derive secret or set peer"));
+    
+    if (!EVP_PKEY_derive(pctx_gen, NULL, &sz))
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't get result size"));
+
+    if (!enif_alloc_binary(sz, &ret_bin))
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't allcate binary"));
+    ret_bin_alloc = 1;
+
+    if (!EVP_PKEY_derive(pctx_gen, ret_bin.data, &ret_bin.size))
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't get result"));
+
+    if (sz != ret_bin.size)
+        if (!enif_realloc_binary(&ret_bin, ret_bin.size))
+            assign_goto(ret, err, EXCP_ERROR(env, "Can't realloc binary"));
+    
+    ret = enif_make_binary(env, &ret_bin);
+    ret_bin_alloc = 0;
+
+ err:
+    if (ret_bin_alloc)  enif_release_binary(&ret_bin);
+    if (peer_pctx) EVP_PKEY_CTX_free(peer_pctx);
+    if (peer_pkey) EVP_PKEY_free(peer_pkey);
+    if (own_pctx) EVP_PKEY_CTX_free(own_pctx);
+    if (own_pkey) EVP_PKEY_free(own_pkey);
+    if (pctx_gen) EVP_PKEY_CTX_free(pctx_gen);
+    return ret;
+}
+
+# else
+/* Has not 3.0 */
 ERL_NIF_TERM dh_generate_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 {/* (PrivKey|undefined, DHParams=[P,G], Mpint, Len|0) */
-#ifdef HAVE_DH
     DH *dh_params = NULL;
     unsigned int mpint; /* 0 or 4 */
     ERL_NIF_TERM head, tail;
@@ -36,52 +275,52 @@ ERL_NIF_TERM dh_generate_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM ar
     int pub_len, prv_len;
     ERL_NIF_TERM ret_pub, ret_prv, ret;
     const BIGNUM *pub_key_gen, *priv_key_gen;
-#if defined(HAS_EVP_PKEY_CTX) && (! DISABLE_EVP_DH)
+#  if defined(HAS_EVP_PKEY_CTX) && (! DISABLE_EVP_DH)
     EVP_PKEY_CTX *ctx = NULL;
     EVP_PKEY *dhkey = NULL, *params = NULL;
-#endif
+#  endif
 
     ASSERT(argc == 4);
 
     if (argv[0] != atom_undefined) {
         if (!get_bn_from_bin(env, argv[0], &priv_key_in))
-            goto bad_arg;
+            assign_goto(ret, err, EXCP_BADARG_N(env, 0, "Can't get bignum from binary"));
     }
     if (!enif_get_list_cell(env, argv[1], &head, &tail))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 1, "List with exactly two elements expected"));
     if (!get_bn_from_bin(env, head, &dh_p))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 1, "Can't get bignum from binary"));
 
     if (!enif_get_list_cell(env, tail, &head, &tail))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 1, "List with exactly two elements expected"));
     if (!get_bn_from_bin(env, head, &dh_g))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 1, "Can't get bignum from binary"));
 
     if (!enif_is_empty_list(env, tail))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 1, "List with exactly two elements expected"));
 
     if (!enif_get_uint(env, argv[2], &mpint))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 2, "Integer expected"));
     if (mpint != 0 && mpint != 4)
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 2, "Integer 0 or 4 expected"));
 
     if (!enif_get_ulong(env, argv[3], &len))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 3, "Integer expected"));
     if (len > LONG_MAX)
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 3, "Too big integer"));
 
     /* Load dh_params with values to use by the generator.
        Mem mgmnt transferred from dh_p etc to dh_params */
     if ((dh_params = DH_new()) == NULL)
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't do DH_new"));
     if (priv_key_in) {
         if (!DH_set0_key(dh_params, NULL, priv_key_in))
-            goto bad_arg;
+            assign_goto(ret, err, EXCP_BADARG_N(env, 0, "Not accepted as private key"));
         /* On success, dh_params owns priv_key_in */
         priv_key_in = NULL;
     }
     if (!DH_set0_pqg(dh_params, dh_p, NULL, dh_g))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 1, "P and/or G not accepted"));
     dh_p_shared = dh_p; /* Don't free this because dh_params owns it */
     /* On success, dh_params owns dh_p and dh_g */
     dh_p = NULL;
@@ -91,56 +330,56 @@ ERL_NIF_TERM dh_generate_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM ar
         int bn_len;
 
         if ((bn_len = BN_num_bits(dh_p_shared)) < 0)
-            goto bad_arg;
+            assign_goto(ret, err, EXCP_ERROR(env, "BN_num_bits < 0"));
         dh_p_shared = NULL;  /* dh_params owns the reference */
         if (len >= (size_t)bn_len)
-            goto bad_arg;
+            assign_goto(ret, err, EXCP_ERROR_N(env, 3, "Too big length"));
 
         if (!DH_set_length(dh_params, (long)len))
-            goto bad_arg;
+            assign_goto(ret, err, EXCP_ERROR_N(env, 3, "The length is not accepted"));
     }
 
-#if defined(HAS_EVP_PKEY_CTX) && (! DISABLE_EVP_DH)
+#  if defined(HAS_EVP_PKEY_CTX) && (! DISABLE_EVP_DH)
     if ((params = EVP_PKEY_new()) == NULL)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_new"));
 
    /* set the key referenced by params to dh_params... */
     if (EVP_PKEY_set1_DH(params, dh_params) != 1)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_set1_DH"));
 
     if ((ctx = EVP_PKEY_CTX_new(params, NULL)) == NULL)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_CTX_new"));
 
     if (EVP_PKEY_keygen_init(ctx) != 1)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_keygen_init"));
 
     if ((dhkey = EVP_PKEY_new()) == NULL)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_new"));
 
     /* key gen op, key written to ppkey (=last arg) */
     if (EVP_PKEY_keygen(ctx, &dhkey) != 1)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_keygen"));
 
     DH_free(dh_params);
     if ((dh_params = EVP_PKEY_get1_DH(dhkey)) == NULL)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_get1_DH"));
 
-#else
+#  else
     if (!DH_generate_key(dh_params))
-        goto err;
-#endif
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't DH_generate_key"));
+#  endif
 
     DH_get0_key(dh_params, &pub_key_gen, &priv_key_gen);
 
     if ((pub_len = BN_num_bytes(pub_key_gen)) < 0)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't get public key length"));
     if ((prv_len = BN_num_bytes(priv_key_gen)) < 0)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't get private key length"));
 
     if ((pub_ptr = enif_make_new_binary(env, (size_t)pub_len+mpint, &ret_pub)) == NULL)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate pub_ptr"));
     if ((prv_ptr = enif_make_new_binary(env, (size_t)prv_len+mpint, &ret_prv)) == NULL)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate prv_ptr"));
 
     if (mpint) {
         put_uint32(pub_ptr, (unsigned int)pub_len);
@@ -151,9 +390,9 @@ ERL_NIF_TERM dh_generate_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM ar
     }
 
     if (BN_bn2bin(pub_key_gen, pub_ptr) < 0)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't BN_bn2bin"));
     if (BN_bn2bin(priv_key_gen, prv_ptr) < 0)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't BN_bn2bin"));
 
     ERL_VALGRIND_MAKE_MEM_DEFINED(pub_ptr, pub_len);
     ERL_VALGRIND_MAKE_MEM_DEFINED(prv_ptr, prv_len);
@@ -161,13 +400,7 @@ ERL_NIF_TERM dh_generate_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM ar
     ret = enif_make_tuple2(env, ret_pub, ret_prv);
     goto done;
 
- bad_arg:
-    ret = enif_make_badarg(env);
-    goto done;
-
  err:
-    ret = atom_error;
-
  done:
     if (priv_key_in)
         BN_free(priv_key_in);
@@ -178,24 +411,21 @@ ERL_NIF_TERM dh_generate_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM ar
     if (dh_params)
         DH_free(dh_params);
 
-#if defined(HAS_EVP_PKEY_CTX) && (! DISABLE_EVP_DH)
+#  if defined(HAS_EVP_PKEY_CTX) && (! DISABLE_EVP_DH)
     if (ctx)
         EVP_PKEY_CTX_free(ctx);
     if (dhkey)
         EVP_PKEY_free(dhkey);
     if (params)
         EVP_PKEY_free(params);
-#endif
+#  endif
 
     return ret;
-#else
-    return enif_raise_exception(env, atom_notsup);
-#endif
 }
 
+
 ERL_NIF_TERM dh_compute_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 {/* (OthersPublicKey, MyPrivateKey, DHParams=[P,G]) */
-#ifdef HAVE_DH
     BIGNUM *other_pub_key = NULL;
     BIGNUM *dh_p = NULL;
     BIGNUM *dh_g = NULL;
@@ -216,22 +446,22 @@ ERL_NIF_TERM dh_compute_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM arg
     ASSERT(argc == 3);
 
     if (!get_bn_from_bin(env, argv[0], &other_pub_key))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 0, "Can't get bignum from binary"));
     if (!get_bn_from_bin(env, argv[1], &priv_key))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 1, "Can't get bignum from binary"));
 
     if (!enif_get_list_cell(env, argv[2], &head, &tail))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 2, "List with exactly two elements expected"));
     if (!get_bn_from_bin(env, head, &dh_p))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 2, "Can't get bignum from binary"));
 
     if (!enif_get_list_cell(env, tail, &head, &tail))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 2, "List with exactly two elements expected"));
     if (!get_bn_from_bin(env, head, &dh_g))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 2, "Can't get bignum from binary"));
 
     if (!enif_is_empty_list(env, tail))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 2, "List with exactly two elements expected"));
 
     /* Note: DH_set0_key() does not allow setting only the
      * private key, although DH_compute_key() does not use the
@@ -239,48 +469,45 @@ ERL_NIF_TERM dh_compute_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM arg
      * the public key to a copy of the private key.
      */
     if ((dummy_pub_key = BN_dup(priv_key)) == NULL)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't BN_dup"));
     if ((dh_priv = DH_new()) == NULL)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't DH_new"));
 
     if (!DH_set0_key(dh_priv, dummy_pub_key, priv_key))
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't DH_set0_key"));
     /* dh_priv owns dummy_pub_key and priv_key now */
     dummy_pub_key = NULL;
     priv_key = NULL;
 
     if (!DH_set0_pqg(dh_priv, dh_p, NULL, dh_g))
-        goto err;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 2, "P and/or G not accepted"));
     /* dh_priv owns dh_p and dh_g now */
     dh_p = NULL;
     dh_g = NULL;
 
     if ((dh_size = DH_size(dh_priv)) < 0)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't DH_size"));
     if (!enif_alloc_binary((size_t)dh_size, &ret_bin))
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't allcate binary"));
     ret_bin_alloc = 1;
 
     if ((size = DH_compute_key(ret_bin.data, other_pub_key, dh_priv)) < 0)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't DH_compute_key"));
     if (size == 0)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "size == 0"));
 
     if ((size_t)size != ret_bin.size) {
         if (!enif_realloc_binary(&ret_bin, (size_t)size))
-            goto err;
+            assign_goto(ret, err, EXCP_ERROR(env, "Can't realloc binary"));
     }
 
     ret = enif_make_binary(env, &ret_bin);
     ret_bin_alloc = 0;
     goto done;
 
- bad_arg:
  err:
     if (ret_bin_alloc)
         enif_release_binary(&ret_bin);
-    ret = enif_make_badarg(env);
-
  done:
     if (other_pub_key)
         BN_free(other_pub_key);
@@ -296,7 +523,10 @@ ERL_NIF_TERM dh_compute_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM arg
         DH_free(dh_priv);
 
     return ret;
-#else
-    return enif_raise_exception(env, atom_notsup);
-#endif
 }
+
+# endif /* else part of HAS_3_0_API  */
+
+
+
+#endif /* HAVE_DH */
diff --git a/lib/crypto/c_src/dss.c b/lib/crypto/c_src/dss.c
index 7669155db6..2e19453e50 100644
--- a/lib/crypto/c_src/dss.c
+++ b/lib/crypto/c_src/dss.c
@@ -23,6 +23,117 @@
 
 #ifdef HAVE_DSA
 
+# ifdef HAS_3_0_API
+
+int get_dss_private_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
+// HAS_3_0_API
+{
+    /* key=[P,Q,G,PRIV_KEY] */
+    ERL_NIF_TERM head, tail;
+    OSSL_PARAM params[5];
+    EVP_PKEY_CTX *ctx = NULL;
+    int i = 0;
+    
+    head = key;
+
+    // https://www.openssl.org/docs/man3.0/man7/EVP_PKEY-FFC.html
+    if (!get_ossl_param_from_bin_in_list(env, "p",    &head, &params[i++]) ||
+        !get_ossl_param_from_bin_in_list(env, "q",    &head, &params[i++]) ||
+        !get_ossl_param_from_bin_in_list(env, "g",    &head, &params[i++]) ||
+        !get_ossl_param_from_bin_in_list(env, "priv", &head, &params[i++]))
+        goto bad_arg;
+
+    params[i++] = OSSL_PARAM_construct_end();
+
+    tail = head;
+    if (!enif_is_empty_list(env,tail))
+        goto err;
+
+    if ((ctx = EVP_PKEY_CTX_new_from_name(NULL, "DSA", NULL)) == NULL)
+        goto err;
+    if (EVP_PKEY_fromdata_init(ctx) <= 0)
+        goto err;
+    if (EVP_PKEY_fromdata(ctx, pkey, EVP_PKEY_KEYPAIR, params) <= 0)
+        goto bad_arg;
+
+    if (ctx) EVP_PKEY_CTX_free(ctx);
+    return 1;
+
+bad_arg:
+err:
+    if (ctx) EVP_PKEY_CTX_free(ctx);
+    return 0;
+}
+
+int get_dss_public_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
+// HAS_3_0_API
+{
+    /* key=[P, Q, G, PUB_KEY (=Y)] */
+    ERL_NIF_TERM head, tail;
+    OSSL_PARAM params[5];
+    EVP_PKEY_CTX *ctx = NULL;
+    int i = 0;
+    
+    head = key;
+
+    // https://www.openssl.org/docs/man3.0/man7/EVP_PKEY-FFC.html
+    if (!get_ossl_param_from_bin_in_list(env, "p",   &head, &params[i++]) ||
+        !get_ossl_param_from_bin_in_list(env, "q",   &head, &params[i++]) ||
+        !get_ossl_param_from_bin_in_list(env, "g",   &head, &params[i++]) ||
+        !get_ossl_param_from_bin_in_list(env, "pub", &head, &params[i++]))
+        goto bad_arg;
+
+    params[i++] = OSSL_PARAM_construct_end();
+
+    tail = head;
+    if (!enif_is_empty_list(env,tail))
+        goto err;
+
+    if ((ctx = EVP_PKEY_CTX_new_from_name(NULL, "DSA", NULL)) == NULL)
+        goto err;
+    if (EVP_PKEY_fromdata_init(ctx) <= 0)
+        goto err;
+    if (EVP_PKEY_fromdata(ctx, pkey, EVP_PKEY_PUBLIC_KEY, params) <= 0)
+        goto bad_arg;
+
+    if (ctx) EVP_PKEY_CTX_free(ctx);
+    return 1;
+
+bad_arg:
+err:
+    if (ctx) EVP_PKEY_CTX_free(ctx);
+    return 0;
+}
+
+
+int dss_privkey_to_pubkey(ErlNifEnv* env, EVP_PKEY *pkey, ERL_NIF_TERM *ret)
+// HAS_3_0_API
+{
+    ERL_NIF_TERM result[5];
+    BIGNUM *p = NULL, *q = NULL, *g = NULL, *pub = NULL;
+
+    if (
+        !EVP_PKEY_get_bn_param(pkey, "p", &p)
+        || !EVP_PKEY_get_bn_param(pkey, "q", &q)
+        || !EVP_PKEY_get_bn_param(pkey, "g", &g)
+        || !EVP_PKEY_get_bn_param(pkey, "pub", &pub)
+        || ((result[0] = bin_from_bn(env, p)) == atom_error)
+        || ((result[1] = bin_from_bn(env, q)) == atom_error)
+        || ((result[1] = bin_from_bn(env, g)) == atom_error)
+        || ((result[1] = bin_from_bn(env, pub)) == atom_error)
+        )
+        goto err;
+
+    *ret =  enif_make_list_from_array(env, result, 4);
+    return 1;
+
+ err:
+    return 0;
+}
+
+# else
+/* Has NOT 3.0 API */
+
 int get_dss_private_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
 {
     /* key=[P,Q,G,KEY] */
@@ -78,6 +189,7 @@ int get_dss_private_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
     dummy_pub_key = NULL;
     priv_key = NULL;
 
+    *pkey = EVP_PKEY_new();
     if (EVP_PKEY_assign_DSA(*pkey, dsa) != 1)
         goto err;
     /* On success, result owns dsa */
@@ -144,6 +256,7 @@ int get_dss_public_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
     /* dsa takes ownership on success */
     dsa_y = NULL;
 
+    *pkey = EVP_PKEY_new();
     if (EVP_PKEY_assign_DSA(*pkey, dsa) != 1)
         goto err;
     /* On success, result owns dsa */
@@ -195,4 +308,6 @@ int dss_privkey_to_pubkey(ErlNifEnv* env, EVP_PKEY *pkey, ERL_NIF_TERM *ret)
     return 0;
 }
 
-#endif
+# endif /* HAS_3_0_API */
+
+#endif /* HAVE_DSA */
diff --git a/lib/crypto/c_src/ec.c b/lib/crypto/c_src/ec.c
index b52aeed6ea..124582c4f8 100644
--- a/lib/crypto/c_src/ec.c
+++ b/lib/crypto/c_src/ec.c
@@ -1,7 +1,7 @@
 /*
  * %CopyrightBegin%
  *
- * Copyright Ericsson AB 2010-2021. All Rights Reserved.
+ * Copyright Ericsson AB 2010-2022. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,21 +22,456 @@
 #include "bn.h"
 
 #ifdef HAVE_EC
-static EC_KEY* ec_key_new(ErlNifEnv* env, ERL_NIF_TERM curve_arg, size_t *size);
-static ERL_NIF_TERM point2term(ErlNifEnv* env,
-			       const EC_GROUP *group,
-			       const EC_POINT *point,
-			       point_conversion_form_t form);
+# if defined(HAS_3_0_API)
 
-ERL_NIF_TERM make_badarg_maybe(ErlNifEnv* env)
+int get_curve_definition(ErlNifEnv* env, ERL_NIF_TERM *ret, ERL_NIF_TERM def,
+                         OSSL_PARAM params[], int *i,
+                         size_t *order_size)
 {
-    ERL_NIF_TERM reason;
-    if (enif_has_pending_exception(env, &reason))
-	return reason; /* dummy return value ignored */
+    const ERL_NIF_TERM* curve;
+    int c_arity = -1;
+    const ERL_NIF_TERM *prime;
+    int p_arity = -1;
+    const ERL_NIF_TERM *field;
+    int f_arity = -1;
+    BIGNUM *p = NULL;
+    int arity = -1;
+    const ERL_NIF_TERM* curve_tuple;
+
+    /* Here are two random curve definition examples, one prime_field and
+       one characteristic_two_field. Both are from the crypto/src/crypto_ec_curves.erl.
+
+        curve(secp192r1) ->
+           {
+            {prime_field, <<16#FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF:192>>}, %% Prime
+            {<<16#FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC:192>>,               %% A
+             <<16#64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1:192>>,               %% B
+             <<16#3045AE6FC8422F64ED579528D38120EAE12196D5:160>>},                      %% Seed
+             <<16#04:8,
+               16#188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012:192,                 %% X(p0)
+               16#07192B95FFC8DA78631011ED6B24CDD573F977A11E794811:192>>,               %% Y(p0)
+             <<16#FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831:192>>,               %% Order
+             <<16#01:8>>                                                                %% CoFactor
+           };
+
+        curve(c2pnb176v1) ->
+           {
+            {characteristic_two_field, 176, {ppbasis,1,2,43}},
+            {<<16#E4E6DB2995065C407D9D39B8D0967B96704BA8E9C90B:176>>,                   %% A
+             <<16#5DDA470ABE6414DE8EC133AE28E9BBD7FCEC0AE0FFF2:176>>,                   %% B
+             none},                                                                     %% Seed
+             <<16#04:8,
+               16#8D16C2866798B600F9F08BB4A8E860F3298CE04A5798:176,                     %% X(p0)
+               16#6FA4539C2DADDDD6BAB5167D61B436E1D92BB16A562C:176>>,                   %% Y(p0)
+             <<16#010092537397ECA4F6145799D62B0A19CE06FE26AD:168>>,                     %% Order
+             <<16#FF6E:16>>                                                             %% CoFactor
+           };
+    */
+
+    /* Separate the curve definition from the curve name */
+    if (!enif_get_tuple(env, def, &arity, &curve_tuple) || (arity != 2))
+        assign_goto(*ret, err, EXCP_ERROR(env, "Tuple arity 2 expected."));
+
+    /* {Field, Prime, Point, Order, CoFactor} = CurveDef */
+    if (!enif_get_tuple(env, curve_tuple[0], &c_arity, &curve) ||
+        c_arity != 5)
+        assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad curve def. Expect 5-tuple."));
+
+    if (!get_ossl_octet_string_param_from_bin(env, "generator", curve[2], &params[(*i)++]))
+        assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad Generator (Point)"));
+
+    if (!get_ossl_BN_param_from_bin_sz(env, "order", curve[3], &params[(*i)++], order_size))
+        assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad order"));
+
+    if (curve[4] == atom_none)
+        assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Cofactor must be != none"));
+                
+    if (!get_ossl_BN_param_from_bin(env, "cofactor", curve[4], &params[(*i)++]))
+        assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad cofactor"));
+
+    /* {A, B, Seed} = Prime = curve[1] */
+    if (!enif_get_tuple(env, curve[1], &p_arity, &prime))
+        assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad Prime"));
+
+    if (!get_ossl_BN_param_from_bin(env, "a", prime[0], &params[(*i)++]))
+        assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad a"));
+
+    if (!get_ossl_BN_param_from_bin(env, "b", prime[1], &params[(*i)++]))
+        assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad b"));
+
+    if (enif_is_binary(env, prime[2]))
+        if (!get_ossl_octet_string_param_from_bin(env, "seed", prime[2], &params[(*i)++]))
+            assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad seed"));
+
+    /* Field = curve[0] */
+    if (!enif_get_tuple(env, curve[0], &f_arity, &field)) {
+        assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad Field"));
+    }
+    else if (f_arity == 2 && field[0] == atom_prime_field) {
+        /* {prime_field, Prime} */
+        params[(*i)++] = OSSL_PARAM_construct_utf8_string("field-type",  "prime-field", 0);
+                
+        if (!get_ossl_BN_param_from_bin(env, "p", field[1], &params[(*i)++]))
+            assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad p (Prime)"));
+    }
+
+    else if (f_arity == 3 && field[0] == atom_characteristic_two_field) {
+        /* {characteristic_two_field, M, Basis} */
+#  if defined(OPENSSL_NO_EC2M)
+        assign_goto(*ret, err, EXCP_NOTSUP_N(env, 1, "Unsupported field-type (characteristic_two_field)"));
+#  else
+        int b_arity = -1;
+        const ERL_NIF_TERM* basis;
+        long field_bits;
+
+        params[(*i)++] = OSSL_PARAM_construct_utf8_string("field-type",  "characteristic-two-field", 0);
+
+        if ((p = BN_new()) == NULL)
+            assign_goto(*ret, err, EXCP_ERROR(env, "Creating bignum failed"));
+
+        if (!enif_get_long(env, field[1], &field_bits) ||
+            (field_bits > OPENSSL_ECC_MAX_FIELD_BITS || field_bits > INT_MAX)
+            )
+            assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad field-bits (M)"));
+                    
+        if (enif_get_tuple(env, field[2], &b_arity, &basis)) {
+            if (b_arity == 2) {
+                unsigned int k1;
+
+                if (basis[0] != atom_tpbasis)
+                    assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad atom"));
+                if (!enif_get_uint(env, basis[1], &k1))
+                    assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "uint expected (k1)"));
+
+                /* {tpbasis, k} = Basis */
+                if (field_bits <= k1 || k1 == 0 || k1 > INT_MAX)
+                    assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "bad values (field_bits or k1)"));
+
+                /* create the polynomial */
+                if (!BN_set_bit(p, (int)field_bits) ||
+                    !BN_set_bit(p, (int)k1) ||
+                    !BN_set_bit(p, 0))
+                    assign_goto(*ret, err, EXCP_ERROR(env, "Polynom bit setting failed"));
+
+            } else if (b_arity == 4) {
+                /* {ppbasis, k1, k2, k3} = Basis */
+                unsigned int k1, k2, k3;
+
+                if (basis[0] != atom_ppbasis)
+                    assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad atom"));
+
+                if (!enif_get_uint(env, basis[1], &k1) ||
+                    !enif_get_uint(env, basis[2], &k2) ||
+                    !enif_get_uint(env, basis[3], &k3))
+                    assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Expecting uint (k1,k2,k3)"));
+
+                if (field_bits <= k3 || k3 <= k2 || k2 <= k1 || k1 == 0 ||
+                    k3 > INT_MAX || k2 > INT_MAX || k1 > INT_MAX)
+                    assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "bad values (field_bits, k1, k2 or k3)"));
+
+                /* create the polynomial */
+                if (!BN_set_bit(p, (int)field_bits) ||
+                    !BN_set_bit(p, (int)k1) ||
+                    !BN_set_bit(p, (int)k2) ||
+                    !BN_set_bit(p, (int)k3) ||
+                    !BN_set_bit(p, 0) )
+                    assign_goto(*ret, err, EXCP_ERROR(env, "Polynom bit setting failed"));
+
+            } else
+                assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad tuple"));
+
+        } else if (field[2] == atom_onbasis) {
+            /* onbasis = Basis */
+            /* no parameters */
+            assign_goto(*ret, err, EXCP_NOTSUP_N(env, 1, "'onbasis' not supported"));
+        } else
+            assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad last field"));
+
+        {
+            ErlNifBinary tmp;
+                        
+            if (!enif_inspect_binary(env, bin_from_bn(env,p), &tmp) || // Allocate buf
+                BN_bn2nativepad(p, tmp.data, tmp.size) < 0) {// Fill with BN in right endianity
+                assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "BN padding failed"));
+            }
+            params[(*i)++] = OSSL_PARAM_construct_BN("p", tmp.data, tmp.size);
+        }
+#  endif
+    }
     else
-	return enif_make_badarg(env);
+        assign_goto(*ret, err, EXCP_ERROR_N(env, 1, "Bad field-type")); 
+
+    if (p) BN_free(p);
+    return 1;
+    
+ err:
+    if (p) BN_free(p);
+    return 0;
+}
+
+int get_ec_public_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
+{ /* key :: {CurveDef::{_,_,_,_,_}, PubKey::binary()} */
+    ERL_NIF_TERM ret = atom_undefined;
+    const ERL_NIF_TERM *tpl_terms;
+    int tpl_arity;
+    int i = 0;
+    OSSL_PARAM params[15];
+    EVP_PKEY_CTX *pctx = NULL;
+    
+    if (!enif_get_tuple(env, key, &tpl_arity, &tpl_terms) ||
+        (tpl_arity != 2) ||
+        !enif_is_tuple(env, tpl_terms[0]) ||
+        !enif_is_binary(env, tpl_terms[1]) )
+        assign_goto(ret, err, EXCP_BADARG_N(env, 0, "Bad public key format"));
+    
+    if (!get_ossl_octet_string_param_from_bin(env, "pub",  tpl_terms[1], &params[i++]))
+        assign_goto(ret, err, EXCP_BADARG_N(env, 0, "Bad public key"));
+
+    if (!get_curve_definition(env, &ret, tpl_terms[0], params, &i, NULL))
+        goto err;
+
+    params[i++] = OSSL_PARAM_construct_end();
+
+    if (!(pctx = EVP_PKEY_CTX_new_from_name(NULL, "EC", NULL)))
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't make EVP_PKEY_CTX"));
+
+    if (EVP_PKEY_fromdata_init(pctx) <= 0)
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't init fromdata"));
+    
+    if (EVP_PKEY_fromdata(pctx, pkey, EVP_PKEY_PUBLIC_KEY, params) <= 0)
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't do fromdata"));
+
+    if (!*pkey)
+        assign_goto(ret, err, EXCP_ERROR(env, "Couldn't get a public key"));
+
+    if (pctx) EVP_PKEY_CTX_free(pctx);
+    return 1;
+
+ err:
+    if (pctx) EVP_PKEY_CTX_free(pctx);
+    return 0;
 }
 
+
+int get_ec_private_key_2(ErlNifEnv* env,
+                         ERL_NIF_TERM curve, ERL_NIF_TERM key,
+                         EVP_PKEY **pkey,
+                         ERL_NIF_TERM *ret,
+                         size_t *order_size);
+
+int get_ec_private_key_2(ErlNifEnv* env,
+                         ERL_NIF_TERM curve, ERL_NIF_TERM key,
+                         EVP_PKEY **pkey,
+                         ERL_NIF_TERM *ret,
+                         size_t *order_size)
+{
+    int i = 0;
+    OSSL_PARAM params[15];
+    EVP_PKEY_CTX *pctx = NULL;
+
+    if (!get_ossl_BN_param_from_bin(env, "priv",  key, &params[i++]))
+        assign_goto(*ret, err, EXCP_BADARG_N(env, 0, "Bad private key"));
+
+    if (!get_curve_definition(env, ret, curve, params, &i, order_size))
+        goto err;
+
+    params[i++] = OSSL_PARAM_construct_end();
+
+    if (!(pctx = EVP_PKEY_CTX_new_from_name(NULL, "EC", NULL)))
+        assign_goto(*ret, err, EXCP_ERROR(env, "Can't make EVP_PKEY_CTX"));
+
+    if (EVP_PKEY_fromdata_init(pctx) <= 0)
+        assign_goto(*ret, err, EXCP_ERROR(env, "Can't init fromdata"));
+    
+    if (EVP_PKEY_fromdata(pctx, pkey, EVP_PKEY_KEYPAIR, params) <= 0)
+        assign_goto(*ret, err, EXCP_ERROR(env, "Can't do fromdata"));
+
+    if (!*pkey)
+        assign_goto(*ret, err, EXCP_ERROR(env, "Couldn't get a private key"));
+    
+    if (pctx) EVP_PKEY_CTX_free(pctx);
+    return 1;
+
+ err:
+    if (pctx) EVP_PKEY_CTX_free(pctx);
+    return 0;
+}
+
+
+int get_ec_private_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
+{  /* key ::  {CurveDef::{_,_,_,_,_}, PrivKey::binary()}  */
+    ERL_NIF_TERM ret = atom_undefined;
+    const ERL_NIF_TERM *tpl_terms;
+    int tpl_arity;
+
+    if (!enif_get_tuple(env, key, &tpl_arity, &tpl_terms) ||
+        (tpl_arity != 2) ||
+        !enif_is_tuple(env, tpl_terms[0]) ||
+        !enif_is_binary(env, tpl_terms[1]) )
+        assign_goto(ret, err, EXCP_BADARG_N(env, 0, "Bad private key format"));
+    
+    if (!get_ec_private_key_2(env, tpl_terms[0], tpl_terms[1], pkey, &ret, NULL))
+        goto err;
+
+    return 1;
+
+ err:
+    return 0;
+}
+
+int mk_pub_key_binary(ErlNifEnv* env, EVP_PKEY **peer_pkey, ErlNifBinary *pubkey_bin, ERL_NIF_TERM *ret);
+
+ERL_NIF_TERM ec_generate_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
+{ /* (Curve, PrivKey|undefined)  */
+    ERL_NIF_TERM ret = atom_undefined;
+    int i = 0;
+    OSSL_PARAM params[15];
+    EVP_PKEY_CTX *pctx = NULL;
+    EVP_PKEY *pkey = NULL, *peer_pkey = NULL;
+    size_t sz, order_size;
+    BIGNUM *priv_bn = NULL;
+    ErlNifBinary pubkey_bin;
+    
+    if (argv[1] != atom_undefined)
+        {
+            if (!get_ec_private_key_2(env, argv[0], argv[1], &peer_pkey, &ret, &order_size))
+                goto err;
+            
+            /* Get the two keys, pub as binary and priv as BN.
+               Since the private key is explicitly given, it must be calculated.
+               I haven't found any way to do that with the pure 3.0 interface yet.
+            */
+            if (!mk_pub_key_binary(env, &peer_pkey, &pubkey_bin, &ret))
+                goto err;
+
+            if (!EVP_PKEY_get_bn_param(peer_pkey, "priv", &priv_bn))
+                assign_goto(ret, err, EXCP_BADARG_N(env, 1, "Couldn't get peer priv key bytes"));
+        }
+    else
+        {
+            /* PrivKey (that is, argv[1]) == atom_undefined */
+            if (!get_curve_definition(env, &ret, argv[0], params, &i, &order_size))
+                // INSERT "ret" parameter in get_curve_definition !!
+                assign_goto(ret, err, EXCP_BADARG_N(env, 0, "Couldn't get Curve definition"));
+    
+            params[i++] = OSSL_PARAM_construct_end();
+
+            /* Neither the private nor the public key is known, so we generate the pair: */
+            if (!(pctx = EVP_PKEY_CTX_new_from_name(NULL, "EC", NULL)))
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_CTX_new_from_name"));
+
+            if (EVP_PKEY_keygen_init(pctx) <= 0)
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_keygen_init"));
+
+            if (!EVP_PKEY_CTX_set_params(pctx, params))
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_CTX_set_params"));
+        
+            if (!EVP_PKEY_generate(pctx, &pkey))
+                assign_goto(ret, err, EXCP_ERROR(env, "Couldn't generate EC key"));
+    
+            /* Get the two keys, pub as binary and priv as BN */
+            if (!EVP_PKEY_get_octet_string_param(pkey, "encoded-pub-key", NULL, 0, &sz))
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't get pub octet string size"));
+
+            if (!enif_alloc_binary(sz, &pubkey_bin))
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate pub octet string"));
+
+            if (!EVP_PKEY_get_octet_string_param(pkey, "encoded-pub-key",
+                                                 pubkey_bin.data,
+                                                 sz,
+                                                 &pubkey_bin.size))
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't get pub octet string"));
+
+            if (!EVP_PKEY_get_bn_param(pkey, "priv", &priv_bn))
+                assign_goto(ret, err, EXCP_BADARG_N(env, 1, "Couldn't get priv key bytes"));
+        }
+
+    ret = enif_make_tuple2(env,
+                           enif_make_binary(env, &pubkey_bin),
+                           bn2term(env, order_size, priv_bn));
+ err:
+    if (pkey) EVP_PKEY_free(pkey);
+    if (peer_pkey) EVP_PKEY_free(peer_pkey);
+    if (pctx) EVP_PKEY_CTX_free(pctx);
+    if (priv_bn) BN_free(priv_bn);
+
+    return ret;
+}
+
+int mk_pub_key_binary(ErlNifEnv* env, EVP_PKEY **peer_pkey, ErlNifBinary *pubkey_bin, ERL_NIF_TERM *ret)
+{
+    EC_KEY *ec_key = NULL;
+    EC_POINT *public_key = NULL;
+    EC_GROUP *group = NULL;
+    BIGNUM *priv_bn = NULL;
+    
+    *ret = atom_undefined;
+
+    /* Use the deprecated interface to get the curve and
+       private key in pre 3.0 form: */
+    if ((ec_key = EVP_PKEY_get1_EC_KEY(*peer_pkey)) == NULL)
+        assign_goto(*ret, err, EXCP_ERROR(env, "Couldn't get EC key"));
+
+    if ((group = EC_GROUP_dup(EC_KEY_get0_group(ec_key))) == NULL)
+        assign_goto(*ret, err, EXCP_ERROR(env, "Couldn't get EC_GROUP"));
+
+    if ((public_key = EC_POINT_new(group)) == NULL)
+        assign_goto(*ret, err, EXCP_ERROR(env, "Couldn't create POINT"));
+
+    if (!EC_POINT_copy(public_key, EC_GROUP_get0_generator(group)))
+        assign_goto(*ret, err, EXCP_ERROR(env, "Couldn't copy POINT"));
+
+    /* Make the corresponding public key */
+    if (!EVP_PKEY_get_bn_param(*peer_pkey, "priv", &priv_bn))
+        assign_goto(*ret, err, EXCP_BADARG_N(env, 1, "Couldn't get peer priv key bytes"));
+
+    if (BN_is_zero(priv_bn))
+        assign_goto(*ret, err, EXCP_BADARG_N(env, 1, "peer priv key must not be 0"));
+
+    if (!EC_POINT_mul(group, public_key, priv_bn, NULL, NULL, NULL))
+        assign_goto(*ret, err, EXCP_ERROR(env, "Couldn't multiply POINT"));
+
+    if (!EC_KEY_set_public_key(ec_key, public_key))
+        assign_goto(*ret, err, EXCP_ERROR(env, "Couldn't set EC_KEY"));
+
+    if (!EVP_PKEY_assign_EC_KEY(*peer_pkey, ec_key))
+        assign_goto(*ret, err, EXCP_ERROR(env, "Couldn't assign EC_KEY to PKEY"));
+            
+    /* And now get the binary representation (by some reason we can't read it from
+       peer_pubkey in the calling function with 3.0-functions.)
+    */
+    {
+        point_conversion_form_t form = EC_KEY_get_conv_form(ec_key);
+        size_t dlen = EC_POINT_point2oct(group, public_key, form, NULL, 0, NULL);
+
+        if (!enif_alloc_binary(dlen, pubkey_bin) ||
+            !EC_POINT_point2oct(group, public_key, form, pubkey_bin->data, pubkey_bin->size, NULL)
+            )
+            assign_goto(*ret, err, EXCP_ERROR(env, "Couldn't get public key"));
+    }
+
+ err:
+    if (public_key) EC_POINT_free(public_key);
+    if (group) EC_GROUP_free(group);
+    if (priv_bn) BN_free(priv_bn);
+
+    if (*ret == atom_undefined)
+        return 1;
+    else
+        return 0;
+}
+    
+# endif /* HAS_3_0_API */
+
+
+
+
+/*----------------------------------------------------------------
+  Non 3.0-specific functions
+*/
+
+# if ! defined(HAS_3_0_API)
+
 static EC_KEY* ec_key_new(ErlNifEnv* env, ERL_NIF_TERM curve_arg, size_t *size)
 {
     EC_KEY *key = NULL;
@@ -231,6 +666,33 @@ static EC_KEY* ec_key_new(ErlNifEnv* env, ERL_NIF_TERM curve_arg, size_t *size)
     return key;
 }
 
+int term2point(ErlNifEnv* env, ERL_NIF_TERM term, EC_GROUP *group, EC_POINT **pptr)
+{
+    ErlNifBinary bin;
+    EC_POINT *point = NULL;
+
+    if (!enif_inspect_binary(env, term, &bin))
+        goto err;
+
+    if ((point = EC_POINT_new(group)) == NULL)
+        goto err;
+
+    /* set the point conversion form */
+    EC_GROUP_set_point_conversion_form(group, (point_conversion_form_t)(bin.data[0] & ~0x01));
+
+    /* extract the ec point */
+    if (!EC_POINT_oct2point(group, point, bin.data, bin.size, NULL))
+        goto err;
+
+    *pptr = point;
+    return 1;
+
+ err:
+    if (point)
+        EC_POINT_free(point);
+    return 0;
+}
+
 static ERL_NIF_TERM point2term(ErlNifEnv* env,
 			       const EC_GROUP *group,
 			       const EC_POINT *point,
@@ -266,33 +728,6 @@ static ERL_NIF_TERM point2term(ErlNifEnv* env,
     return ret;
 }
 
-int term2point(ErlNifEnv* env, ERL_NIF_TERM term, EC_GROUP *group, EC_POINT **pptr)
-{
-    ErlNifBinary bin;
-    EC_POINT *point = NULL;
-
-    if (!enif_inspect_binary(env, term, &bin))
-        goto err;
-
-    if ((point = EC_POINT_new(group)) == NULL)
-        goto err;
-
-    /* set the point conversion form */
-    EC_GROUP_set_point_conversion_form(group, (point_conversion_form_t)(bin.data[0] & ~0x01));
-
-    /* extract the ec point */
-    if (!EC_POINT_oct2point(group, point, bin.data, bin.size, NULL))
-        goto err;
-
-    *pptr = point;
-    return 1;
-
- err:
-    if (point)
-        EC_POINT_free(point);
-    return 0;
-}
-
 int get_ec_private_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
 {
     const ERL_NIF_TERM *tpl_terms;
@@ -310,6 +745,7 @@ int get_ec_private_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
     if (!get_ec_key_sz(env, tpl_terms[0], tpl_terms[1], atom_undefined, &ec, NULL))
         goto err;
 
+    *pkey = EVP_PKEY_new();
     if (EVP_PKEY_assign_EC_KEY(*pkey, ec) != 1)
         goto err;
             /* On success, result owns ec */
@@ -339,6 +775,7 @@ int get_ec_public_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
     if (!get_ec_key_sz(env, tpl_terms[0], atom_undefined, tpl_terms[1], &ec, NULL))
         goto err;
 
+    *pkey = EVP_PKEY_new();
     if (EVP_PKEY_assign_EC_KEY(*pkey, ec) != 1)
         goto err;
             /* On success, result owns ec */
@@ -361,6 +798,8 @@ int get_ec_key_sz(ErlNifEnv* env,
     BIGNUM *priv_key = NULL;
     EC_POINT *pub_key = NULL;
     EC_GROUP *group = NULL;
+    int arity = -1;
+    const ERL_NIF_TERM* curve_tuple;
 
     if (priv != atom_undefined) {
         if (!get_bn_from_bin(env, priv, &priv_key))
@@ -371,7 +810,10 @@ int get_ec_key_sz(ErlNifEnv* env,
             goto err;
     }
 
-    if ((key = ec_key_new(env, curve, size)) == NULL)
+    if (!enif_get_tuple(env, curve, &arity, &curve_tuple) || (arity != 2))
+        goto err;
+
+    if ((key = ec_key_new(env, curve_tuple[0], size)) == NULL)
         goto err;
 
     if ((group = EC_GROUP_dup(EC_KEY_get0_group(key))) == NULL)
@@ -424,11 +866,8 @@ int get_ec_key_sz(ErlNifEnv* env,
     return 1;
 }
 
-#endif /* HAVE_EC */
-
-ERL_NIF_TERM ec_key_generate(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
+ERL_NIF_TERM ec_generate_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 { /* (Curve, PrivKey)  */
-#if defined(HAVE_EC)
     EC_KEY *key = NULL;
     const EC_GROUP *group;
     const EC_POINT *public_key;
@@ -438,11 +877,11 @@ ERL_NIF_TERM ec_key_generate(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]
     size_t size;
 
     if (!get_ec_key_sz(env, argv[0], argv[1], atom_undefined, &key, &size))
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 1, "Couldn't get EC key"));
 
     if (argv[1] == atom_undefined) {
 	if (!EC_KEY_generate_key(key))
-            goto err;
+            assign_goto(ret, err, EXCP_ERROR(env, "Couldn't generate EC key"));
     }
 
     group = EC_KEY_get0_group(key);
@@ -461,15 +900,20 @@ ERL_NIF_TERM ec_key_generate(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]
     goto done;
 
  err:
- bad_arg:
-    ret = make_badarg_maybe(env);
-
  done:
     if (key)
         EC_KEY_free(key);
     return ret;
+}
 
-#else
-    return atom_notsup;
-#endif
+# endif /* ! HAS_3_0_API */
+
+#endif /* HAVE_EC */
+
+
+#if ! defined(HAVE_EC)
+ERL_NIF_TERM ec_generate_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
+{ /* (Curve, PrivKey)  */
+    return EXCP_NOTSUP_N(env, 0, "EC not supported");
 }
+#endif
diff --git a/lib/crypto/c_src/ec.h b/lib/crypto/c_src/ec.h
index e7b885cb0f..e53986d64e 100644
--- a/lib/crypto/c_src/ec.h
+++ b/lib/crypto/c_src/ec.h
@@ -1,7 +1,7 @@
 /*
  * %CopyrightBegin%
  *
- * Copyright Ericsson AB 2010-2021. All Rights Reserved.
+ * Copyright Ericsson AB 2010-2022. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,15 +24,24 @@
 #include "common.h"
 
 #if defined(HAVE_EC)
-int get_ec_public_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey);
-int get_ec_private_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey);
 
+# if defined(HAS_3_0_API)
+int get_curve_definition(ErlNifEnv* env, ERL_NIF_TERM *ret, ERL_NIF_TERM def,
+                         OSSL_PARAM params[], int *i,
+                         size_t *order_size);
+# endif /* HAS_3_0_API */
+
+# if ! defined(HAS_3_0_API)
 int get_ec_key_sz(ErlNifEnv* env, ERL_NIF_TERM curve, ERL_NIF_TERM priv, ERL_NIF_TERM pub,
                   EC_KEY** res, size_t* size);
+# endif
+
+int get_ec_public_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey);
+int get_ec_private_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey);
+
 int term2point(ErlNifEnv* env, ERL_NIF_TERM term, EC_GROUP *group, EC_POINT **pptr);
-ERL_NIF_TERM make_badarg_maybe(ErlNifEnv* env);
 #endif
 
-ERL_NIF_TERM ec_key_generate(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);
+ERL_NIF_TERM ec_generate_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);
 
 #endif /* E_EC_H__ */
diff --git a/lib/crypto/c_src/ecdh.c b/lib/crypto/c_src/ecdh.c
index 041c658808..7509d9cb84 100644
--- a/lib/crypto/c_src/ecdh.c
+++ b/lib/crypto/c_src/ecdh.c
@@ -21,15 +21,124 @@
 #include "ecdh.h"
 #include "ec.h"
 
-/*
-  (_OthersPublicKey, _MyPrivateKey)
-  (_OthersPublicKey, _MyEC_Point)
-*/
+#if !defined(HAVE_EC)
+ERL_NIF_TERM ecdh_compute_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
+/* (OtherPublicKey, {CurveDef,CurveName}, My) */
+{
+    return EXCP_NOTSUP_N(env, 0, "EC not supported");
+}
+
+#else
+
+# if defined(HAS_3_0_API)
+#  include "bn.h"
+
+ERL_NIF_TERM ecdh_compute_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
+/* (OtherPublicKey, {CurveDef,CurveName}, My) */
+{
+    ERL_NIF_TERM ret = atom_undefined;
+    ErlNifBinary ret_bin;
+    size_t sz;
+    int ret_bin_alloc = 0;
+    int i = 0, i_key = 0;
+    OSSL_PARAM params[15];
+    EVP_PKEY_CTX *own_pctx = NULL, *peer_pctx = NULL, *pctx_gen = NULL;
+    EVP_PKEY *own_pkey = NULL, *peer_pkey = NULL;
+    int err;
+    
+    /**** Fetch parameters ****/
+
+    /* Build peer_pkey */
+    i_key = i;
+    if (!get_ossl_octet_string_param_from_bin(env, "pub",  argv[0], &params[i++]))
+        assign_goto(ret, err, EXCP_BADARG_N(env, 0, "Bad peer public key; binary expected"));
+
+    /* Curve definition/name */
+    if (!get_curve_definition(env, &ret, argv[1], params, &i, NULL))
+        goto err;
+
+    /* End of params */
+    params[i++] = OSSL_PARAM_construct_end();
+
+    /* Build the remote public key in peer_pkey */
+    peer_pctx = EVP_PKEY_CTX_new_from_name(NULL, "EC", NULL);
+
+    if (EVP_PKEY_fromdata_init(peer_pctx) <= 0)
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't init fromdata"));
+    
+    if (EVP_PKEY_fromdata(peer_pctx, &peer_pkey, EVP_PKEY_PUBLIC_KEY, params) <= 0)
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't do fromdata"));
+
+    if (!peer_pkey)
+        assign_goto(ret, err, EXCP_ERROR(env, "No peer_pkey"));
+
+    /* Build the local private (and public) key in own_pkey */
+
+    /* Just replace the pub key with the priv key in params; the
+       curve definition is of course the same
+    */
+    if (!get_ossl_BN_param_from_bin(env, "priv",  argv[2], &params[i_key]))
+        assign_goto(ret, err, EXCP_BADARG_N(env, 0, "Bad peer public key; binary expected"));
+
+    own_pctx = EVP_PKEY_CTX_new_from_name(NULL, "EC", NULL);
+
+    if (EVP_PKEY_fromdata_init(own_pctx) <= 0)
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't init fromdata"));
+
+    if (EVP_PKEY_fromdata(own_pctx, &own_pkey, EVP_PKEY_KEYPAIR, params) <= 0)
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't do fromdata"));
+
+    if (!own_pkey)
+        assign_goto(ret, err, EXCP_ERROR(env, "No own_pkey"));
+
+    /**** Derive the common secret from own_pkey and peer_pkey ****/
+
+    if (!(pctx_gen = EVP_PKEY_CTX_new(own_pkey, NULL)))
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_CTX_init"));
+        
+    if (EVP_PKEY_derive_init(pctx_gen) <= 0)
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_derive_init"));
+
+    if ((err = EVP_PKEY_derive_set_peer_ex(pctx_gen, peer_pkey, 0)) <= 0)
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't derive secret or set peer"));
+    
+    if ((err = EVP_PKEY_derive(pctx_gen, NULL, &sz)) <= 0)
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't get result size"));
+
+    if (!enif_alloc_binary(sz, &ret_bin))
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't allcate binary"));
+    ret_bin_alloc = 1;
+
+    if ((err = EVP_PKEY_derive(pctx_gen, ret_bin.data, &ret_bin.size)) <=0)
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't get result"));
+
+    if (sz != ret_bin.size)
+        if (!enif_realloc_binary(&ret_bin, ret_bin.size))
+            assign_goto(ret, err, EXCP_ERROR(env, "Can't realloc binary"));
+    
+    ret = enif_make_binary(env, &ret_bin);
+    ret_bin_alloc = 0;
+
+ err:
+    if (ret_bin_alloc)  enif_release_binary(&ret_bin);
+    if (peer_pctx) EVP_PKEY_CTX_free(peer_pctx);
+    if (peer_pkey) EVP_PKEY_free(peer_pkey);
+    if (own_pctx) EVP_PKEY_CTX_free(own_pctx);
+    if (own_pkey) EVP_PKEY_free(own_pkey);
+    if (pctx_gen) EVP_PKEY_CTX_free(pctx_gen);
+    return ret;
+}
+
+# endif /* HAS_3_0_API */
+
+
+
+# if ! defined(HAS_3_0_API)
+
 ERL_NIF_TERM ecdh_compute_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
-/* (OtherPublicKey, Curve, My) */
+/* (OtherPublicKey, {CurveDef,_CurveName}, My) */
 {
-#if defined(HAVE_EC)
-    ERL_NIF_TERM ret;
+    ERL_NIF_TERM ret = atom_undefined;
     unsigned char *p;
     EC_KEY* key = NULL;
     int degree;
@@ -39,44 +148,37 @@ ERL_NIF_TERM ecdh_compute_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM a
     EC_POINT *my_ecpoint = NULL;
     EC_KEY *other_ecdh = NULL;
 
-    ASSERT(argc == 3);
-
     if (!get_ec_key_sz(env, argv[1], argv[2], atom_undefined, &key, NULL)) // my priv key
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 2, "Couldn't get local key"));
+    
     if ((group = EC_GROUP_dup(EC_KEY_get0_group(key))) == NULL)
-        goto bad_arg;
+         assign_goto(ret, err, EXCP_ERROR(env, "Couldn't duplicate EC key"));
+
     priv_key = EC_KEY_get0_private_key(key);
 
-    if (!term2point(env, argv[0], group, &my_ecpoint)) {
-        goto err;
-    }
+    if (!term2point(env, argv[0], group, &my_ecpoint))
+        assign_goto(ret, err, EXCP_BADARG_N(env, 0, "Couldn't get ecpoint"));
 
     if ((other_ecdh = EC_KEY_new()) == NULL)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Couldn't allocate EC_KEY"));
+    
     if (!EC_KEY_set_group(other_ecdh, group))
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Couldn't set group"));
+
     if (!EC_KEY_set_private_key(other_ecdh, priv_key))
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Couldn't set private key"));
 
     if ((degree = EC_GROUP_get_degree(group)) <= 0)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Couldn't get degree"));
 
     field_size = (size_t)degree;
     if ((p = enif_make_new_binary(env, (field_size+7)/8, &ret)) == NULL)
-        goto err;
-    if (ECDH_compute_key(p, (field_size+7)/8, my_ecpoint, other_ecdh, NULL) < 1)
-        goto err;
-
-    goto done;
+        assign_goto(ret, err, EXCP_ERROR(env, "Couldn't allocate binary"));
 
- bad_arg:
-    ret = make_badarg_maybe(env);
-    goto done;
+    if (ECDH_compute_key(p, (field_size+7)/8, my_ecpoint, other_ecdh, NULL) < 1)
+        assign_goto(ret, err, EXCP_ERROR(env, "Couldn't compute key"));
 
  err:
-    ret = enif_make_badarg(env);
-
- done:
     if (group)
         EC_GROUP_free(group);
     if (my_ecpoint)
@@ -87,8 +189,6 @@ ERL_NIF_TERM ecdh_compute_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM a
         EC_KEY_free(key);
 
     return ret;
-
-#else
-    return atom_notsup;
-#endif
 }
+# endif /* ! HAS_3_0_API */
+#endif /* HAVE_EC */
diff --git a/lib/crypto/c_src/evp.c b/lib/crypto/c_src/evp.c
index 7491db3d57..3a3f384a60 100644
--- a/lib/crypto/c_src/evp.c
+++ b/lib/crypto/c_src/evp.c
@@ -1,7 +1,7 @@
 /*
  * %CopyrightBegin%
  *
- * Copyright Ericsson AB 2010-2020. All Rights Reserved.
+ * Copyright Ericsson AB 2010-2022. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -34,43 +34,53 @@ ERL_NIF_TERM evp_compute_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM ar
 
     ASSERT(argc == 3);
 
+    /* Arg 0, Curve */
     if (argv[0] == atom_x25519)
         type = EVP_PKEY_X25519;
     else if (argv[0] == atom_x448)
         type = EVP_PKEY_X448;
     else
-        goto bad_arg;
+        assign_goto(ret, bad_arg, EXCP_BADARG_N(env, 0, "Bad curve"));
 
-    if (!enif_inspect_binary(env, argv[1], &peer_bin))
-        goto bad_arg;
+    /* Arg 2, MyBin (My private key) */
     if (!enif_inspect_binary(env, argv[2], &my_bin))
-        goto bad_arg;
+        assign_goto(ret, bad_arg, EXCP_BADARG_N(env, 2, "Binary expected"));
 
     if ((my_key = EVP_PKEY_new_raw_private_key(type, NULL, my_bin.data, my_bin.size)) == NULL)
-        goto err;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 2, "Not a valid raw private key"));
+
     if ((ctx = EVP_PKEY_CTX_new(my_key, NULL)) == NULL)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR_N(env, 2, "Can't make context"));
 
     if (EVP_PKEY_derive_init(ctx) != 1)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_derive_init"));
+
+    /* Arg 1, PeerBin (Peer public key) */
+    if (!enif_inspect_binary(env, argv[1], &peer_bin))
+        assign_goto(ret, bad_arg, EXCP_BADARG_N(env, 1, "Binary expected"));
 
     if ((peer_key = EVP_PKEY_new_raw_public_key(type, NULL, peer_bin.data, peer_bin.size)) == NULL)
-        goto err;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 1, "Not a raw public peer key"));
+
     if (EVP_PKEY_derive_set_peer(ctx, peer_key) != 1)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR_N(env, 1, "Can't EVP_PKEY_derive_set_peer"));
 
+    /* Find max size of the common key */
     if (EVP_PKEY_derive(ctx, NULL, &max_size) != 1)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR_N(env, 1, "Can't get max size"));
 
     if (!enif_alloc_binary(max_size, &key_bin))
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate"));
+
     key_bin_alloc = 1;
+
+    /* Derive the common key */
     if (EVP_PKEY_derive(ctx, key_bin.data, &key_bin.size) != 1)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_derive"));
 
     if (key_bin.size < max_size) {
         if (!enif_realloc_binary(&key_bin, (size_t)key_bin.size))
-            goto err;
+            assign_goto(ret, err, EXCP_ERROR(env, "Can't shrink binary"));
     }
 
     ret = enif_make_binary(env, &key_bin);
@@ -81,7 +91,6 @@ ERL_NIF_TERM evp_compute_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM ar
  err:
     if (key_bin_alloc)
         enif_release_binary(&key_bin);
-    ret = enif_make_badarg(env);
 
  done:
     if (my_key)
@@ -98,6 +107,7 @@ ERL_NIF_TERM evp_compute_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM ar
 #endif
 }
 
+
 ERL_NIF_TERM evp_generate_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 /* (Curve) */
 {
@@ -119,46 +129,41 @@ ERL_NIF_TERM evp_generate_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM a
     else if (argv[0] == atom_ed448)
         type = EVP_PKEY_ED448;
     else
-        goto bad_arg;
+        assign_goto(ret, bad_arg, EXCP_BADARG_N(env, 0, "Bad curve"));
 
     if (argv[1] == atom_undefined) {
         if ((ctx = EVP_PKEY_CTX_new_id(type, NULL)) == NULL)
-            goto bad_arg;
+            assign_goto(ret, err, EXCP_ERROR(env, "Can't make context"));
         if (EVP_PKEY_keygen_init(ctx) != 1)
-            goto err;
+            assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_keygen_init"));
         if (EVP_PKEY_keygen(ctx, &pkey) != 1)
-            goto err;
+            assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_keygen"));
     } else {
         if (!enif_inspect_binary(env, argv[1], &prv_key))
-            goto bad_arg;
+            assign_goto(ret, err, EXCP_ERROR_N(env, 1, "Can't get max size"));
         if ((pkey = EVP_PKEY_new_raw_private_key(type, NULL, prv_key.data, prv_key.size)) == NULL)
-            goto bad_arg;
+            assign_goto(ret, err, EXCP_ERROR_N(env, 1, "Can't EVP_PKEY_new_raw_private_key"));
     }
 
     if (EVP_PKEY_get_raw_public_key(pkey, NULL, &key_len) != 1)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR_N(env, 1, "Can't get max size"));
     if ((out_pub = enif_make_new_binary(env, key_len, &ret_pub)) == NULL)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate"));
     if (EVP_PKEY_get_raw_public_key(pkey, out_pub, &key_len) != 1)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_get_raw_public_key"));
 
     if (EVP_PKEY_get_raw_private_key(pkey, NULL, &key_len) != 1)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR_N(env, 1, "Can't get max size"));
     if ((out_priv = enif_make_new_binary(env, key_len, &ret_prv)) == NULL)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate"));
     if (EVP_PKEY_get_raw_private_key(pkey, out_priv, &key_len) != 1)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_get_raw_private_key"));
 
     ret = enif_make_tuple2(env, ret_pub, ret_prv);
     goto done;
 
  bad_arg:
-    ret = enif_make_badarg(env);
-    goto done;
-
  err:
-    ret = atom_error;
-
  done:
     if (pkey)
         EVP_PKEY_free(pkey);
diff --git a/lib/crypto/c_src/hash.c b/lib/crypto/c_src/hash.c
index 92f599fc61..ba454f5062 100644
--- a/lib/crypto/c_src/hash.c
+++ b/lib/crypto/c_src/hash.c
@@ -104,39 +104,30 @@ ERL_NIF_TERM hash_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
     unsigned             ret_size;
     unsigned char        *outp;
 
-    ASSERT(argc == 2);
-
     if ((digp = get_digest_type(argv[0])) == NULL)
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 0, "Bad digest type");
     if (DIGEST_FORBIDDEN_IN_FIPS(digp))
-        goto notsup;
+        return EXCP_NOTSUP_N(env, 0, "Bad digest type in FIPS");
+    if ((md = digp->md.p) == NULL)
+        return EXCP_NOTSUP_N(env, 0, "Digest type not supported in this cryptolib");
+
     if (!enif_inspect_iolist_as_binary(env, argv[1], &data))
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 1, "Not iolist");
 
-    if ((md = digp->md.p) == NULL)
-        goto err;
 
     ret_size = (unsigned)EVP_MD_size(md);
     ASSERT(0 < ret_size && ret_size <= EVP_MAX_MD_SIZE);
 
     if ((outp = enif_make_new_binary(env, ret_size, &ret)) == NULL)
-        goto err;
+        return EXCP_ERROR(env, "Can't allocate binary");
+
     if (EVP_Digest(data.data, data.size, outp, &ret_size, md, NULL) != 1)
-        goto err;
+        return EXCP_ERROR(env, "Low-level call failed");
 
     ASSERT(ret_size == (unsigned)EVP_MD_size(md));
 
     CONSUME_REDS(env, data);
     return ret;
-
- bad_arg:
-    return enif_make_badarg(env);
-
- notsup:
-    return atom_notsup;
-
- err:
-    return atom_notsup;
 }
 
 #if OPENSSL_VERSION_NUMBER >= PACKED_OPENSSL_VERSION_PLAIN(1,0,0)
@@ -147,31 +138,22 @@ ERL_NIF_TERM hash_init_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
     struct evp_md_ctx    *ctx = NULL;
     ERL_NIF_TERM         ret;
 
-    ASSERT(argc == 1);
-
     if ((digp = get_digest_type(argv[0])) == NULL)
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 0, "Bad digest type");
+
     if (DIGEST_FORBIDDEN_IN_FIPS(digp))
-        goto notsup;
+        return EXCP_NOTSUP_N(env, 0, "Digest type not supported in FIPS");
     if (digp->md.p == NULL)
-        goto err;
+        return EXCP_NOTSUP_N(env, 0, "Unsupported digest type");
 
     if ((ctx = enif_alloc_resource(evp_md_ctx_rtype, sizeof(struct evp_md_ctx))) == NULL)
-        goto err;
+        return EXCP_ERROR(env, "Can't allocate nif resource");
     if ((ctx->ctx = EVP_MD_CTX_new()) == NULL)
-        goto err;
+        assign_goto(ret, done, EXCP_ERROR(env, "Low-level call EVP_MD_CTX_new failed"));
     if (EVP_DigestInit(ctx->ctx, digp->md.p) != 1)
-        goto err;
+        assign_goto(ret, done, EXCP_ERROR(env, "Low-level call EVP_DigestInit failed"));
 
     ret = enif_make_resource(env, ctx);
-    goto done;
-
- bad_arg:
-    return enif_make_badarg(env);
-
- notsup:
- err:
-    ret = atom_notsup;
 
  done:
     if (ctx)
@@ -185,31 +167,23 @@ ERL_NIF_TERM hash_update_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]
     ErlNifBinary data;
     ERL_NIF_TERM ret;
 
-    ASSERT(argc == 2);
-
     if (!enif_get_resource(env, argv[0], evp_md_ctx_rtype, (void**)&ctx))
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 0, "Bad state");
+
     if (!enif_inspect_iolist_as_binary(env, argv[1], &data))
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 1, "Not iolist");
 
     if ((new_ctx = enif_alloc_resource(evp_md_ctx_rtype, sizeof(struct evp_md_ctx))) == NULL)
-        goto err;
+        return EXCP_ERROR(env, "Can't allocate nif resource");
     if ((new_ctx->ctx = EVP_MD_CTX_new()) == NULL)
-        goto err;
+        assign_goto(ret, done, EXCP_ERROR(env, "Low-level call EVP_MD_CTX_new failed"));
     if (EVP_MD_CTX_copy(new_ctx->ctx, ctx->ctx) != 1)
-        goto err;
+        assign_goto(ret, done, EXCP_ERROR(env, "Low-level call EVP_MD_CTX_copy failed"));
     if (EVP_DigestUpdate(new_ctx->ctx, data.data, data.size) != 1)
-        goto err;
+        assign_goto(ret, done, EXCP_ERROR(env, "Low-level call EVP_DigestUpdate failed"));
 
     ret = enif_make_resource(env, new_ctx);
     CONSUME_REDS(env, data);
-    goto done;
-
- bad_arg:
-    return enif_make_badarg(env);
-
- err:
-    ret = atom_notsup;
 
  done:
     if (new_ctx)
@@ -228,28 +202,21 @@ ERL_NIF_TERM hash_final_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
     ASSERT(argc == 1);
 
     if (!enif_get_resource(env, argv[0], evp_md_ctx_rtype, (void**)&ctx))
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 0, "Bad state");
 
     ret_size = (unsigned)EVP_MD_CTX_size(ctx->ctx);
     ASSERT(0 < ret_size && ret_size <= EVP_MAX_MD_SIZE);
 
     if ((new_ctx = EVP_MD_CTX_new()) == NULL)
-        goto err;
+        assign_goto(ret, done, EXCP_ERROR(env, "Low-level call EVP_MD_CTX_new failed"));
     if (EVP_MD_CTX_copy(new_ctx, ctx->ctx) != 1)
-        goto err;
+        assign_goto(ret, done, EXCP_ERROR(env, "Low-level call EVP_MD_CTX_copy failed"));
     if ((outp = enif_make_new_binary(env, ret_size, &ret)) == NULL)
-        goto err;
+        assign_goto(ret, done, EXCP_ERROR(env, "Can't make a new binary"));
     if (EVP_DigestFinal(new_ctx, outp, &ret_size) != 1)
-        goto err;
+        assign_goto(ret, done, EXCP_ERROR(env, "Low-level call EVP_DigestFinal failed"));
 
     ASSERT(ret_size == (unsigned)EVP_MD_CTX_size(ctx->ctx));
-    goto done;
-
- bad_arg:
-    return enif_make_badarg(env);
-
- err:
-    ret = atom_notsup;
 
  done:
     if (new_ctx)
@@ -271,11 +238,12 @@ ERL_NIF_TERM hash_init_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
     ASSERT(argc == 1);
 
     if ((digp = get_digest_type(argv[0])) == NULL)
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 0, "Bad digest type");
+    
     if (DIGEST_FORBIDDEN_IN_FIPS(digp))
-        goto notsup;
+        return EXCP_NOTSUP_N(env, 0, "Digest type not supported in FIPS");
     if (digp->md.p == NULL)
-        goto err;
+        return EXCP_NOTSUP_N(env, 0, "Unsupported digest type");
 
     switch (EVP_MD_type(digp->md.p))
     {
@@ -326,27 +294,18 @@ ERL_NIF_TERM hash_init_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
         break;
 #endif
     default:
-        goto err;
+        return EXCP_NOTSUP_N(env, 0, "Unsupported digest type");
     }
     ASSERT(ctx_size);
     ASSERT(ctx_init);
 
     if ((outp = enif_make_new_binary(env, ctx_size, &ctx)) == NULL)
-        goto err;
+        return EXCP_ERROR(env, "Can't allocate binary");
 
     if (ctx_init(outp) != 1)
-        goto err;
+        return EXCP_ERROR(env, "Can't init ctx");
 
     return enif_make_tuple2(env, argv[0], ctx);
-
- bad_arg:
-    return enif_make_badarg(env);
-
- notsup:
-    return atom_notsup;
-
- err:
-    return atom_notsup;
 }
 
 ERL_NIF_TERM hash_update_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
@@ -361,23 +320,21 @@ ERL_NIF_TERM hash_update_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]
     size_t               ctx_size   = 0;
     update_fun           ctx_update = 0;
 
-    ASSERT(argc == 2);
-
     if (!enif_get_tuple(env, argv[0], &arity, &tuple))
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 0, "Bad state");
     if (arity != 2)
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 0, "Bad state");
     if ((digp = get_digest_type(tuple[0])) == NULL)
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 0, "Bad state");
     if (DIGEST_FORBIDDEN_IN_FIPS(digp))
-        goto notsup;
+        return EXCP_BADARG_N(env, 0, "Bad state");
+    if (digp->md.p == NULL)
+        return EXCP_BADARG_N(env, 0, "Bad state");
     if (!enif_inspect_binary(env, tuple[1], &ctx))
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 0, "Bad state");
+    
     if (!enif_inspect_iolist_as_binary(env, argv[1], &data))
-        goto bad_arg;
-
-    if (digp->md.p == NULL)
-        goto err;
+        return EXCP_BADARG_N(env, 0, "Bad data");
 
     switch (EVP_MD_type(digp->md.p))
     {
@@ -428,32 +385,24 @@ ERL_NIF_TERM hash_update_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]
         break;
 #endif
     default:
-        goto err;
+        return EXCP_BADARG_N(env, 0, "Bad state");
     }
     ASSERT(ctx_size);
     ASSERT(ctx_update);
 
     if (ctx.size != ctx_size)
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 0, "Bad state");
 
     if ((ctx_buff = enif_make_new_binary(env, ctx_size, &new_ctx)) == NULL)
-        goto err;
+        return EXCP_ERROR(env, "Can't allocate binary");
+
     memcpy(ctx_buff, ctx.data, ctx_size);
 
     if (ctx_update(ctx_buff, data.data, data.size) != 1)
-        goto err;
+        return EXCP_ERROR(env, "Can't update");
 
     CONSUME_REDS(env, data);
     return enif_make_tuple2(env, tuple[0], new_ctx);
-
- bad_arg:
-    return enif_make_badarg(env);
-
- notsup:
-    return atom_notsup;
-
- err:
-    return atom_notsup;
 }
 
 ERL_NIF_TERM hash_final_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
@@ -470,21 +419,19 @@ ERL_NIF_TERM hash_final_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
     final_fun            ctx_final = 0;
     unsigned char        *outp;
 
-    ASSERT(argc == 1);
-
     if (!enif_get_tuple(env, argv[0], &arity, &tuple))
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 0, "Bad state");
     if (arity != 2)
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 0, "Bad state");
     if ((digp = get_digest_type(tuple[0])) == NULL)
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 0, "Bad state");
     if (DIGEST_FORBIDDEN_IN_FIPS(digp))
-        goto notsup;
-    if (!enif_inspect_binary(env, tuple[1], &ctx))
-        goto bad_arg;
-
+        return EXCP_BADARG_N(env, 0, "Bad state");
     if ((md = digp->md.p) == NULL)
-        goto err;
+        return EXCP_BADARG_N(env, 0, "Bad state");
+
+    if (!enif_inspect_binary(env, tuple[1], &ctx))
+        return EXCP_BADARG_N(env, 0, "Bad data");
 
     switch (EVP_MD_type(md))
     {
@@ -535,33 +482,24 @@ ERL_NIF_TERM hash_final_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
         break;
 #endif
     default:
-        goto err;
+        return EXCP_BADARG_N(env, 0, "Bad state");
     }
     ASSERT(ctx_size);
     ASSERT(ctx_final);
 
     if (ctx.size != ctx_size)
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 0, "Bad state");
 
     if ((new_ctx = enif_alloc(ctx_size)) == NULL)
-        goto err;
+        return EXCP_ERROR(env, "Can't allocate");
 
     memcpy(new_ctx, ctx.data, ctx_size);
 
     if ((outp = enif_make_new_binary(env, (size_t)EVP_MD_size(md), &ret)) == NULL)
-        goto err;
+        assign_goto(ret, done, EXCP_ERROR(env, "Can't allocate binary"));
 
     if (ctx_final(outp, new_ctx) != 1)
-        goto err;
-
-    goto done;
-
- bad_arg:
-    return enif_make_badarg(env);
-
- notsup:
- err:
-    ret = atom_notsup;
+        assign_goto(ret, done, EXCP_ERROR(env, "Can't do final"));
 
  done:
     if (new_ctx)
diff --git a/lib/crypto/c_src/hash_equals.c b/lib/crypto/c_src/hash_equals.c
new file mode 100644
index 0000000000..85f54b14eb
--- /dev/null
+++ b/lib/crypto/c_src/hash_equals.c
@@ -0,0 +1,51 @@
+/*
+ * %CopyrightBegin%
+ *
+ * Copyright Ericsson AB 2010-2021. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * %CopyrightEnd%
+
+ */
+
+#include "common.h"
+#include "hash_equals.h"
+
+ERL_NIF_TERM hash_equals_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
+{
+#ifdef HAVE_OPENSSL_CRYPTO_MEMCMP
+    ErlNifBinary s1, s2;
+
+    ASSERT(argc == 2);
+
+    if (!enif_inspect_binary(env, argv[0], &s1))
+        goto bad_arg;
+    if (!enif_inspect_binary(env, argv[1], &s2))
+        goto bad_arg;
+
+    if (s1.size != s2.size)
+        goto err;
+
+    if (CRYPTO_memcmp(s1.data, s2.data, s1.size) == 0)
+        return enif_make_atom(env, "true");
+
+    return enif_make_atom(env, "false");
+
+ bad_arg:
+ err:
+    return enif_make_badarg(env);
+#else
+    return EXCP_NOTSUP(env, "Unsupported CRYPTO_memcmp");
+#endif
+}
diff --git a/lib/crypto/c_src/hash_equals.h b/lib/crypto/c_src/hash_equals.h
new file mode 100644
index 0000000000..966862c828
--- /dev/null
+++ b/lib/crypto/c_src/hash_equals.h
@@ -0,0 +1,28 @@
+/*
+ * %CopyrightBegin%
+ *
+ * Copyright Ericsson AB 2010-2021. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * %CopyrightEnd%
+ */
+
+#ifndef E_HASH_EQUALS_H__
+#define E_HASH_EQUALS_H__ 1
+
+#include "common.h"
+
+ERL_NIF_TERM hash_equals_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);
+
+#endif /* E_HASH_EQUALS_H__ */
diff --git a/lib/crypto/c_src/mac.c b/lib/crypto/c_src/mac.c
index bd76fa209a..4223f0567f 100644
--- a/lib/crypto/c_src/mac.c
+++ b/lib/crypto/c_src/mac.c
@@ -1,7 +1,7 @@
 /*
  * %CopyrightBegin%
  *
- * Copyright Ericsson AB 2010-2021. All Rights Reserved.
+ * Copyright Ericsson AB 2010-2022. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -196,12 +196,20 @@ ERL_NIF_TERM mac_one_time(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
     ErlNifBinary key_bin, text;
     int ret_bin_alloc = 0;
     ERL_NIF_TERM return_term;
-    const EVP_MD *md = NULL;
     ErlNifBinary ret_bin;
-#ifdef HAS_EVP_PKEY_CTX
+#if defined(HAS_3_0_API)
+    const char *name;
+    const char *subalg;
+    unsigned char *out = NULL;
+    size_t outlen;
+#else
+    /* Old style */
+    const EVP_MD *md = NULL;
+# ifdef HAS_EVP_PKEY_CTX
     size_t size;
     EVP_PKEY *pkey = NULL;
     EVP_MD_CTX *mctx = NULL;
+# endif
 #endif
 
     /*---------------------------------
@@ -255,32 +263,38 @@ ERL_NIF_TERM mac_one_time(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
                     return_term = EXCP_BADARG_N(env, 1, "Bad digest algorithm for HMAC");
                     goto err;
                 }
-            if (digp->md.p == NULL)
+            if (DIGEST_FORBIDDEN_IN_FIPS(digp))
                 {
-                    return_term = EXCP_NOTSUP_N(env, 1, "Unsupported digest algorithm");
+                    return_term = EXCP_NOTSUP_N(env, 1, "Digest algorithm for HMAC forbidden in FIPS");
                     goto err;
                 }
-            if (DIGEST_FORBIDDEN_IN_FIPS(digp))
+
+#if defined(HAS_3_0_API)
+            name = "HMAC";
+            subalg = digp->str_v3;
+#else
+            /* Old style */
+            if (digp->md.p == NULL)
                 {
-                    return_term = EXCP_NOTSUP_N(env, 1, "Digest algorithm for HMAC forbidden in FIPS");
+                    return_term = EXCP_NOTSUP_N(env, 1, "Unsupported digest algorithm");
                     goto err;
                 }
             md = digp->md.p;
-
-#if defined(HAS_EVP_PKEY_CTX) && (! DISABLE_EVP_HMAC)
-# ifdef HAVE_PKEY_new_raw_private_key
+# if defined(HAS_EVP_PKEY_CTX) && (! DISABLE_EVP_HMAC)
+#  ifdef HAVE_PKEY_new_raw_private_key
             /* Preferred for new applications according to EVP_PKEY_new_mac_key(3) */
             pkey = EVP_PKEY_new_raw_private_key(EVP_PKEY_HMAC, /*engine*/ NULL, key_bin.data,  key_bin.size);
-# else
+#  else
             /* Available in older versions */
             pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, /*engine*/ NULL, key_bin.data,  key_bin.size);
-# endif
+#  endif
 
-#else
+# else
             if (!hmac_low_level(env, md, key_bin, text, &ret_bin, &ret_bin_alloc, &return_term))
                 goto err;
             else
                 goto success;
+# endif
 #endif
         }
         break;
@@ -315,13 +329,19 @@ ERL_NIF_TERM mac_one_time(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
                     goto err;
                 }
 
-# ifdef HAVE_EVP_PKEY_new_CMAC_key
-            pkey = EVP_PKEY_new_CMAC_key(/*engine*/ NULL, key_bin.data,  key_bin.size, cipherp->cipher.p);
+# if defined(HAS_3_0_API)
+            name = "CMAC";
+            subalg = cipherp->str_v3;
 # else
+            /* Old style */
+#  ifdef HAVE_EVP_PKEY_new_CMAC_key
+            pkey = EVP_PKEY_new_CMAC_key(/*engine*/ NULL, key_bin.data,  key_bin.size, cipherp->cipher.p);
+#  else
             if (!cmac_low_level(env, key_bin, cipherp->cipher.p, text, &ret_bin, &ret_bin_alloc, &return_term))
                 goto err;
             else
                 goto success;
+#  endif
 # endif
         }
         break;
@@ -333,26 +353,49 @@ ERL_NIF_TERM mac_one_time(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
          ************/
 #ifdef HAVE_POLY1305
     case POLY1305_mac:
+# if defined(HAS_3_0_API)
+        name = "POLY1305";
+        subalg = NULL;
+# else
+        /* Old style */
         /* poly1305 implies that EVP_PKEY_new_raw_private_key exists */
         pkey = EVP_PKEY_new_raw_private_key(EVP_PKEY_POLY1305, /*engine*/ NULL, key_bin.data,  key_bin.size);
+# endif
         break;
 #endif
 
-
         /***************
          * Unknown MAC *
          ***************/
     case NO_mac:
     default:
-        /* We know that this mac is supported with some version(s) of cryptolib */
+        /* We know that this mac is supported with some version(s) of cryptolib, but not here */
         return_term = EXCP_NOTSUP_N(env, 1, "Unsupported mac algorithm");
         goto err;
     }
 
+#if defined(HAS_3_0_API)
+    /*-----------------------------------------
+      Common computations when we have 3.0 API
+    */
+
+    if (!(out = EVP_Q_mac(NULL, name, NULL,
+                          subalg, NULL,
+                          key_bin.data, key_bin.size,
+                          text.data, text.size,
+                          NULL, 0, &outlen)))
+        assign_goto(return_term, err, EXCP_ERROR(env, "Couldn't get mac"));
+
+    if (!enif_alloc_binary(outlen, &ret_bin))
+        assign_goto(return_term, err, EXCP_ERROR(env, "Alloc binary"));
+    ret_bin_alloc = 1;
+
+    memcpy(ret_bin.data, out, outlen);
+#else
     /*-----------------------------------------
       Common computations when we have EVP_PKEY
     */
-#ifdef HAS_EVP_PKEY_CTX
+# ifdef HAS_EVP_PKEY_CTX
     if (!pkey)
         {
             return_term = EXCP_ERROR(env, "EVP_PKEY_key creation");
@@ -371,13 +414,13 @@ ERL_NIF_TERM mac_one_time(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
             goto err;
         }
 
-# ifdef HAVE_DigestSign_as_single_op
+#  ifdef HAVE_DigestSign_as_single_op
     if (EVP_DigestSign(mctx, NULL, &size, text.data, text.size) != 1)
         {
             return_term = EXCP_ERROR(env, "Can't get sign size");
             goto err;
         }
-# else
+#  else
     if (EVP_DigestSignUpdate(mctx, text.data, text.size) != 1)
         {
             return_term = EXCP_ERROR(env, "EVP_DigestSignUpdate");
@@ -389,7 +432,7 @@ ERL_NIF_TERM mac_one_time(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
             return_term = EXCP_ERROR(env, "Can't get sign size");
             goto err;
         }
-# endif
+#  endif
    
     if (!enif_alloc_binary(size, &ret_bin))
         {
@@ -398,11 +441,11 @@ ERL_NIF_TERM mac_one_time(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
         }
     ret_bin_alloc = 1;
 
-# ifdef HAVE_DigestSign_as_single_op
+#  ifdef HAVE_DigestSign_as_single_op
     if (EVP_DigestSign(mctx, ret_bin.data, &size, text.data, text.size) != 1)
-# else    
+#  else    
     if (EVP_DigestSignFinal(mctx, ret_bin.data, &size) != 1)
-# endif
+#  endif
         {
             return_term = EXCP_ERROR(env, "Signing");
             goto err;
@@ -411,25 +454,30 @@ ERL_NIF_TERM mac_one_time(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
     goto success; /* The label "success:" could be left without any "goto success"
                      in some combination of flags. This prevents a compiler warning
                   */
-#endif /* ifdef HAS_EVP_PKEY_CTX */
-
+# endif /* ifdef HAS_EVP_PKEY_CTX */
+ success:
+#endif
 
     /****************************
      Exit when we got a signature
     *****************************/
- success:
     CONSUME_REDS(env, text);
 
     return_term = enif_make_binary(env, &ret_bin);
     ret_bin_alloc = 0;
 
  err:
-
-#ifdef HAS_EVP_PKEY_CTX
+#if defined(HAS_3_0_API)
+    if (out)
+        OPENSSL_free(out);
+#else
+            /* Old style */
+# ifdef HAS_EVP_PKEY_CTX
     if (pkey)
         EVP_PKEY_free(pkey);
     if (mctx)
         EVP_MD_CTX_free(mctx);
+# endif
 #endif
 
     if (ret_bin_alloc)
@@ -449,7 +497,11 @@ int init_mac_ctx(ErlNifEnv *env);
 
 struct mac_context
 {
+#if defined(HAS_3_0_API)
+    EVP_MAC_CTX *ctx;
+#else
     EVP_MD_CTX *ctx;
+#endif
 };
 
 static ErlNifResourceType* mac_context_rtype;
@@ -478,7 +530,11 @@ static void mac_context_dtor(ErlNifEnv* env, struct mac_context *obj)
         return;
 
     if (obj->ctx)
+#if defined(HAS_3_0_API)
+        EVP_MAC_CTX_free(obj->ctx);
+#else
         EVP_MD_CTX_free(obj->ctx);
+#endif
 }
 
 /*******************************************************************
@@ -489,13 +545,32 @@ static void mac_context_dtor(ErlNifEnv* env, struct mac_context *obj)
 
 ERL_NIF_TERM mac_init_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 {/* (MacType, SubType, Key) */
-#ifdef HAS_EVP_PKEY_CTX
+
+#if ! defined(HAS_EVP_PKEY_CTX) && ! defined(HAS_3_0_API)
+    /* Only realy low-level available */
+    if (argv[0] != atom_hmac)
+        return EXCP_NOTSUP_N(env, 0, "Unsupported mac algorithm");
+
+    return hmac_init_nif(env, argc, argv);
+
+#else
+    /* EVP_PKEY_CTX is available or even the 3.0 API */
     struct mac_context  *obj = NULL;
     struct mac_type_t *macp;
     ErlNifBinary key_bin;
     ERL_NIF_TERM return_term;
+# if defined(HAS_3_0_API)
+    const char *name = NULL;
+    const char *digest = NULL;
+    const char *cipher = NULL;
+    EVP_MAC *mac = NULL;
+    OSSL_PARAM params[3];
+    size_t params_n = 0;
+# else
+    /* EVP_PKEY_CTX is available */
     const EVP_MD *md = NULL;
     EVP_PKEY *pkey = NULL;
+# endif
 
     /*---------------------------------
       Get common indata and validate it
@@ -542,25 +617,30 @@ ERL_NIF_TERM mac_init_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
                     return_term = EXCP_BADARG_N(env, 1, "Bad digest algorithm for HMAC");
                     goto err;
                 }
-            if (digp->md.p == NULL)
+            if (DIGEST_FORBIDDEN_IN_FIPS(digp))
                 {
-                    return_term = EXCP_NOTSUP_N(env, 1, "Unsupported digest algorithm");
+                    return_term = EXCP_NOTSUP_N(env, 1, "Digest algorithm for HMAC forbidden in FIPS");
                     goto err;
                 }
-            if (DIGEST_FORBIDDEN_IN_FIPS(digp))
+# if defined(HAS_3_0_API)
+            name = "HMAC";
+            digest = digp->str_v3;
+# else
+            if (digp->md.p == NULL)
                 {
-                    return_term = EXCP_NOTSUP_N(env, 1, "Digest algorithm for HMAC forbidden in FIPS");
+                    return_term = EXCP_NOTSUP_N(env, 1, "Unsupported digest algorithm");
                     goto err;
                 }
             md = digp->md.p;
 
-# ifdef HAVE_PKEY_new_raw_private_key
+#  ifdef HAVE_PKEY_new_raw_private_key
             /* Preferred for new applications according to EVP_PKEY_new_mac_key(3) */
             pkey = EVP_PKEY_new_raw_private_key(EVP_PKEY_HMAC, /*engine*/ NULL, key_bin.data,  key_bin.size);
-# else
+#  else
             /* Available in older versions */
             pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, /*engine*/ NULL, key_bin.data,  key_bin.size);
-# endif
+#  endif
+#endif
         }
         break;
 
@@ -568,7 +648,7 @@ ERL_NIF_TERM mac_init_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
         /********
          * CMAC *
          ********/
-#if defined(HAVE_CMAC) && defined(HAVE_EVP_PKEY_new_CMAC_key)
+# if defined(HAVE_CMAC) && defined(HAVE_EVP_PKEY_new_CMAC_key)
     case CMAC_mac:
         {
             const struct cipher_type_t *cipherp;
@@ -594,21 +674,32 @@ ERL_NIF_TERM mac_init_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
                     goto err;
                 }
 
+#  if defined(HAS_3_0_API)
+            name = "CMAC";
+            cipher = cipherp->str_v3;
+#  else
+            /* Old style */
             pkey = EVP_PKEY_new_CMAC_key(/*engine*/ NULL, key_bin.data,  key_bin.size, cipherp->cipher.p);
+#  endif
         }
         break;
-#endif /* HAVE_CMAC && HAVE_EVP_PKEY_new_CMAC_key */
+# endif /* HAVE_CMAC && HAVE_EVP_PKEY_new_CMAC_key */
 
 
         /************
          * POLY1305 *
          ************/
-#ifdef HAVE_POLY1305
+# ifdef HAVE_POLY1305
     case POLY1305_mac:
+#  if defined(HAS_3_0_API)
+        name = "POLY1305";
+#  else
+        /* Old style */
         /* poly1305 implies that EVP_PKEY_new_raw_private_key exists */
         pkey = EVP_PKEY_new_raw_private_key(EVP_PKEY_POLY1305, /*engine*/ NULL, key_bin.data,  key_bin.size);
+#  endif
         break;
-#endif
+# endif
 
 
         /***************
@@ -621,8 +712,34 @@ ERL_NIF_TERM mac_init_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
         goto err;
     }
 
+# if defined(HAS_3_0_API)
     /*-----------------------------------------
-      Common computations
+      Common computations when we have 3.0 API
+    */
+    if (!(mac = EVP_MAC_fetch(NULL, name, NULL)))
+        assign_goto(return_term, err, EXCP_NOTSUP_N(env, 0, "Unsupported mac algorithm"));
+
+    if (cipher != NULL)
+        params[params_n++] =
+            OSSL_PARAM_construct_utf8_string("cipher", (char*)cipher, 0);
+    if (digest != NULL)
+        params[params_n++] =
+            OSSL_PARAM_construct_utf8_string("digest", (char*)digest, 0);
+    params[params_n] = OSSL_PARAM_construct_end();
+
+    if ((obj = enif_alloc_resource(mac_context_rtype, sizeof(struct mac_context))) == NULL)
+        assign_goto(return_term, err, EXCP_ERROR(env, "Can't allocate mac_context_rtype"));
+
+    if (!(obj->ctx = EVP_MAC_CTX_new(mac)))
+        assign_goto(return_term, err, EXCP_ERROR(env, "Can't create EVP_MAC_CTX"));
+    
+    if (!EVP_MAC_init(obj->ctx, key_bin.data, key_bin.size, params))
+        assign_goto(return_term, err, EXCP_ERROR(env, "Can't initialize EVP_MAC_CTX"));
+
+    
+# else
+    /*-----------------------------------------
+      Common computations when we have EVP_PKEY_CTX but not 3.0 API
     */
     if (!pkey)
         {
@@ -648,6 +765,8 @@ ERL_NIF_TERM mac_init_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
             goto err;
         }
 
+# endif
+
     return_term = enif_make_resource(env, obj);
 
  err:
@@ -655,16 +774,13 @@ ERL_NIF_TERM mac_init_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
     if (obj)
         enif_release_resource(obj);
 
+# if ! defined(HAS_3_0_API)
     if (pkey)
         EVP_PKEY_free(pkey);
+# endif
 
     return return_term;
 
-#else
-    if (argv[0] != atom_hmac)
-        return EXCP_NOTSUP_N(env, 0, "Unsupported mac algorithm");
-
-    return hmac_init_nif(env, argc, argv);
 #endif
 }
 
@@ -693,7 +809,7 @@ ERL_NIF_TERM mac_update_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 
 ERL_NIF_TERM mac_update(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 {/* (Ref, Text) */
-#ifdef HAS_EVP_PKEY_CTX
+#if defined(HAS_EVP_PKEY_CTX) || defined(HAS_3_0_API)
     struct mac_context *obj = NULL;
     ErlNifBinary text;
 
@@ -703,8 +819,12 @@ ERL_NIF_TERM mac_update(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
     if (!enif_inspect_iolist_as_binary(env, argv[1], &text))
         return EXCP_BADARG_N(env, 1, "Bad text");
 
+# if defined(HAS_3_0_API)
+    if (!EVP_MAC_update(obj->ctx, text.data, text.size))
+# else
     if (EVP_DigestSignUpdate(obj->ctx, text.data, text.size) != 1)
-        return EXCP_ERROR(env, "EVP_DigestSignUpdate");
+# endif
+        return EXCP_ERROR(env, "mac update");
 
     CONSUME_REDS(env, text);
     return argv[0];
@@ -718,7 +838,7 @@ ERL_NIF_TERM mac_update(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 
 ERL_NIF_TERM mac_final_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 {/* (Ref) */
-#ifdef HAS_EVP_PKEY_CTX
+#if defined(HAS_EVP_PKEY_CTX) || defined(HAS_3_0_API)
     struct mac_context *obj;
     size_t size;
     ErlNifBinary ret_bin;
@@ -726,13 +846,21 @@ ERL_NIF_TERM mac_final_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
     if (!enif_get_resource(env, argv[0], (ErlNifResourceType*)mac_context_rtype, (void**)&obj))
         return EXCP_BADARG_N(env, 0, "Bad ref");
 
+# if defined(HAS_3_0_API)
+    if (!EVP_MAC_final(obj->ctx, NULL, &size, 0))
+# else
     if (EVP_DigestSignFinal(obj->ctx, NULL, &size) != 1)
+# endif
         return EXCP_ERROR(env, "Can't get sign size");
    
     if (!enif_alloc_binary(size, &ret_bin))
         return EXCP_ERROR(env, "Alloc binary");
 
+# if defined(HAS_3_0_API)
+    if (!EVP_MAC_final(obj->ctx, ret_bin.data, &size, size))
+# else
     if (EVP_DigestSignFinal(obj->ctx, ret_bin.data, &size) != 1)
+#endif
         {
             enif_release_binary(&ret_bin);
             return EXCP_ERROR(env, "Signing");
diff --git a/lib/crypto/c_src/pbkdf2_hmac.c b/lib/crypto/c_src/pbkdf2_hmac.c
index 7eec603d9c..08360ed558 100644
--- a/lib/crypto/c_src/pbkdf2_hmac.c
+++ b/lib/crypto/c_src/pbkdf2_hmac.c
@@ -1,7 +1,7 @@
 /*
  * %CopyrightBegin%
  *
- * Copyright Ericsson AB 2010-2021. All Rights Reserved.
+ * Copyright Ericsson AB 2010-2022. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -30,45 +30,41 @@ ERL_NIF_TERM pbkdf2_hmac_nif(ErlNifEnv* env, int argc,
     ErlNifUInt64 iter, keylen;
     struct digest_type_t* digp = NULL;
 
-    ASSERT(argc == 5);
-
     if ((digp = get_digest_type(argv[0])) == NULL)
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 0, "Bad digest type");
     if (digp->md.p == NULL)
-        goto bad_arg;
-    if ((digp->flags & PBKDF2_ELIGIBLE_DIGEST) == 0) {
-        goto bad_arg;
-    }
+        return EXCP_BADARG_N(env, 0, "md.p is not NULL");
+    if ((digp->flags & PBKDF2_ELIGIBLE_DIGEST) == 0)
+        return EXCP_BADARG_N(env, 0, "Not eligible digest type");
 
     if (!enif_inspect_binary(env, argv[1], &pass))
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 1, "Not binary");
+
     if (!enif_inspect_binary(env, argv[2], &salt))
-        goto bad_arg;
-    if (!enif_get_uint64(env, argv[3], &iter))
-        goto bad_arg;
-    if (!enif_get_uint64(env, argv[4], &keylen))
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 2, "Not binary");
 
+    if (!enif_get_uint64(env, argv[3], &iter))
+        return EXCP_BADARG_N(env, 3, "Not integer");
     if (iter < 1)
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 3, "Must be > 0");
+
+    if (!enif_get_uint64(env, argv[4], &keylen))
+        return EXCP_BADARG_N(env, 4, "Not integer");
     if (keylen < 1)
-        goto bad_arg;
+        return EXCP_BADARG_N(env, 4, "Must be > 0");
 
     if (!enif_alloc_binary(keylen, &out))
-        goto err;
+        return EXCP_ERROR(env, "Can't allocate binary");
 
     if (!PKCS5_PBKDF2_HMAC((const char *)pass.data, pass.size,
                            salt.data, salt.size, iter,
                            digp->md.p,
                            keylen, out.data)) {
         enif_release_binary(&out);
-        goto err;
+        return EXCP_ERROR(env, "Low-level call failed");
     }
 
     return enif_make_binary(env, &out);
- bad_arg:
- err:
-    return enif_make_badarg(env);
 #else
     return EXCP_NOTSUP(env, "Unsupported CRYPTO_PKCS5_PBKDF2_HMAC");
 #endif
diff --git a/lib/crypto/c_src/pkey.c b/lib/crypto/c_src/pkey.c
index 70c6d1bbe4..bfdcfe3553 100644
--- a/lib/crypto/c_src/pkey.c
+++ b/lib/crypto/c_src/pkey.c
@@ -27,10 +27,6 @@
 #include "engine.h"
 #include "rsa.h"
 
-#define PKEY_BADARG -1
-#define PKEY_NOTSUP 0
-#define PKEY_OK 1
-
 typedef struct PKeyCryptOptions {
     const EVP_MD *rsa_mgf1_md;
     ErlNifBinary rsa_oaep_label;
@@ -46,55 +42,122 @@ typedef struct PKeySignOptions {
 } PKeySignOptions;
 
 
-static int get_pkey_digest_type(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NIF_TERM type,
-				const EVP_MD **md);
-static int get_pkey_sign_digest(ErlNifEnv *env, ERL_NIF_TERM algorithm,
-				ERL_NIF_TERM type, ERL_NIF_TERM data,
+static int check_pkey_algorithm_type(ErlNifEnv *env,
+                                     int alg_arg_num, ERL_NIF_TERM algorithm,
+                                     ERL_NIF_TERM *err_return);
+static int get_pkey_digest_type(ErlNifEnv *env, ERL_NIF_TERM algorithm,
+                                int type_arg_num, ERL_NIF_TERM type,
+				const EVP_MD **md,
+                                ERL_NIF_TERM *err_return);
+static int get_pkey_sign_digest(ErlNifEnv *env,
+                                const ERL_NIF_TERM argv[],
+                                int algorithm_arg_num, int type_arg_num, int data_arg_num,
 				unsigned char *md_value, const EVP_MD **mdp,
-				unsigned char **tbsp, size_t *tbslenp);
-static int get_pkey_sign_options(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NIF_TERM options,
-                                 const EVP_MD *md, PKeySignOptions *opt);
-static int get_pkey_private_key(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NIF_TERM key, EVP_PKEY **pkey);
-static int get_pkey_public_key(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NIF_TERM key,
-			       EVP_PKEY **pkey);
-static int get_pkey_crypt_options(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NIF_TERM options,
-				  PKeyCryptOptions *opt);
+				unsigned char **tbsp, size_t *tbslenp,
+                                ERL_NIF_TERM *err_return);
+static int get_pkey_sign_options(ErlNifEnv *env,
+                                 const ERL_NIF_TERM argv[],
+                                 int algorithm_arg_num, int options_arg_num,
+                                 const EVP_MD *md, PKeySignOptions *opt,
+                                 ERL_NIF_TERM *err_return);
+static int get_pkey_private_key(ErlNifEnv *env,
+                               const ERL_NIF_TERM argv[],
+                               int algorithm_arg_num, int key_arg_num,
+			       EVP_PKEY **pkey,
+                               ERL_NIF_TERM *err_return);
+static int get_pkey_public_key(ErlNifEnv *env,
+                               const ERL_NIF_TERM argv[],
+                               int algorithm_arg_num, int key_arg_num,
+			       EVP_PKEY **pkey,
+                               ERL_NIF_TERM *err_return);
+static int get_pkey_crypt_options(ErlNifEnv *env,
+                                  const ERL_NIF_TERM argv[],
+                                  int algorithm_arg_num, int options_arg_num,
+				  PKeyCryptOptions *opt,
+                                  ERL_NIF_TERM *err_return);
 #ifdef HAVE_RSA_SSLV23_PADDING
 static size_t size_of_RSA(EVP_PKEY *pkey);
 #endif
 
-static int get_pkey_digest_type(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NIF_TERM type,
-				const EVP_MD **md)
+static int check_pkey_algorithm_type(ErlNifEnv *env,
+                                     int alg_arg_num, ERL_NIF_TERM algorithm,
+                                     ERL_NIF_TERM *err_return)
+{
+    if (
+#ifndef HAVE_EDDSA
+        (algorithm == atom_eddsa) ||
+#endif
+
+#ifndef HAVE_DSA
+        (algorithm == atom_dss) ||
+#endif
+
+#ifndef HAVE_EC
+        (algorithm == atom_ecdsa) ||
+#endif
+        0)
+        assign_goto(*err_return, err,  EXCP_NOTSUP_N(env, alg_arg_num, "Unsupported algorithm"));
+        
+
+#ifdef HAVE_EDDSA
+    if (FIPS_MODE())
+        assign_goto(*err_return, err, EXCP_NOTSUP_N(env, alg_arg_num, "Unsupported algorithm in FIPS mode"));
+#endif    
+
+    if ((algorithm != atom_rsa) &&
+        (algorithm != atom_dss) &&
+        (algorithm != atom_ecdsa) &&
+        (algorithm != atom_eddsa)
+        )
+        assign_goto(*err_return, err, EXCP_BADARG_N(env, alg_arg_num, "Bad algorithm"));
+
+    return 1;
+
+ err:
+    return 0;
+}
+
+
+static int get_pkey_digest_type(ErlNifEnv *env, ERL_NIF_TERM algorithm,
+                                int type_arg_num, ERL_NIF_TERM type,
+				const EVP_MD **md,
+                                ERL_NIF_TERM *err_return)
 {
     struct digest_type_t *digp = NULL;
     *md = NULL;
 
     if (type == atom_none && algorithm == atom_rsa)
-        return PKEY_OK;
-    if (algorithm == atom_eddsa) {
-#ifdef HAVE_EDDSA
-        if (!FIPS_MODE()) return PKEY_OK;
-#else
-        return PKEY_NOTSUP;
-#endif
-    }
+        return 1;
+
+    if (algorithm == atom_eddsa) /* Type was skipped for eddsa in < OTP-25
+                                    For eddsa the RFC 8032 mandates sha512 in
+                                    the algorithm */
+        return 1;
+    
     if ((digp = get_digest_type(type)) == NULL)
-        return PKEY_BADARG;
+        assign_goto(*err_return, notsup, EXCP_BADARG_N(env, type_arg_num, "Bad digest type"));
+
     if (DIGEST_FORBIDDEN_IN_FIPS(digp))
-        return PKEY_NOTSUP;
+        assign_goto(*err_return, notsup, EXCP_BADARG_N(env, type_arg_num, "Digest type forbidden in FIPS"));
+
     if (digp->md.p == NULL)
-        return PKEY_NOTSUP;
+        assign_goto(*err_return, notsup, EXCP_BADARG_N(env, type_arg_num, "Digest type not supported"));
 
     *md = digp->md.p;
-    return PKEY_OK;
+    return 1;
+
+ notsup:
+    return 0;
 }
 
-static int get_pkey_sign_digest(ErlNifEnv *env, ERL_NIF_TERM algorithm,
-				ERL_NIF_TERM type, ERL_NIF_TERM data,
+static int get_pkey_sign_digest(ErlNifEnv *env,
+                                const ERL_NIF_TERM argv[],
+                                int algorithm_arg_num, int type_arg_num, int data_arg_num,
 				unsigned char *md_value, const EVP_MD **mdp,
-				unsigned char **tbsp, size_t *tbslenp)
+				unsigned char **tbsp, size_t *tbslenp,
+                                ERL_NIF_TERM *err_return)
 {
-    int i, ret;
+    int ret;
     const ERL_NIF_TERM *tpl_terms;
     int tpl_arity;
     ErlNifBinary tbs_bin;
@@ -108,50 +171,55 @@ static int get_pkey_sign_digest(ErlNifEnv *env, ERL_NIF_TERM algorithm,
     tbs = *tbsp;
     tbslen = *tbslenp;
 
-    if ((i = get_pkey_digest_type(env, algorithm, type, &md)) != PKEY_OK)
-        return i;
+    if (!check_pkey_algorithm_type(env, algorithm_arg_num, argv[algorithm_arg_num], err_return))
+        goto err; /* An exception is present in ret */
+    
+    if (!get_pkey_digest_type(env, argv[algorithm_arg_num],
+                              type_arg_num, argv[type_arg_num],
+                              &md, err_return))
+        goto err; /* An exception is present in ret */
 
-    if (enif_get_tuple(env, data, &tpl_arity, &tpl_terms)) {
+    if (enif_get_tuple(env, argv[data_arg_num], &tpl_arity, &tpl_terms)) {
         if (tpl_arity != 2)
-            goto bad_arg;
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, data_arg_num, "Bad list"));
         if (tpl_terms[0] != atom_digest)
-            goto bad_arg;
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, data_arg_num, "Expected 'digest' as head"));
         if (!enif_inspect_iolist_as_binary(env, tpl_terms[1], &tbs_bin))
-            goto bad_arg;
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, data_arg_num, "Bad 2nd element in list"));
         if (tbs_bin.size > INT_MAX)
-            goto bad_arg;
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, data_arg_num, "Too large binary"));
         if (md != NULL) {
             if ((int)tbs_bin.size != EVP_MD_size(md))
-                goto bad_arg;
+                assign_goto(*err_return, err, EXCP_BADARG_N(env, data_arg_num, "Bad binary size for the algorithm"));
         }
 
         /* We have a digest (= hashed text) in tbs_bin */
 	tbs = tbs_bin.data;
 	tbslen = tbs_bin.size;
     } else if (md == NULL) {
-        if (!enif_inspect_iolist_as_binary(env, data, &tbs_bin))
-            goto bad_arg;
+        if (!enif_inspect_iolist_as_binary(env, argv[data_arg_num], &tbs_bin))
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, data_arg_num, "Expected a binary or a list"));
 
         /* md == NULL, that is no hashing because DigestType argument was atom_none */
 	tbs = tbs_bin.data;
 	tbslen = tbs_bin.size;
     } else {
-        if (!enif_inspect_iolist_as_binary(env, data, &tbs_bin))
-            goto bad_arg;
+        if (!enif_inspect_iolist_as_binary(env, argv[data_arg_num], &tbs_bin))
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, data_arg_num, "Expected a binary or a list"));
 
         /* We have the cleartext in tbs_bin and the hash algo info in md */
 	tbs = md_value;
 
         if ((mdctx = EVP_MD_CTX_create()) == NULL)
-            goto err;
+            assign_goto(*err_return, err, EXCP_ERROR(env, "Can't create MD_CTX"));
 
         /* Looks well, now hash the plain text into a digest according to md */
         if (EVP_DigestInit_ex(mdctx, md, NULL) != 1)
-            goto err;
+            assign_goto(*err_return, err, EXCP_ERROR(env, "Can't create EVP_DigestInit_ex"));
         if (EVP_DigestUpdate(mdctx, tbs_bin.data, tbs_bin.size) != 1)
-            goto err;
+            assign_goto(*err_return, err, EXCP_ERROR(env, "Can't create EVP_DigestUpdate"));
         if (EVP_DigestFinal_ex(mdctx, tbs, &tbsleni) != 1)
-            goto err;
+            assign_goto(*err_return, err, EXCP_ERROR(env, "Can't create EVP_DigestFinal_ex"));
 
         tbslen = (size_t)tbsleni;
     }
@@ -160,32 +228,33 @@ static int get_pkey_sign_digest(ErlNifEnv *env, ERL_NIF_TERM algorithm,
     *tbsp = tbs;
     *tbslenp = tbslen;
 
-    ret = PKEY_OK;
+    ret = 1;
     goto done;
 
- bad_arg:
  err:
-    ret = PKEY_BADARG;
-
+    ret = 0;
  done:
     if (mdctx)
         EVP_MD_CTX_destroy(mdctx);
     return ret;
 }
 
-static int get_pkey_sign_options(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NIF_TERM options,
-                                 const EVP_MD *md, PKeySignOptions *opt)
+static int get_pkey_sign_options(ErlNifEnv *env,
+                                 const ERL_NIF_TERM argv[],
+                                 int algorithm_arg_num, int options_arg_num,
+                                 const EVP_MD *md, PKeySignOptions *opt,
+                                 ERL_NIF_TERM *err_return)
 {
     ERL_NIF_TERM head, tail;
     const ERL_NIF_TERM *tpl_terms;
     int tpl_arity;
     const EVP_MD *opt_md;
 
-    if (!enif_is_list(env, options))
-        goto bad_arg;
+    if (!enif_is_list(env, argv[options_arg_num]))
+        assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Expected a list"));
 
     /* defaults */
-    if (algorithm == atom_rsa) {
+    if (argv[algorithm_arg_num] == atom_rsa) {
 	opt->rsa_mgf1_md = NULL;
 	opt->rsa_padding = RSA_PKCS1_PADDING;
 	opt->rsa_pss_saltlen = -2;
@@ -195,26 +264,27 @@ static int get_pkey_sign_options(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NIF
 	opt->rsa_pss_saltlen = 0;
     }
 
-    if (enif_is_empty_list(env, options))
-	return PKEY_OK;
+    if (enif_is_empty_list(env, argv[options_arg_num]))
+	return 1;
 
-    if (algorithm != atom_rsa)
-        goto bad_arg;
+    if (argv[algorithm_arg_num] != atom_rsa)
+        assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Only RSA supports Options"));
 
-    tail = options;
+    tail = argv[options_arg_num];
     while (enif_get_list_cell(env, tail, &head, &tail)) {
-        if (!enif_get_tuple(env, head, &tpl_arity, &tpl_terms))
-            goto bad_arg;
-        if (tpl_arity != 2)
-            goto bad_arg;
-
-        if (tpl_terms[0] == atom_rsa_mgf1_md && enif_is_atom(env, tpl_terms[1])) {
-            int result;
-
-            result = get_pkey_digest_type(env, algorithm, tpl_terms[1], &opt_md);
-            if (result != PKEY_OK)
-                return result;
-
+        if (!enif_get_tuple(env, head, &tpl_arity, &tpl_terms) ||
+            (tpl_arity != 2))
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Expects only two-tuples in the list"));
+
+        if (tpl_terms[0] == atom_rsa_mgf1_md) {
+            if (!enif_is_atom(env, tpl_terms[1]))
+                assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Atom expected as argument to option rsa_mgf1_md"));
+
+            if (!get_pkey_digest_type(env, argv[algorithm_arg_num],
+                                      options_arg_num, tpl_terms[1],
+                                      &opt_md, err_return))
+                goto err; /* An exception is present in ret */
+            
             opt->rsa_mgf1_md = opt_md;
 
         } else if (tpl_terms[0] == atom_rsa_padding) {
@@ -227,7 +297,7 @@ static int get_pkey_sign_options(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NIF
                 if (opt->rsa_mgf1_md == NULL)
                     opt->rsa_mgf1_md = md;
 #else
-                return PKEY_NOTSUP;
+                assign_goto(*err_return, err, EXCP_NOTSUP_N(env, options_arg_num, "rsa_pkcs1_pss_padding not supported"));
 #endif
 
             } else if (tpl_terms[1] == atom_rsa_x931_padding) {
@@ -237,172 +307,163 @@ static int get_pkey_sign_options(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NIF
                 opt->rsa_padding = RSA_NO_PADDING;
 
             } else {
-                goto bad_arg;
+                assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Bad value in option rsa_padding"));
             }
 
         } else if (tpl_terms[0] == atom_rsa_pss_saltlen) {
-            if (!enif_get_int(env, tpl_terms[1], &(opt->rsa_pss_saltlen)))
-                goto bad_arg;
-            if (opt->rsa_pss_saltlen < -2)
-                goto bad_arg;
+            if (!enif_get_int(env, tpl_terms[1], &(opt->rsa_pss_saltlen)) ||
+                (opt->rsa_pss_saltlen < -2) )
+                assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Bad value in option rsa_pss_saltlen"));
 
         } else {
-            goto bad_arg;
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Bad option"));
         }
     }
 
-    return PKEY_OK;
+    return 1;
 
- bad_arg:
-    return PKEY_BADARG;
+ err:
+    return 0;
 }
 
-static int get_pkey_private_key(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NIF_TERM key, EVP_PKEY **pkey)
+static int get_pkey_private_key(ErlNifEnv *env,
+                               const ERL_NIF_TERM argv[],
+                               int algorithm_arg_num, int key_arg_num,
+			       EVP_PKEY **pkey,
+                               ERL_NIF_TERM *err_return)
 {
-    EVP_PKEY *result = NULL;
     char *id = NULL;
     char *password = NULL;
+    int ret;
 
-    if (enif_is_map(env, key)) {
+    if (enif_is_map(env, argv[key_arg_num])) {
 #ifdef HAS_ENGINE_SUPPORT
         /* Use key stored in engine */
         ENGINE *e;
 
-        if (!get_engine_and_key_id(env, key, &id, &e))
-            goto err;
-
-        password = get_key_password(env, key);
-        result = ENGINE_load_private_key(e, id, NULL, password);
+        if (!get_engine_and_key_id(env, argv[key_arg_num], &id, &e))
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, key_arg_num, "Couldn't get engine and/or key id"));
 
+        password = get_key_password(env, argv[key_arg_num]);
+        *pkey = ENGINE_load_private_key(e, id, NULL, password);
+        if (!*pkey)
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, key_arg_num, "Couldn't get private key from engine"));
 #else
-        return PKEY_BADARG;
+        assign_goto(*err_return, err, EXCP_BADARG_N(env, key_arg_num, "No engine support"));
 #endif
 
-    } else if (algorithm == atom_rsa) {
-        if ((result = EVP_PKEY_new()) == NULL)
-            goto err;
-        if (!get_rsa_private_key(env, key, &result))
-            goto err;
+    } else  if (argv[algorithm_arg_num] == atom_rsa) {
+        if (!get_rsa_private_key(env, argv[key_arg_num], pkey))
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, key_arg_num, "Couldn't get RSA private key"));
 
-    } else if (algorithm == atom_ecdsa) {
+    } else if (argv[algorithm_arg_num] == atom_ecdsa) {
 #if defined(HAVE_EC)
-        if ((result = EVP_PKEY_new()) == NULL)
-            goto err;
-        if (!get_ec_private_key(env, key, &result))
-            goto err;
+        if (!get_ec_private_key(env, argv[key_arg_num], pkey))
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, key_arg_num, "Couldn't get ECDSA private key"));
 #else
-	return PKEY_NOTSUP;
+	assign_goto(*err_return, err, EXCP_NOTSUP_N(env, algorithm_arg_num, "ECDSA not supported"));
 #endif
 
-    } else if (algorithm == atom_eddsa) {
+    } else if (argv[algorithm_arg_num] == atom_eddsa) {
 #ifdef HAVE_EDDSA
-        if (FIPS_MODE())
-            return PKEY_NOTSUP;
-        if (!get_eddsa_key(env, 0, key, &result))
-            goto err;
+        if (!FIPS_MODE()) {
+            if (!get_eddsa_key(env, 0, argv[key_arg_num], pkey))
+                assign_goto(*err_return, err, EXCP_BADARG_N(env, key_arg_num, "Couldn't get EDDSA private key"));
+        } else
+            assign_goto(*err_return, err, EXCP_NOTSUP_N(env, algorithm_arg_num, "EDDSA not supported in FIPS mode"));
 #else
-            return PKEY_NOTSUP;
-#endif
+        assign_goto(*err_return, err, EXCP_NOTSUP_N(env, algorithm_arg_num, "EDDSA not supported"));
+#endif        
 
-    } else if (algorithm == atom_dss) {
+    } else if (argv[algorithm_arg_num] == atom_dss) {
 #ifdef HAVE_DSA
-        if ((result = EVP_PKEY_new()) == NULL)
-            goto err;
-        if (!get_dss_private_key(env, key, &result))
-            goto err;
+        if (!get_dss_private_key(env, argv[key_arg_num], pkey))
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, key_arg_num, "Couldn't get DSA private key"));
 #else
-        return PKEY_NOTSUP;
+        assign_goto(*err_return, err, EXCP_NOTSUP_N(env, algorithm_arg_num, "DSA not supported"));
 #endif
 
     } else
-	return PKEY_BADARG;
-
+          assign_goto(*err_return, err, EXCP_BADARG_N(env, algorithm_arg_num, "Bad algorithm"));  
 
- free_and_return:
+    ret = 1;
+ done:
     if (password)
         enif_free(password);
     if (id)
         enif_free(id);
 
-    if (result == NULL) {
-        return PKEY_BADARG;
-    } else {
-        *pkey = result;
-        return PKEY_OK;
-    }
+    return ret;
 
  err:
-    if (result)
-        EVP_PKEY_free(result);
-    result = NULL;
-    goto free_and_return;
+    if (*pkey)
+        EVP_PKEY_free(*pkey);
+    *pkey = NULL;
+    ret = 0;
+    goto done;
 }
 
 
-static int get_pkey_public_key(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NIF_TERM key,
-			       EVP_PKEY **pkey)
+static int get_pkey_public_key(ErlNifEnv *env,
+                               const ERL_NIF_TERM argv[],
+                               int algorithm_arg_num, int key_arg_num,
+			       EVP_PKEY **pkey,
+                               ERL_NIF_TERM *err_return)
 {
-    EVP_PKEY *result = NULL;
     char *id = NULL;
     char *password = NULL;
+    int ret;
 
-    if (enif_is_map(env, key)) {
+    if (enif_is_map(env, argv[key_arg_num])) {
 #ifdef HAS_ENGINE_SUPPORT
         /* Use key stored in engine */
         ENGINE *e;
 
-        if (!get_engine_and_key_id(env, key, &id, &e))
-            goto err;
-
-        password = get_key_password(env, key);
-        result = ENGINE_load_public_key(e, id, NULL, password);
+        if (!get_engine_and_key_id(env, argv[key_arg_num], &id, &e))
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, key_arg_num, "Couldn't get engine and/or key id"));
 
+        password = get_key_password(env, argv[key_arg_num]);
+        *pkey = ENGINE_load_public_key(e, id, NULL, password);
+        if (!pkey)
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, key_arg_num, "Couldn't get public key from engine"));
 #else
-        return PKEY_BADARG;
+        assign_goto(*err_return, err, EXCP_BADARG_N(env, key_arg_num, "No engine support"));
 #endif
-    } else  if (algorithm == atom_rsa) {
-        if ((result = EVP_PKEY_new()) == NULL)
-            goto err;
-        if (!get_rsa_public_key(env, key, &result))
-            goto err;
 
-    } else if (algorithm == atom_ecdsa) {
+    } else  if (argv[algorithm_arg_num] == atom_rsa) {
+        if (!get_rsa_public_key(env, argv[key_arg_num], pkey))
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, key_arg_num, "Couldn't get RSA public key"));
+
+    } else if (argv[algorithm_arg_num] == atom_ecdsa) {
 #if defined(HAVE_EC)
-        if ((result = EVP_PKEY_new()) == NULL)
-            goto err;
-        if (!get_ec_public_key(env, key, &result))
-            goto err;
+        if (!get_ec_public_key(env, argv[key_arg_num], pkey))
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, key_arg_num, "Couldn't get ECDSA public key"));
 #else
-	return PKEY_NOTSUP;
+        assign_goto(*err_return, err, EXCP_NOTSUP_N(env, algorithm_arg_num, "ECDSA not supported"));
 #endif
-    } else if (algorithm == atom_eddsa) {
+
+    } else if (argv[algorithm_arg_num] == atom_eddsa) {
 #ifdef HAVE_EDDSA
         if (!FIPS_MODE()) {
-            if (!get_eddsa_key(env, 1, key, &result))
-                goto err;
-        }
+            if (!get_eddsa_key(env, 1, argv[key_arg_num], pkey))
+                assign_goto(*err_return, err, EXCP_BADARG_N(env, key_arg_num, "Couldn't get EDDSA public key"));
+        } else
+            assign_goto(*err_return, err, EXCP_NOTSUP_N(env, algorithm_arg_num, "EDDSA not supported in FIPS mode"));
 #else
-	return PKEY_NOTSUP;
+        assign_goto(*err_return, err, EXCP_NOTSUP_N(env, algorithm_arg_num, "EDDSA not supported"));
 #endif
-    } else if (algorithm == atom_dss) {
+
+    } else if (argv[algorithm_arg_num] == atom_dss) {
 #ifdef HAVE_DSA
-        if ((result = EVP_PKEY_new()) == NULL)
-            goto err;
-        if (!get_dss_public_key(env, key, &result))
-            goto err;
+        if (!get_dss_public_key(env, argv[key_arg_num], pkey))
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, key_arg_num, "Couldn't get DSA public key"));
 #else
-        return PKEY_NOTSUP;
+        assign_goto(*err_return, err, EXCP_NOTSUP_N(env, algorithm_arg_num, "DSA not supported"));
 #endif
-    } else {
-	return PKEY_BADARG;
-    }
-
-    goto done;
+    } else
+        assign_goto(*err_return, err, EXCP_BADARG_N(env, algorithm_arg_num, "Bad algorithm"));
 
- err:
-    if (result)
-        EVP_PKEY_free(result);
-    result = NULL;
+    ret = 1;
 
  done:
     if (password)
@@ -410,440 +471,431 @@ static int get_pkey_public_key(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NIF_T
     if (id)
         enif_free(id);
 
-    if (result == NULL) {
-        return PKEY_BADARG;
-    } else {
-        *pkey = result;
-        return PKEY_OK;
-    }
+    return ret;
+
+ err:
+    if (*pkey)
+        EVP_PKEY_free(*pkey);
+    *pkey = NULL;
+    ret = 0;
+    goto done;
 }
 
 ERL_NIF_TERM pkey_sign_nif(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
 {/* (Algorithm, Type, Data|{digest,Digest}, Key|#{}, Options) */
-    int i;
     int sig_bin_alloc = 0;
-    ERL_NIF_TERM ret;
+    ERL_NIF_TERM ret = atom_undefined;
     const EVP_MD *md = NULL;
     unsigned char md_value[EVP_MAX_MD_SIZE];
     EVP_PKEY *pkey = NULL;
-#ifdef HAVE_EDDSA
-    EVP_MD_CTX *mdctx = NULL;
-#endif
 #ifdef HAS_EVP_PKEY_CTX
     EVP_PKEY_CTX *ctx = NULL;
     size_t siglen;
 #else
     int len;
     unsigned int siglen;
+    RSA *rsa = NULL;
+# ifdef HAVE_DSA
+    DSA *dsa = NULL;
+# endif
+# if defined(HAVE_EC)
+    EC_KEY *ec = NULL;
+# endif
 #endif
     PKeySignOptions sig_opt;
     ErlNifBinary sig_bin; /* signature */
     unsigned char *tbs = NULL; /* data to be signed */
     size_t tbslen = 0;
-    RSA *rsa = NULL;
-#ifdef HAVE_DSA
-    DSA *dsa = NULL;
-#endif
-#if defined(HAVE_EC)
-    EC_KEY *ec = NULL;
-#endif
-/*char buf[1024];
-enif_get_atom(env,argv[0],buf,1024,ERL_NIF_LATIN1); printf("algo=%s ",buf);
-enif_get_atom(env,argv[1],buf,1024,ERL_NIF_LATIN1); printf("hash=%s ",buf);
-*/
 
 #ifndef HAS_ENGINE_SUPPORT
     if (enif_is_map(env, argv[3]))
-        return atom_notsup;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 3, "No engine support"));
 #endif
+    if (!get_pkey_sign_digest(env, argv, 0, 1, 2, md_value, &md, &tbs, &tbslen, &ret))
+        goto err; /* An exception is present in ret */
 
-    i = get_pkey_sign_digest(env, argv[0], argv[1], argv[2], md_value, &md, &tbs, &tbslen);
-    switch (i) {
-    case PKEY_OK:
-        break;
-    case PKEY_NOTSUP:
-        goto notsup;
-    default:
-        goto bad_arg;
-    }
-
-    i = get_pkey_sign_options(env, argv[0], argv[4], md, &sig_opt);
-    switch (i) {
-    case PKEY_OK:
-        break;
-    case PKEY_NOTSUP:
-        goto notsup;
-    default:
-        goto bad_arg;
-    }
-
-    if (get_pkey_private_key(env, argv[0], argv[3], &pkey) != PKEY_OK)
-        goto bad_arg;
+    if (!get_pkey_sign_options(env, argv, 0, 4, md, &sig_opt, &ret))
+        goto err; /* An exception is present in ret */
 
 #ifdef HAS_EVP_PKEY_CTX
-    if ((ctx = EVP_PKEY_CTX_new(pkey, NULL)) == NULL)
-        goto err;
-
-    if (argv[0] != atom_eddsa) {
-        if (EVP_PKEY_sign_init(ctx) != 1)
-            goto err;
-        if (md != NULL) {
-            if (EVP_PKEY_CTX_set_signature_md(ctx, md) != 1)
-                goto err;
+    { /* EVP_MD_CTX */
+        if (!get_pkey_private_key(env, argv, 0, 3, &pkey, &ret))
+            goto err; /* An exception is present in ret */
+
+        if ((ctx = EVP_PKEY_CTX_new(pkey, NULL)) == NULL)
+            assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate new EVP_PKEY_CTX"));
+
+        if (argv[0] != atom_eddsa) {
+            if (EVP_PKEY_sign_init(ctx) != 1)
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_sign_init"));
+            if (md != NULL) {
+                if (EVP_PKEY_CTX_set_signature_md(ctx, md) != 1)
+                    assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_CTX_set_signature_md"));
+            }
         }
-    }
 
-    if (argv[0] == atom_rsa) {
-        if (EVP_PKEY_CTX_set_rsa_padding(ctx, sig_opt.rsa_padding) != 1)
-            goto err;
+        if (argv[0] == atom_rsa) {
+            if (EVP_PKEY_CTX_set_rsa_padding(ctx, sig_opt.rsa_padding) != 1)
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_CTX_set_rsa_padding"));
 # ifdef HAVE_RSA_PKCS1_PSS_PADDING
-	if (sig_opt.rsa_padding == RSA_PKCS1_PSS_PADDING) {
-            if (sig_opt.rsa_mgf1_md != NULL) {
+            if (sig_opt.rsa_padding == RSA_PKCS1_PSS_PADDING) {
+                if (sig_opt.rsa_mgf1_md != NULL) {
 #  ifdef HAVE_RSA_MGF1_MD
-                if (EVP_PKEY_CTX_set_rsa_mgf1_md(ctx, sig_opt.rsa_mgf1_md) != 1)
-                    goto err;
+                    if (EVP_PKEY_CTX_set_rsa_mgf1_md(ctx, sig_opt.rsa_mgf1_md) != 1)
+                        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_CTX_set_rsa_mgf1_md"));
 #  else
-                goto notsup;
+                    assign_goto(ret, err, EXCP_NOTSUP_N(env, 4, "rsa_mgf1_md unavailable with this cryptolib"));
 #  endif
+                }
+                if (sig_opt.rsa_pss_saltlen > -2) {
+                    if (EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx, sig_opt.rsa_pss_saltlen) != 1)
+                        assign_goto(ret, err, EXCP_BADARG_N(env, 4, "Bad rsa_pss_saltlen"));
+                }
             }
-            if (sig_opt.rsa_pss_saltlen > -2) {
-                if (EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx, sig_opt.rsa_pss_saltlen) != 1)
-                    goto err;
-            }
-        }
 # endif
-    }
+        }
 
-    if (argv[0] == atom_eddsa) {
+        if (argv[0] == atom_eddsa) {
 # ifdef HAVE_EDDSA
-        if (!FIPS_MODE()) {
-            if ((mdctx = EVP_MD_CTX_new()) == NULL)
-                goto err;
+            if (!FIPS_MODE()) {
+                EVP_MD_CTX *mdctx = NULL;
+                if ((mdctx = EVP_MD_CTX_new()) == NULL)
+                    assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_MD_CTX_new"));
+
+                if (EVP_DigestSignInit(mdctx, NULL, NULL, NULL, pkey) != 1)
+                    assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_DigestSignInit"));
+                if (EVP_DigestSign(mdctx, NULL, &siglen, tbs, tbslen) != 1)
+                    assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_DigestSign"));
+                if (!enif_alloc_binary(siglen, &sig_bin))
+                    assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate binary"));
+                sig_bin_alloc = 1;
+
+                if (EVP_DigestSign(mdctx, sig_bin.data, &siglen, tbs, tbslen) != 1) {
+                    if (mdctx)
+                        EVP_MD_CTX_free(mdctx);
+                    assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_DigestSign"));
+                }
+                if (mdctx)
+                    EVP_MD_CTX_free(mdctx);
+            }
+            else
+# endif
+                assign_goto(ret, err, EXCP_NOTSUP_N(env, 0, "eddsa not supported"));
+        } else {
+
+# ifndef HAVE_DSA
+            if (argv[0] == atom_dss)  assign_goto(ret, err, EXCP_NOTSUP_N(env, 0, "dsa not supported"));
+        } else {
+# endif
+            if (EVP_PKEY_sign(ctx, NULL, &siglen, tbs, tbslen) != 1)
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_sign"));
 
-            if (EVP_DigestSignInit(mdctx, NULL, NULL, NULL, pkey) != 1)
-                goto err;
-            if (EVP_DigestSign(mdctx, NULL, &siglen, tbs, tbslen) != 1)
-                goto err;
             if (!enif_alloc_binary(siglen, &sig_bin))
-                goto err;
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate binary"));
             sig_bin_alloc = 1;
 
-            if (EVP_DigestSign(mdctx, sig_bin.data, &siglen, tbs, tbslen) != 1)
-                goto bad_key;
+            if (md != NULL) {
+                ERL_VALGRIND_ASSERT_MEM_DEFINED(tbs, EVP_MD_size(md));
+            }
+            if (EVP_PKEY_sign(ctx, sig_bin.data, &siglen, tbs, tbslen) != 1)
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_sign"));
         }
-        else
-# endif
-            goto notsup;
-    } else {
-        if (EVP_PKEY_sign(ctx, NULL, &siglen, tbs, tbslen) != 1)
-            goto err;
-        if (!enif_alloc_binary(siglen, &sig_bin))
-            goto err;
-        sig_bin_alloc = 1;
-
-        if (md != NULL) {
-            ERL_VALGRIND_ASSERT_MEM_DEFINED(tbs, EVP_MD_size(md));
-        }
-        if (EVP_PKEY_sign(ctx, sig_bin.data, &siglen, tbs, tbslen) != 1)
-            goto bad_key;
-    }
-#else
-/*printf("Old interface\r\n");
- */
-    if (argv[0] == atom_rsa) {
-        if ((rsa = EVP_PKEY_get1_RSA(pkey)) == NULL)
-            goto err;
-        if ((len = RSA_size(rsa)) < 0)
-            goto err;
-        if (!enif_alloc_binary((size_t)len, &sig_bin))
-            goto err;
-        sig_bin_alloc = 1;
-
-        if ((len = EVP_MD_size(md)) < 0)
-            goto err;
-        ERL_VALGRIND_ASSERT_MEM_DEFINED(tbs, len);
-
-        if (RSA_sign(md->type, tbs, (unsigned int)len, sig_bin.data, &siglen, rsa) != 1)
-            goto bad_key;
-    } else if (argv[0] == atom_dss) {
-        if ((dsa = EVP_PKEY_get1_DSA(pkey)) == NULL)
-            goto err;
-        if ((len = DSA_size(dsa)) < 0)
-            goto err;
-        if (!enif_alloc_binary((size_t)len, &sig_bin))
-            goto err;
-        sig_bin_alloc = 1;
-
-        if ((len = EVP_MD_size(md)) < 0)
-            goto err;
-        ERL_VALGRIND_ASSERT_MEM_DEFINED(tbs, len);
-
-        if (DSA_sign(md->type, tbs, len, sig_bin.data, &siglen, dsa) != 1)
-            goto bad_key;
-    } else if (argv[0] == atom_ecdsa) {
-#if defined(HAVE_EC)
-        if ((ec = EVP_PKEY_get1_EC_KEY(pkey)) == NULL)
-            goto err;
-        if ((len = ECDSA_size(ec)) < 0)
-            goto err;
-        if (!enif_alloc_binary((size_t)len, &sig_bin))
-            goto err;
-        sig_bin_alloc = 1;
-
-        len = EVP_MD_size(md);
-        ERL_VALGRIND_ASSERT_MEM_DEFINED(tbs, len);
-
-        if (ECDSA_sign(md->type, tbs, len, sig_bin.data, &siglen, ec) != 1)
-            goto bad_key;
-#else
-        goto notsup;
-#endif
-    } else {
-        goto bad_arg;
-    }
-#endif
 
     ERL_VALGRIND_MAKE_MEM_DEFINED(sig_bin.data, siglen);
     if (siglen != sig_bin.size) {
         if (!enif_realloc_binary(&sig_bin, siglen))
-            goto err;
+            assign_goto(ret, err, EXCP_ERROR(env, "Can't reallocate binary"));
         ERL_VALGRIND_ASSERT_MEM_DEFINED(sig_bin.data, siglen);
     }
+
     ret = enif_make_binary(env, &sig_bin);
     sig_bin_alloc = 0;
-    goto done;
-
- bad_key:
-    ret = atom_error;
-    goto done;
-
- notsup:
-    ret = atom_notsup;
-    goto done;
-
- bad_arg:
- err:
-    ret = enif_make_badarg(env);
-    goto done;
 
- done:
+    err:
     if (sig_bin_alloc)
         enif_release_binary(&sig_bin);
-    if (rsa)
-        RSA_free(rsa);
-#ifdef HAVE_DSA
-    if (dsa)
-        DSA_free(dsa);
-#endif
-#ifdef HAVE_EC
-    if (ec)
-        EC_KEY_free(ec);
-#endif
-#ifdef HAS_EVP_PKEY_CTX
     if (ctx)
         EVP_PKEY_CTX_free(ctx);
-#endif
     if (pkey)
         EVP_PKEY_free(pkey);
+    return ret;
+    }
+    /* End of HAS_EVP_PKEY_CTX */
+#else
+    /* Old interface - before EVP_PKEY_CTX */
+    {
+        if (!get_pkey_private_key(env, argv, 0, 3, &pkey, &ret))
+            goto err;  /* An exception is present in ret */
+
+        if (argv[0] == atom_rsa) {
+            if ((rsa = EVP_PKEY_get1_RSA(pkey)) == NULL)
+                assign_goto(ret, err, EXCP_BADARG_N(env, 3, "Not an RSA private key"));
+            if ((len = RSA_size(rsa)) < 0)
+                assign_goto(ret, err, EXCP_BADARG_N(env, 3, "Bad RSA private key length"));
+            if (!enif_alloc_binary((size_t)len, &sig_bin))
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate binary"));
+            sig_bin_alloc = 1;
 
-#ifdef HAVE_EDDSA
-    if (mdctx)
-        EVP_MD_CTX_free(mdctx);
+            if ((len = EVP_MD_size(md)) < 0)
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't get md length"));
+            ERL_VALGRIND_ASSERT_MEM_DEFINED(tbs, len);
+
+            if (RSA_sign(md->type, tbs, (unsigned int)len, sig_bin.data, &siglen, rsa) != 1)
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't sign"));
+                            
+        } else if (argv[0] == atom_dss) {
+            if ((dsa = EVP_PKEY_get1_DSA(pkey)) == NULL)
+                assign_goto(ret, err, EXCP_BADARG_N(env, 3, "Not an DSA private key"));
+            if ((len = DSA_size(dsa)) < 0)
+                assign_goto(ret, err, EXCP_BADARG_N(env, 3, "Bad DSA private key length"));
+            if (!enif_alloc_binary((size_t)len, &sig_bin))
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate binary"));
+            sig_bin_alloc = 1;
+
+            if ((len = EVP_MD_size(md)) < 0)
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't get md length"));
+            ERL_VALGRIND_ASSERT_MEM_DEFINED(tbs, len);
+
+            if (DSA_sign(md->type, tbs, len, sig_bin.data, &siglen, dsa) != 1)
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't sign"));
+        } else if (argv[0] == atom_ecdsa) {
+# if defined(HAVE_EC)
+            if ((ec = EVP_PKEY_get1_EC_KEY(pkey)) == NULL)
+                assign_goto(ret, err, EXCP_BADARG_N(env, 3, "Not an ECDSA private key"));
+            if ((len = ECDSA_size(ec)) < 0)
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't get size"));
+            if (!enif_alloc_binary((size_t)len, &sig_bin))
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate binary"));
+            sig_bin_alloc = 1;
+
+            len = EVP_MD_size(md);
+            ERL_VALGRIND_ASSERT_MEM_DEFINED(tbs, len);
+
+            if (ECDSA_sign(md->type, tbs, len, sig_bin.data, &siglen, ec) != 1)
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't sign"));
+# else
+            assign_goto(ret, notsup, EXCP_NOTSUP_N(env, 0, "ecdsa not supported"));
+# endif /* HAVE_EC */
+        } else {
+            assign_goto(ret, notsup, EXCP_BADARG_N(env, 0, "Unknown algorithm"));
+        }
+
+        ERL_VALGRIND_MAKE_MEM_DEFINED(sig_bin.data, siglen);
+        if (siglen != sig_bin.size) {
+            if (!enif_realloc_binary(&sig_bin, siglen))
+                 assign_goto(ret, err, EXCP_ERROR(env, "Can't re-allocate binary"));
+            ERL_VALGRIND_ASSERT_MEM_DEFINED(sig_bin.data, siglen);
+        }
+        ret = enif_make_binary(env, &sig_bin);
+        sig_bin_alloc = 0;
+
+    notsup:
+    err:
+        if (sig_bin_alloc)
+            enif_release_binary(&sig_bin);
+        if (rsa)
+            RSA_free(rsa);
+# ifdef HAVE_DSA
+        if (dsa)
+            DSA_free(dsa);
+# endif
+# ifdef HAVE_EC
+        if (ec)
+            EC_KEY_free(ec);
+# endif
+# ifdef HAS_EVP_PKEY_CTX
+        if (ctx)
+            EVP_PKEY_CTX_free(ctx);
+# endif
+        if (pkey)
+            EVP_PKEY_free(pkey);
+
+        return ret;
+    }
 #endif
 
-    return ret;
 }
 
+
+
 ERL_NIF_TERM pkey_verify_nif(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
 {/* (Algorithm, Type, Data|{digest,Digest}, Signature, Key, Options) */
-    int i;
     int result;
     const EVP_MD *md = NULL;
     unsigned char md_value[EVP_MAX_MD_SIZE];
     EVP_PKEY *pkey = NULL;
-#ifdef HAS_EVP_PKEY_CTX
-    EVP_PKEY_CTX *ctx = NULL;
-#else
-#endif
     PKeySignOptions sig_opt;
     ErlNifBinary sig_bin; /* signature */
     unsigned char *tbs = NULL; /* data to be signed */
     size_t tbslen = 0;
-    ERL_NIF_TERM ret;
+    ERL_NIF_TERM ret = atom_undefined;
+
+#ifdef HAS_EVP_PKEY_CTX
+    EVP_PKEY_CTX *ctx = NULL;
+#else
     RSA *rsa = NULL;
-#ifdef HAVE_DSA
-    DSA *dsa = NULL;
-#endif
-#ifdef HAVE_EC
-    EC_KEY *ec = NULL;
-#endif
-#ifdef HAVE_EDDSA
-    EVP_MD_CTX *mdctx = NULL;
-#endif
+# ifdef HAVE_DSA
+        DSA *dsa = NULL;
+# endif
+# ifdef HAVE_EC
+        EC_KEY *ec = NULL;
+# endif
+#endif  // HAS_EVP_PKEY_CTX
+
 
 #ifndef HAS_ENGINE_SUPPORT
-    if (enif_is_map(env, argv[4]))
-        return atom_notsup;
+    if (enif_is_map(env, argv[3]))
+        assign_goto(ret, err, EXCP_BADARG_N(env, 3, "No engine support"));
 #endif
 
-    if (!enif_inspect_binary(env, argv[3], &sig_bin))
-	return enif_make_badarg(env);
-
-    i = get_pkey_sign_digest(env, argv[0], argv[1], argv[2], md_value, &md, &tbs, &tbslen);
-    switch (i) {
-    case PKEY_OK:
-        break;
-    case PKEY_NOTSUP:
-        goto notsup;
-    default:
-        goto bad_arg;
-    }
+    if (!get_pkey_sign_digest(env, argv, 0, 1, 2, md_value, &md, &tbs, &tbslen, &ret))
+        goto err; /* An exception is present in ret */
 
-    i = get_pkey_sign_options(env, argv[0], argv[5], md, &sig_opt);
-    switch (i) {
-    case PKEY_OK:
-        break;
-    case PKEY_NOTSUP:
-        goto notsup;
-    default:
-        goto bad_arg;
-    }
+    if (!get_pkey_sign_options(env, argv, 0, 5, md, &sig_opt, &ret))
+        goto err; /* An exception is present in ret */
 
-    if (get_pkey_public_key(env, argv[0], argv[4], &pkey) != PKEY_OK) {
-        goto bad_arg;
-    }
+    if (!enif_inspect_binary(env, argv[3], &sig_bin))
+        assign_goto(ret, err, EXCP_BADARG_N(env, 3, "Expected a binary"));
 
 #ifdef HAS_EVP_PKEY_CTX
-/* printf("EVP interface\r\n");
- */
-    if ((ctx = EVP_PKEY_CTX_new(pkey, NULL)) == NULL)
-        goto err;
-
-    if (argv[0] != atom_eddsa) {
-        if (EVP_PKEY_verify_init(ctx) != 1)
-            goto err;
-        if (md != NULL) {
-            if (EVP_PKEY_CTX_set_signature_md(ctx, md) != 1)
-                goto err;
+    /* EVP_PKEY_CTX */
+    {
+        if (!get_pkey_public_key(env, argv, 0, 4, &pkey, &ret))
+            goto err; /* An exception is present in ret */
+
+        if ((ctx = EVP_PKEY_CTX_new(pkey, NULL)) == NULL)
+            assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate new EVP_PKEY_CTX"));
+
+        if (argv[0] != atom_eddsa) {
+            if (EVP_PKEY_verify_init(ctx) != 1)
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_sign_init"));
+            if (md != NULL) {
+                if (EVP_PKEY_CTX_set_signature_md(ctx, md) != 1)
+                    assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_CTX_set_signature_md"));
+            }
         }
-    }
 
-    if (argv[0] == atom_rsa) {
-        if (EVP_PKEY_CTX_set_rsa_padding(ctx, sig_opt.rsa_padding) != 1)
-            goto err;
-        if (sig_opt.rsa_padding == RSA_PKCS1_PSS_PADDING) {
-            if (sig_opt.rsa_mgf1_md != NULL) {
-# ifdef HAVE_RSA_MGF1_MD
-                if (EVP_PKEY_CTX_set_rsa_mgf1_md(ctx, sig_opt.rsa_mgf1_md) != 1)
-                    goto err;
-# else
-                goto notsup;
-# endif
-            }
-            if (sig_opt.rsa_pss_saltlen > -2) {
-                if (EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx, sig_opt.rsa_pss_saltlen) != 1)
-                    goto err;
+        if (argv[0] == atom_rsa) {
+            if (EVP_PKEY_CTX_set_rsa_padding(ctx, sig_opt.rsa_padding) != 1)
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_CTX_set_rsa_padding"));
+# ifdef HAVE_RSA_PKCS1_PSS_PADDING
+            if (sig_opt.rsa_padding == RSA_PKCS1_PSS_PADDING) {
+                if (sig_opt.rsa_mgf1_md != NULL) {
+#  ifdef HAVE_RSA_MGF1_MD
+                    if (EVP_PKEY_CTX_set_rsa_mgf1_md(ctx, sig_opt.rsa_mgf1_md) != 1)
+                        assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_CTX_set_rsa_mgf1_md"));
+#  else
+                    assign_goto(ret, err, EXCP_NOTSUP_N(env, 5, "rsa_mgf1_md unavailable with this cryptolib"));
+#  endif
+                }
+                if (sig_opt.rsa_pss_saltlen > -2) {
+                    if (EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx, sig_opt.rsa_pss_saltlen) != 1)
+                        assign_goto(ret, err, EXCP_BADARG_N(env, 5, "Bad rsa_pss_saltlen"));
+                }
             }
+# endif
         }
-    }
 
-    if (argv[0] == atom_eddsa) {
-#ifdef HAVE_EDDSA
-        if (!FIPS_MODE()) {
-            if ((mdctx = EVP_MD_CTX_new()) == NULL)
-                goto err;
+        if (argv[0] == atom_eddsa) {
+# ifdef HAVE_EDDSA
+            EVP_MD_CTX *mdctx = NULL;
+            if (!FIPS_MODE()) {
+                if ((mdctx = EVP_MD_CTX_new()) == NULL)
+                     assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_MD_CTX_new"));
 
-            if (EVP_DigestVerifyInit(mdctx, NULL, NULL, NULL, pkey) != 1)
-                goto err;
+                if (EVP_DigestVerifyInit(mdctx, NULL, NULL, NULL, pkey) != 1)
+                    assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_DigestVerifyInit"));
 
-            result = EVP_DigestVerify(mdctx, sig_bin.data, sig_bin.size, tbs, tbslen);
-        }
-        else
-#endif
-        goto notsup;
-    } else {
-        if (md != NULL) {
-            ERL_VALGRIND_ASSERT_MEM_DEFINED(tbs, EVP_MD_size(md));
+                result = EVP_DigestVerify(mdctx, sig_bin.data, sig_bin.size, tbs, tbslen);
+                if (mdctx)
+                    EVP_MD_CTX_free(mdctx);
+            }
+            else
+# endif /* HAVE_EDDSA */
+                assign_goto(ret, err, EXCP_NOTSUP_N(env, 0, "eddsa not supported"));
+        } else {
+            /* RSA or DSS */
+            if (md != NULL) {
+                ERL_VALGRIND_ASSERT_MEM_DEFINED(tbs, EVP_MD_size(md));
+            }
+            result = EVP_PKEY_verify(ctx, sig_bin.data, sig_bin.size, tbs, tbslen);
         }
-        result = EVP_PKEY_verify(ctx, sig_bin.data, sig_bin.size, tbs, tbslen);
-    }
-#else
-/*printf("Old interface\r\n");
-*/
-    if (tbslen > INT_MAX)
-        goto bad_arg;
-    if (sig_bin.size > INT_MAX)
-        goto bad_arg;
-    if (argv[0] == atom_rsa) {
-        if ((rsa = EVP_PKEY_get1_RSA(pkey)) == NULL)
-            goto err;
-        result = RSA_verify(md->type, tbs, (unsigned int)tbslen, sig_bin.data, (unsigned int)sig_bin.size, rsa);
-    } else if (argv[0] == atom_dss) {
-        if ((dsa = EVP_PKEY_get1_DSA(pkey)) == NULL)
-            goto err;
-        result = DSA_verify(0, tbs, (int)tbslen, sig_bin.data, (int)sig_bin.size, dsa);
-    } else if (argv[0] == atom_ecdsa) {
-#if defined(HAVE_EC)
-        if ((ec = EVP_PKEY_get1_EC_KEY(pkey)) == NULL)
-            goto err;
-        result = ECDSA_verify(EVP_MD_type(md), tbs, (int)tbslen, sig_bin.data, (int)sig_bin.size, ec);
-#else
-        goto notsup;
-#endif
-    } else {
-        goto bad_arg;
-    }
-#endif
 
-    ret = (result == 1 ? atom_true : atom_false);
-    goto done;
+        ret = (result == 1 ? atom_true : atom_false);
 
- bad_arg:
- err:
-    ret = enif_make_badarg(env);
-    goto done;
+    err:
+        if (ctx)
+            EVP_PKEY_CTX_free(ctx);
+        if (pkey)
+            EVP_PKEY_free(pkey);
 
- notsup:
-    ret = atom_notsup;
+        return ret;
+    }
+    /* End of HAS_EVP_PKEY_CTX */
+#else
+    /* Old interface - before EVP_PKEY_CTX */
+    {
+        if (!get_pkey_public_key(env, argv, 0, 4, &pkey, &ret))
+            goto err; /* An exception is present in ret */
+
+        if (argv[0] == atom_rsa) {
+            if ((rsa = EVP_PKEY_get1_RSA(pkey)) == NULL)
+                assign_goto(ret, err, EXCP_BADARG_N(env, 4, "Not an RSA public key"));
+            result = RSA_verify(md->type, tbs, (unsigned int)tbslen, sig_bin.data, (unsigned int)sig_bin.size, rsa);
+        } else if (argv[0] == atom_dss) {
+            if ((dsa = EVP_PKEY_get1_DSA(pkey)) == NULL)
+                assign_goto(ret, err, EXCP_BADARG_N(env, 4, "Not an DSA public key"));
+            result = DSA_verify(0, tbs, (int)tbslen, sig_bin.data, (int)sig_bin.size, dsa);
+        } else if (argv[0] == atom_ecdsa) {
+# if defined(HAVE_EC)
+            if ((ec = EVP_PKEY_get1_EC_KEY(pkey)) == NULL)
+                assign_goto(ret, err, EXCP_BADARG_N(env, 4, "Not an ECDSA private key"));
+            result = ECDSA_verify(EVP_MD_type(md), tbs, (int)tbslen, sig_bin.data, (int)sig_bin.size, ec);
+# else
+            assign_goto(ret, err, EXCP_NOTSUP_N(env, 0, "ecdsa not supported"));
+# endif /* HAVE_EC */
+        } else {
+            assign_goto(ret, err, EXCP_BADARG_N(env, 0, "Unknown algorithm"));
+        }
+        ret = (result == 1 ? atom_true : atom_false);
+
+    err:
+        if (rsa)
+            RSA_free(rsa);
+# ifdef HAVE_DSA
+        if (dsa)
+            DSA_free(dsa);
+# endif
+# ifdef HAVE_EC
+        if (ec)
+            EC_KEY_free(ec);
+# endif
+        if (pkey)
+            EVP_PKEY_free(pkey);
 
- done:
-#ifdef HAS_EVP_PKEY_CTX
-    if (ctx)
-        EVP_PKEY_CTX_free(ctx);
-#endif
-#ifdef HAVE_EDDSA
-    if (mdctx)
-        EVP_MD_CTX_free(mdctx);
-#endif
-    if (pkey)
-        EVP_PKEY_free(pkey);
-    if (rsa)
-        RSA_free(rsa);
-#ifdef HAVE_DSA
-    if (dsa)
-        DSA_free(dsa);
-#endif
-#ifdef HAVE_EC
-    if (ec)
-        EC_KEY_free(ec);
-#endif
+        return ret;
+    }
+#endif /* Pre  EVP_PKEY_CTX */
 
-    return ret;
 }
 
-static int get_pkey_crypt_options(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NIF_TERM options,
-				  PKeyCryptOptions *opt)
+
+static int get_pkey_crypt_options(ErlNifEnv *env,
+                                  const ERL_NIF_TERM argv[],
+                                  int algorithm_arg_num, int options_arg_num,
+				  PKeyCryptOptions *opt,
+                                  ERL_NIF_TERM *err_return)
 {
     ERL_NIF_TERM head, tail;
     const ERL_NIF_TERM *tpl_terms;
     int tpl_arity;
     const EVP_MD *opt_md;
 
-    if (!enif_is_list(env, options))
-        goto bad_arg;
+    if (!enif_is_list(env, argv[options_arg_num]))
+        assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Expected a list"));
 
     /* defaults */
-    if (algorithm == atom_rsa) {
+    if (argv[algorithm_arg_num] == atom_rsa) {
         opt->rsa_mgf1_md = NULL;
         opt->rsa_oaep_label.data = NULL;
         opt->rsa_oaep_label.size = 0;
@@ -859,18 +911,17 @@ static int get_pkey_crypt_options(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NI
         opt->signature_md = NULL;
     }
 
-    if (enif_is_empty_list(env, options))
-        return PKEY_OK;
+    if (enif_is_empty_list(env, argv[options_arg_num]))
+        return 1; /* There are no options to fetch. Return OK */
 
-    if (algorithm != atom_rsa)
-        goto bad_arg;
+    if (argv[algorithm_arg_num] != atom_rsa)
+        assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Only RSA supports Options"));
 
-    tail = options;
+    tail = argv[options_arg_num];
     while (enif_get_list_cell(env, tail, &head, &tail)) {
-        if (!enif_get_tuple(env, head, &tpl_arity, &tpl_terms))
-            goto bad_arg;
-        if (tpl_arity != 2)
-            goto bad_arg;
+        if (!enif_get_tuple(env, head, &tpl_arity, &tpl_terms) ||
+            (tpl_arity != 2))
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Expect only two-tuples in the list"));
 
         if (tpl_terms[0] == atom_rsa_padding
             || tpl_terms[0] == atom_rsa_pad /* Compatibility */
@@ -894,59 +945,62 @@ static int get_pkey_crypt_options(ErlNifEnv *env, ERL_NIF_TERM algorithm, ERL_NI
             } else if (tpl_terms[1] == atom_rsa_no_padding) {
                 opt->rsa_padding = RSA_NO_PADDING;
 
-            } else {
-                goto bad_arg;
-            }
+            } else
+                assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Bad padding type in option rsa_padding"));
+
+        } else if (tpl_terms[0] == atom_signature_md) {
+            if (!enif_is_atom(env, tpl_terms[1]))
+                assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Atom expected as argument to option signature_md"));
+
+            if (!get_pkey_digest_type(env, argv[algorithm_arg_num],
+                                      options_arg_num, tpl_terms[1],
+                                      &opt_md, err_return))
+                goto err; /* An exception is present in ret */
 
-        } else if (tpl_terms[0] == atom_signature_md && enif_is_atom(env, tpl_terms[1])) {
-            int i;
-            i = get_pkey_digest_type(env, algorithm, tpl_terms[1], &opt_md);
-            if (i != PKEY_OK) {
-                return i;
-            }
             opt->signature_md = opt_md;
 
-        } else if (tpl_terms[0] == atom_rsa_mgf1_md && enif_is_atom(env, tpl_terms[1])) {
-            int i;
+        } else if (tpl_terms[0] == atom_rsa_mgf1_md) {
+            if (!enif_is_atom(env, tpl_terms[1]))
+                assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Atom expected as argument to option rsa_mgf1_md"));
 #ifndef HAVE_RSA_MGF1_MD
             if (tpl_terms[1] != atom_sha)
-                return PKEY_NOTSUP;
+                assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Only 'sha' is supported in option rsa_mgf1_md"));
 #endif
-            i = get_pkey_digest_type(env, algorithm, tpl_terms[1], &opt_md);
-            if (i != PKEY_OK) {
-                return i;
-            }
+            if (!get_pkey_digest_type(env, argv[algorithm_arg_num],
+                                      options_arg_num, tpl_terms[1],
+                                      &opt_md, err_return))
+                goto err; /* An exception is present in ret */
             opt->rsa_mgf1_md = opt_md;
 
-        } else if (tpl_terms[0] == atom_rsa_oaep_label
-                   && enif_inspect_binary(env, tpl_terms[1], &(opt->rsa_oaep_label))) {
+        } else if (tpl_terms[0] == atom_rsa_oaep_label) {
 #ifdef HAVE_RSA_OAEP_MD
+            if (!enif_inspect_binary(env, tpl_terms[1], &(opt->rsa_oaep_label)))
+                assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Binary expected for option rsa_oaep_label"));
             continue;
 #else
-            return PKEY_NOTSUP;
+            assign_goto(*err_return, err, EXCP_NOTSUP_N(env, options_arg_num, "Option rsa_oaep_label is not supported"));
 #endif
 
-        } else if (tpl_terms[0] == atom_rsa_oaep_md && enif_is_atom(env, tpl_terms[1])) {
-            int i;
+        } else if (tpl_terms[0] == atom_rsa_oaep_md) {
+            if (!enif_is_atom(env, tpl_terms[1]))
+                assign_goto(*err_return, err, EXCP_NOTSUP_N(env, options_arg_num, "Atom expected as argument to option rsa_oaep_md"));
 #ifndef HAVE_RSA_OAEP_MD
             if (tpl_terms[1] != atom_sha)
-                return PKEY_NOTSUP;
+                assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Only 'sha' is supported in option rsa_oaep_md"));
 #endif
-            i = get_pkey_digest_type(env, algorithm, tpl_terms[1], &opt_md);
-            if (i != PKEY_OK) {
-                return i;
-            }
+            if (!get_pkey_digest_type(env, argv[algorithm_arg_num],
+                                      options_arg_num, tpl_terms[1],
+                                      &opt_md, err_return))
+                goto err; /* An exception is present in ret */
             opt->rsa_oaep_md = opt_md;
-
-        } else {
-            goto bad_arg;
-        }
+        } else
+            assign_goto(*err_return, err, EXCP_BADARG_N(env, options_arg_num, "Unknown option"))
     }
 
-    return PKEY_OK;
+    return 1;
 
- bad_arg:
-    return PKEY_BADARG;
+ err:
+    return 0;
 }
 
 #ifdef HAVE_RSA_SSLV23_PADDING
@@ -968,8 +1022,7 @@ static size_t size_of_RSA(EVP_PKEY *pkey) {
 
 ERL_NIF_TERM pkey_crypt_nif(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
 {/* (Algorithm, Data, PublKey=[E,N]|[E,N,D]|[E,N,D,P1,P2,E1,E2,C], Options, IsPrivate, IsEncrypt) */
-    ERL_NIF_TERM ret;
-    int i;
+    ERL_NIF_TERM ret = atom_undefined;
     int result = 0;
     int tmp_bin_alloc = 0;
     int out_bin_alloc = 0;
@@ -987,74 +1040,61 @@ ERL_NIF_TERM pkey_crypt_nif(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
     size_t tmplen;
 #endif
     int is_private, is_encrypt;
-    int algo_init = 0;
     unsigned char *label_copy = NULL;
 
-    ASSERT(argc == 6);
-
     is_private = (argv[4] == atom_true);
     is_encrypt = (argv[5] == atom_true);
 
-/* char algo[1024]; */
+    if (!check_pkey_algorithm_type(env, 0, argv[0], &ret))
+        goto err; /* An exception is present in ret */
+
+    if (!enif_inspect_binary(env, argv[1], &in_bin))
+        assign_goto(ret, err, EXCP_BADARG_N(env, 1, "Binary expected"));
 
 #ifndef HAS_ENGINE_SUPPORT
     if (enif_is_map(env, argv[2]))
-        return atom_notsup;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 2, "No engine support"));
 #endif
 
-    if (!enif_inspect_binary(env, argv[1], &in_bin))
-        goto bad_arg;
-
-    i = get_pkey_crypt_options(env, argv[0], argv[3], &crypt_opt);
-    switch (i) {
-    case PKEY_OK:
-        break;
-    case PKEY_NOTSUP:
-        goto notsup;
-    default:
-        goto bad_arg;
-    }
-
     if (is_private) {
-        if (get_pkey_private_key(env, argv[0], argv[2], &pkey) != PKEY_OK)
-            goto bad_arg;
+        if (!get_pkey_private_key(env, argv, 0, 2, &pkey, &ret))
+            goto err; /* An exception is present in ret */
     } else {
-        if (get_pkey_public_key(env, argv[0], argv[2], &pkey) != PKEY_OK)
-            goto bad_arg;
+        if (!get_pkey_public_key(env, argv, 0, 2, &pkey, &ret))
+            goto err;  /* An exception is present in ret */
     }
 
+    if (!get_pkey_crypt_options(env, argv, 0, 3, &crypt_opt, &ret))
+        goto err; /* An exception is present in ret */
+
 #ifdef HAS_EVP_PKEY_CTX
-    if ((ctx = EVP_PKEY_CTX_new(pkey, NULL)) == NULL)
-        goto err;
+    {
+            int algo_init = 0;
 
-/* enif_get_atom(env,argv[0],algo,1024,ERL_NIF_LATIN1);  */
+            if ((ctx = EVP_PKEY_CTX_new(pkey, NULL)) == NULL)
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate new EVP_PKEY_CTX"));
 
-    if (is_private) {
-        if (is_encrypt) {
-            /* private encrypt */
-            if ((algo_init = EVP_PKEY_sign_init(ctx)) != 1)
-                goto bad_arg;
-        } else {
-            /* private decrypt */
-            if ((algo_init = EVP_PKEY_decrypt_init(ctx)) != 1)
-                goto bad_arg;
-        }
-    } else {
-        if (is_encrypt) {
-            /* public encrypt */
-            if ((algo_init = EVP_PKEY_encrypt_init(ctx)) != 1)
-                goto bad_arg;
-        } else {
-            /* public decrypt */
-            if ((algo_init = EVP_PKEY_verify_recover_init(ctx)) != 1)
-                goto bad_arg;
-        }
+            if (is_private) {
+                if (is_encrypt)
+                    algo_init = EVP_PKEY_sign_init(ctx);
+                else
+                    algo_init = EVP_PKEY_decrypt_init(ctx);
+
+            } else {
+                if (is_encrypt)
+                    algo_init = EVP_PKEY_encrypt_init(ctx);
+                else
+                    algo_init = EVP_PKEY_verify_recover_init(ctx);
+            }
+
+            if (algo_init != 1)
+                assign_goto(ret, err, EXCP_NOTSUP(env, "Can't initiate encrypt/decrypt"));
     }
 
     if (argv[0] == atom_rsa) {
         if (crypt_opt.signature_md != NULL) {
             if (EVP_PKEY_CTX_set_signature_md(ctx, crypt_opt.signature_md) != 1)
-                goto bad_arg;
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't EVP_PKEY_CTX_set_signature_md"));
         }
 
 # ifdef HAVE_RSA_SSLV23_PADDING
@@ -1062,40 +1102,38 @@ ERL_NIF_TERM pkey_crypt_nif(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
             if (is_encrypt) {
                 tmplen = size_of_RSA(pkey);
                 if (tmplen < 1 || tmplen > INT_MAX)
-                    goto err;
+                    assign_goto(ret, err, EXCP_BADARG_N(env, 2, "RSA key of wrong size"));
                 if (!enif_alloc_binary(tmplen, &tmp_bin))
-                    goto err;
+                    assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate binary"));
                 tmp_bin_alloc = 1;
                 if (in_bin.size > INT_MAX)
-                    goto err;
+                    assign_goto(ret, err, EXCP_BADARG_N(env, 1, "Binary too large"));
                 if (!RSA_padding_add_SSLv23(tmp_bin.data, (int)tmplen, in_bin.data, (int)in_bin.size))
-                    goto err;
+                    assign_goto(ret, err, EXCP_ERROR(env, "Couldn't RSA_padding_add_SSLv23"));
                 in_bin = tmp_bin;
             }
             if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_NO_PADDING) != 1)
-                goto err;
+                assign_goto(ret, err, EXCP_ERROR(env, "Couldn't set RSA_NO_PADDING"));
         } else
 # endif
-        {
             if (EVP_PKEY_CTX_set_rsa_padding(ctx, crypt_opt.rsa_padding) != 1)
-                goto err;
-        }
+                assign_goto(ret, err, EXCP_ERROR(env, "Couldn't set rsa padding"));
 
 # ifdef HAVE_RSA_OAEP_MD
         if (crypt_opt.rsa_padding == RSA_PKCS1_OAEP_PADDING) {
             if (crypt_opt.rsa_oaep_md != NULL) {
                 if (EVP_PKEY_CTX_set_rsa_oaep_md(ctx, crypt_opt.rsa_oaep_md) != 1)
-                    goto err;
+                    assign_goto(ret, err, EXCP_ERROR(env, "Couldn't EVP_PKEY_CTX_set_rsa_oaep_md"));
             }
 
             if (crypt_opt.rsa_mgf1_md != NULL) {
                 if (EVP_PKEY_CTX_set_rsa_mgf1_md(ctx, crypt_opt.rsa_mgf1_md) != 1)
-                    goto err;
+                    assign_goto(ret, err, EXCP_ERROR(env, "Couldn't EVP_PKEY_CTX_set_rsa_mgf1_md"));
             }
 
             if (crypt_opt.rsa_oaep_label.data != NULL && crypt_opt.rsa_oaep_label.size > 0) {
                 if (crypt_opt.rsa_oaep_label.size > INT_MAX)
-                    goto err;
+                    assign_goto(ret, err, EXCP_BADARG_N(env, 3, "RSA oep label too large"));
                 if ((label_copy = OPENSSL_malloc(crypt_opt.rsa_oaep_label.size)) == NULL)
                     goto err;
 
@@ -1104,7 +1142,7 @@ ERL_NIF_TERM pkey_crypt_nif(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
 
                 if (EVP_PKEY_CTX_set0_rsa_oaep_label(ctx, label_copy,
                                                      (int)crypt_opt.rsa_oaep_label.size) != 1)
-                    goto err;
+                    assign_goto(ret, err, EXCP_ERROR(env, "Couldn't set RSA oaep label"));
                 /* On success, label_copy is owned by ctx */
                 label_copy = NULL;
             }
@@ -1112,105 +1150,77 @@ ERL_NIF_TERM pkey_crypt_nif(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
 # endif
     }
 
-    if (is_private) {
-        if (is_encrypt) {
-            /* private_encrypt */
-            result = EVP_PKEY_sign(ctx, NULL, &outlen, in_bin.data, in_bin.size);
-        } else {
-            /* private_decrypt */
-            result = EVP_PKEY_decrypt(ctx, NULL, &outlen, in_bin.data, in_bin.size);
-        }
-    } else {
-        if (is_encrypt) {
-            /* public_encrypt */
-            result = EVP_PKEY_encrypt(ctx, NULL, &outlen, in_bin.data, in_bin.size);
-        } else {
-            /* public_decrypt */
-            result = EVP_PKEY_verify_recover(ctx, NULL, &outlen, in_bin.data, in_bin.size);
-        }
-    }
-
+    /* Get the size of the result */
+    if (is_private)
+        result =
+            is_encrypt ? EVP_PKEY_sign(ctx, NULL, &outlen, in_bin.data, in_bin.size)
+                       : EVP_PKEY_decrypt(ctx, NULL, &outlen, in_bin.data, in_bin.size);
+    else
+        result =
+            is_encrypt ? EVP_PKEY_encrypt(ctx, NULL, &outlen, in_bin.data, in_bin.size)
+                       : EVP_PKEY_verify_recover(ctx, NULL, &outlen, in_bin.data, in_bin.size);
+    
+    /* Check */
     if (result != 1)
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Couldn't get size of result"));
 
+    /* Allocate */
     if (!enif_alloc_binary(outlen, &out_bin))
-        goto err;
-    out_bin_alloc = 1;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate binary"));
 
-    if (is_private) {
-        if (is_encrypt) {
-            /* private_encrypt */
-            result = EVP_PKEY_sign(ctx, out_bin.data, &outlen, in_bin.data, in_bin.size);
-        } else {
-            /* private_decrypt */
-            result = EVP_PKEY_decrypt(ctx, out_bin.data, &outlen, in_bin.data, in_bin.size);
-        }
-    } else {
-        if (is_encrypt) {
-            /* public_encrypt */
-            result = EVP_PKEY_encrypt(ctx, out_bin.data, &outlen, in_bin.data, in_bin.size);
-        } else {
-            /* public_decrypt */
-            result = EVP_PKEY_verify_recover(ctx, out_bin.data, &outlen, in_bin.data, in_bin.size);
-        }
-    }
+    out_bin_alloc = 1; /* Flag de-allocation */
+
+    /* Get the result into the newly allocated binary */
+    if (is_private)
+        result =
+            is_encrypt ? EVP_PKEY_sign(ctx, out_bin.data, &outlen, in_bin.data, in_bin.size)
+                       : EVP_PKEY_decrypt(ctx, out_bin.data, &outlen, in_bin.data, in_bin.size);
+    else
+        result=
+            is_encrypt ? EVP_PKEY_encrypt(ctx, out_bin.data, &outlen, in_bin.data, in_bin.size)
+                       : EVP_PKEY_verify_recover(ctx, out_bin.data, &outlen, in_bin.data, in_bin.size);
+
+    if (result != 1)
+        assign_goto(ret, err, EXCP_ERROR(env, "Couldn't get the result"));
 
 #else
-    /* Non-EVP cryptolib. Only support RSA */
+    /* Non-EVP cryptolib. Only supports RSA */
 
-    if (argv[0] != atom_rsa) {
-        algo_init = -2;         /* exitcode: notsup */
-        goto bad_arg;
-    }
+    if (argv[0] != atom_rsa)
+        assign_goto(ret, err, EXCP_NOTSUP_N(env, 0, "Only RSA is supported"));
 
     if ((rsa = EVP_PKEY_get1_RSA(pkey)) == NULL)
-        goto err;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 2, "Not RSA key"));
     if ((len = RSA_size(rsa)) < 0)
-        goto err;
+        assign_goto(ret, err, EXCP_BADARG_N(env, 3, "Bad RSA key length"));
     if (!enif_alloc_binary((size_t)len, &out_bin))
-        goto err;
+        assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate binary"));
     out_bin_alloc = 1;
 
     if (in_bin.size > INT_MAX)
-        goto err;
-    if (is_private) {
-        if (is_encrypt) {
-            /* non-evp rsa private encrypt */
-            ERL_VALGRIND_ASSERT_MEM_DEFINED(in_bin.data,in_bin.size);
-            result = RSA_private_encrypt((int)in_bin.size, in_bin.data,
-                                    out_bin.data, rsa, crypt_opt.rsa_padding);
-            if (result > 0) {
-                ERL_VALGRIND_MAKE_MEM_DEFINED(out_bin.data, result);
-            }
-        } else {
-            /* non-evp rsa private decrypt */
-            result = RSA_private_decrypt((int)in_bin.size, in_bin.data,
-                                    out_bin.data, rsa, crypt_opt.rsa_padding);
-            if (result > 0) {
-                ERL_VALGRIND_MAKE_MEM_DEFINED(out_bin.data, result);
-                if (!enif_realloc_binary(&out_bin, (size_t)result))
-                    goto err;
-            }
-        }
-    } else {
-        if (is_encrypt) {
-            /* non-evp rsa public encrypt */
-            ERL_VALGRIND_ASSERT_MEM_DEFINED(in_bin.data,in_bin.size);
-            result = RSA_public_encrypt((int)in_bin.size, in_bin.data,
-                                   out_bin.data, rsa, crypt_opt.rsa_padding);
-            if (result > 0) {
-                ERL_VALGRIND_MAKE_MEM_DEFINED(out_bin.data, result);
-            }
-        } else {
-            /* non-evp rsa public decrypt */
-            result = RSA_public_decrypt((int)in_bin.size, in_bin.data,
-                                   out_bin.data, rsa, crypt_opt.rsa_padding);
-            if (result > 0) {
-                ERL_VALGRIND_MAKE_MEM_DEFINED(out_bin.data, result);
-                if (!enif_realloc_binary(&out_bin, (size_t)result))
-                    goto err;
-            }
-        }
+        assign_goto(ret, err, EXCP_BADARG_N(env, 1, "Bad indata length"));
+    
+    if (is_encrypt) {
+        ERL_VALGRIND_ASSERT_MEM_DEFINED(in_bin.data,in_bin.size);
+    }
+
+    if (is_private)
+        result =
+            is_encrypt ? RSA_private_encrypt((int)in_bin.size, in_bin.data,
+                                             out_bin.data, rsa, crypt_opt.rsa_padding)
+                       : RSA_private_decrypt((int)in_bin.size, in_bin.data,
+                                             out_bin.data, rsa, crypt_opt.rsa_padding);
+    else
+        result =
+            is_encrypt ? RSA_public_encrypt((int)in_bin.size, in_bin.data,
+                                            out_bin.data, rsa, crypt_opt.rsa_padding)
+                       : RSA_public_decrypt((int)in_bin.size, in_bin.data,
+                                            out_bin.data, rsa, crypt_opt.rsa_padding);
+    if (result > 0) {
+        ERL_VALGRIND_MAKE_MEM_DEFINED(out_bin.data, result);
+        if (!is_encrypt &&
+            !enif_realloc_binary(&out_bin, (size_t)result))
+            assign_goto(ret, err, EXCP_ERROR(env, "Can't re-allocate binary"));
     }
 
     outlen = (size_t)result;
@@ -1223,12 +1233,12 @@ ERL_NIF_TERM pkey_crypt_nif(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
 
             tmplen = size_of_RSA(pkey);
             if (tmplen < 1 || tmplen > INT_MAX)
-                goto err;
+                assign_goto(ret, err, EXCP_BADARG_N(env, 2, "RSA key of wrong size"));
             if (!enif_alloc_binary(tmplen, &tmp_bin))
-                goto err;
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't allocate binary"));
             tmp_bin_alloc = 1;
             if (out_bin.size > INT_MAX)
-                goto err;
+                assign_goto(ret, err, EXCP_ERROR(env, "Result too large"));
 
             p = out_bin.data;
             p++;
@@ -1249,28 +1259,16 @@ ERL_NIF_TERM pkey_crypt_nif(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
         ERL_VALGRIND_MAKE_MEM_DEFINED(out_bin.data, outlen);
         if (outlen != out_bin.size) {
             if (!enif_realloc_binary(&out_bin, outlen))
-                goto err;
+                assign_goto(ret, err, EXCP_ERROR(env, "Can't re-allocate binary"));
             ERL_VALGRIND_ASSERT_MEM_DEFINED(out_bin.data, outlen);
         }
         ret = enif_make_binary(env, &out_bin);
         out_bin_alloc = 0;
     } else {
-        ret = atom_error;
+        assign_goto(ret, err, EXCP_ERROR(env, "RSA encrypt/decrypt failed"));
     }
-    goto done;
-
- notsup:
-    ret = atom_notsup;
-    goto done;
 
- bad_arg:
  err:
-    if (algo_init == -2)
-        ret = atom_notsup;
-    else
-        ret = enif_make_badarg(env);
-
- done:
     if (out_bin_alloc)
         enif_release_binary(&out_bin);
     if (tmp_bin_alloc)
@@ -1290,7 +1288,7 @@ ERL_NIF_TERM pkey_crypt_nif(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
         OPENSSL_free(label_copy);
 
     return ret;
-}
+    }
 
 ERL_NIF_TERM privkey_to_pubkey_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 { /* (Algorithm, PrivKey | KeyMap) */
@@ -1299,17 +1297,20 @@ ERL_NIF_TERM privkey_to_pubkey_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM
 
     ASSERT(argc == 2);
 
-    if (get_pkey_private_key(env, argv[0], argv[1], &pkey) != PKEY_OK) // handles engine
-        goto bad_arg;
+    if (!check_pkey_algorithm_type(env, 0, argv[0], &ret))
+        goto err; /* An exception is present in ret */
+    
+    if (!get_pkey_private_key(env, argv, 0, 1, &pkey, &ret)) // handles engine
+        goto err; /* An exception is present in ret */
 
     if (argv[0] == atom_rsa) {
         if (!rsa_privkey_to_pubkey(env, pkey, &ret))
-            goto err;
+            assign_goto(ret, err, EXCP_BADARG_N(env, 1, "Couldn't get RSA public key from private key"));
 
 #ifdef HAVE_DSA
     } else if (argv[0] == atom_dss) {
         if (!dss_privkey_to_pubkey(env, pkey, &ret))
-            goto err;
+            assign_goto(ret, err, EXCP_BADARG_N(env, 1, "Couldn't get DSA public key from private key"));
 #endif
     } else if (argv[0] == atom_ecdsa) {
 #if defined(HAVE_EC)
@@ -1346,18 +1347,12 @@ ERL_NIF_TERM privkey_to_pubkey_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM
             return enif_make_list_from_array(env, ..., ...);
         */
 #endif
-        goto bad_arg;
+        assign_goto(ret, err, EXCP_NOTSUP_N(env, 0, "ECDSA not implemented"));
     } else {
-        goto bad_arg;
+        ret = EXCP_BADARG_N(env, 0, "Bad algorithm");
     }
 
-    goto done;
-
- bad_arg:
  err:
-    ret = enif_make_badarg(env);
-
- done:
     if (pkey)
         EVP_PKEY_free(pkey);
 
diff --git a/lib/crypto/c_src/rand.c b/lib/crypto/c_src/rand.c
index 82bf2c7467..cc34f0afc7 100644
--- a/lib/crypto/c_src/rand.c
+++ b/lib/crypto/c_src/rand.c
@@ -1,7 +1,7 @@
 /*
  * %CopyrightBegin%
  *
- * Copyright Ericsson AB 2010-2020. All Rights Reserved.
+ * Copyright Ericsson AB 2010-2022. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -101,7 +101,11 @@ ERL_NIF_TERM rand_uniform_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[
 
     if (!BN_sub(bn_to, bn_rand, bn_from))
         goto err;
+#ifdef HAS_3_0_API
+    if (!BN_rand_range(bn_rand, bn_to))
+#else
     if (!BN_pseudo_rand_range(bn_rand, bn_to))
+#endif
         goto err;
     if (!BN_add(bn_rand, bn_rand, bn_from))
         goto err;
diff --git a/lib/crypto/c_src/rsa.c b/lib/crypto/c_src/rsa.c
index 5ee389467d..0a543fe6e5 100644
--- a/lib/crypto/c_src/rsa.c
+++ b/lib/crypto/c_src/rsa.c
@@ -21,16 +21,93 @@
 #include "rsa.h"
 #include "bn.h"
 
-//#define(CHK_RSA_3_0)
-
 static ERL_NIF_TERM rsa_generate_key(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);
-#if !defined(HAS_3_0_API) || defined(CHK_RSA_3_0)
+#if !defined(HAS_3_0_API)
 static ERL_NIF_TERM put_rsa_private_key(ErlNifEnv* env, const RSA *rsa);
 #endif
 #if !defined(HAS_3_0_API)
 static int check_erlang_interrupt(int maj, int min, BN_GENCB *ctxt);
 #endif
 
+#define PUT1(env,bn,t) \
+    if (bn) {if ((t = bin_from_bn(env, bn)) == atom_error) goto err;}   \
+    else t = atom_undefined
+    
+
+// ERL_NIF_TERM debug_put_pkey(ErlNifEnv* env, EVP_PKEY *pkey);
+// ERL_NIF_TERM debug_put_pkey(ErlNifEnv* env, EVP_PKEY *pkey)
+// {
+//     const BIGNUM *e1 = NULL, *n1 = NULL, *d1 = NULL;
+//     RSA *rsa = NULL;
+//     ERL_NIF_TERM result[3];
+// 
+//     rsa = EVP_PKEY_get1_RSA(pkey);
+//     RSA_get0_key(rsa, &n1, &e1, &d1);
+// 
+//     PUT1(env, e1, result[0]);  // Exponent E
+//     PUT1(env, n1, result[1]);  // Modulus N = p*q
+//     PUT1(env, d1, result[2]);
+//         
+//     return enif_make_list_from_array(env,result,3);
+// 
+//  err:
+//     return atom_error;
+// }
+
+
+#if !defined(HAS_3_0_API)
+/* Creates a term which can be parsed by get_rsa_private_key(). This is a list of plain integer binaries (not mpints). */
+static ERL_NIF_TERM put_rsa_private_key(ErlNifEnv* env, const RSA *rsa)
+{
+    ERL_NIF_TERM result[8];
+    const BIGNUM *n = NULL, *e = NULL, *d = NULL, *p = NULL, *q = NULL, *dmp1 = NULL, *dmq1 = NULL, *iqmp = NULL;
+
+    /* Return at least [E,N,D] */
+    RSA_get0_key(rsa, &n, &e, &d);
+
+    if ((result[0] = bin_from_bn(env, e)) == atom_error)  // Exponent E
+        goto err;
+    if ((result[1] = bin_from_bn(env, n)) == atom_error)  // Modulus N = p*q
+        goto err;
+    if ((result[2] = bin_from_bn(env, d)) == atom_error)  // Exponent D
+        goto err;
+
+    /* Check whether the optional additional parameters are available */
+    RSA_get0_factors(rsa, &p, &q);
+    RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);
+
+    if (p && q && dmp1 && dmq1 && iqmp) {
+        if ((result[3] = bin_from_bn(env, p)) == atom_error)     // Factor p
+            goto err;
+        if ((result[4] = bin_from_bn(env, q)) == atom_error)     // Factor q
+            goto err;
+        if ((result[5] = bin_from_bn(env, dmp1)) == atom_error)  // D mod (p-1)
+            goto err;
+        if ((result[6] = bin_from_bn(env, dmq1)) == atom_error)  // D mod (q-1)
+            goto err;
+        if ((result[7] = bin_from_bn(env, iqmp)) == atom_error)  // (1/q) mod p
+            goto err;
+
+	return enif_make_list_from_array(env, result, 8);
+    } else {
+	return enif_make_list_from_array(env, result, 3);
+    }
+
+ err:
+    return enif_make_badarg(env);
+}
+
+static int check_erlang_interrupt(int maj, int min, BN_GENCB *ctxt)
+{
+    ErlNifEnv *env = BN_GENCB_get_arg(ctxt);
+
+    if (!enif_is_current_process_alive(env)) {
+	return 0;
+    } else {
+	return 1;
+    }
+}
+
 int get_rsa_private_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
 {
     /* key=[E,N,D]|[E,N,D,P1,P2,E1,E2,C] */
@@ -56,6 +133,7 @@ int get_rsa_private_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
     if ((rsa = RSA_new()) == NULL)
         goto err;
 
+    *pkey = EVP_PKEY_new();
     if (!RSA_set0_key(rsa, n, e, d))
         goto err;
     /* rsa now owns n, e, and d */
@@ -135,6 +213,7 @@ int get_rsa_private_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
     return 0;
 }
 
+
 int get_rsa_public_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
 {
     /* key=[E,N] */
@@ -162,9 +241,11 @@ int get_rsa_public_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
     n = NULL;
     e = NULL;
 
+    *pkey = EVP_PKEY_new();
     if (EVP_PKEY_assign_RSA(*pkey, rsa) != 1)
         goto err;
 
+    // enif_fprintf(stderr, "pkey = %T\r\n", debug_put_pkey(env,*pkey));
     return 1;
 
  bad_arg:
@@ -179,63 +260,6 @@ int get_rsa_public_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
     return 0;
 }
 
-#if !defined(HAS_3_0_API) || defined(CHK_RSA_3_0)
-/* Creates a term which can be parsed by get_rsa_private_key(). This is a list of plain integer binaries (not mpints). */
-static ERL_NIF_TERM put_rsa_private_key(ErlNifEnv* env, const RSA *rsa)
-{
-    ERL_NIF_TERM result[8];
-    const BIGNUM *n = NULL, *e = NULL, *d = NULL, *p = NULL, *q = NULL, *dmp1 = NULL, *dmq1 = NULL, *iqmp = NULL;
-
-    /* Return at least [E,N,D] */
-    RSA_get0_key(rsa, &n, &e, &d);
-
-    if ((result[0] = bin_from_bn(env, e)) == atom_error)  // Exponent E
-        goto err;
-    if ((result[1] = bin_from_bn(env, n)) == atom_error)  // Modulus N = p*q
-        goto err;
-    if ((result[2] = bin_from_bn(env, d)) == atom_error)  // Exponent D
-        goto err;
-
-    /* Check whether the optional additional parameters are available */
-    RSA_get0_factors(rsa, &p, &q);
-    RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);
-
-    if (p && q && dmp1 && dmq1 && iqmp) {
-        if ((result[3] = bin_from_bn(env, p)) == atom_error)     // Factor p
-            goto err;
-        if ((result[4] = bin_from_bn(env, q)) == atom_error)     // Factor q
-            goto err;
-        if ((result[5] = bin_from_bn(env, dmp1)) == atom_error)  // D mod (p-1)
-            goto err;
-        if ((result[6] = bin_from_bn(env, dmq1)) == atom_error)  // D mod (q-1)
-            goto err;
-        if ((result[7] = bin_from_bn(env, iqmp)) == atom_error)  // (1/q) mod p
-            goto err;
-
-	return enif_make_list_from_array(env, result, 8);
-    } else {
-	return enif_make_list_from_array(env, result, 3);
-    }
-
- err:
-    return enif_make_badarg(env);
-}
-#endif
-
-#if !defined(HAS_3_0_API)
-/* Legacy API deprecated from 3.0 is used */
-
-static int check_erlang_interrupt(int maj, int min, BN_GENCB *ctxt)
-{
-    ErlNifEnv *env = BN_GENCB_get_arg(ctxt);
-
-    if (!enif_is_current_process_alive(env)) {
-	return 0;
-    } else {
-	return 1;
-    }
-}
-
 static ERL_NIF_TERM rsa_generate_key(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 {/* (ModulusSize, PublicExponent) */
     ERL_NIF_TERM ret;
@@ -303,9 +327,127 @@ static ERL_NIF_TERM rsa_generate_key(ErlNifEnv* env, int argc, const ERL_NIF_TER
     return ret;
 }
 
+int rsa_privkey_to_pubkey(ErlNifEnv* env,  EVP_PKEY *pkey, ERL_NIF_TERM *ret)
+{
+    const BIGNUM *n = NULL, *e = NULL, *d = NULL;
+    ERL_NIF_TERM result[2];
+    RSA *rsa = NULL;
+
+    if ((rsa = EVP_PKEY_get1_RSA(pkey)) == NULL)
+        goto err;
+
+    RSA_get0_key(rsa, &n, &e, &d);
+
+    // Exponent E
+    if ((result[0] = bin_from_bn(env, e)) == atom_error)
+        goto err;
+    // Modulus N = p*q
+    if ((result[1] = bin_from_bn(env, n)) == atom_error)
+        goto err;
+
+    *ret = enif_make_list_from_array(env, result, 2);
+    RSA_free(rsa);
+    return 1;
+
+ err:
+    if (rsa)
+        RSA_free(rsa);
+    return 0;
+}
+
+
 #else
 /* New 3.0 API is used */
 
+int get_rsa_private_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
+{
+    /* key=[E,N,D]|[E,N,D,P1,P2,E1,E2,C] */
+    ERL_NIF_TERM head, tail;
+    OSSL_PARAM params[9];
+    EVP_PKEY_CTX *ctx = NULL;
+    int i = 0;
+
+    head = key;
+
+    if (!get_ossl_param_from_bin_in_list(env, "e", &head, &params[i++]) || // Exponent E
+        !get_ossl_param_from_bin_in_list(env, "n", &head, &params[i++]) ||  // N = p*q
+        !get_ossl_param_from_bin_in_list(env, "d", &head, &params[i++]))  // Exponent D
+        goto bad_arg;
+    
+    tail = head;
+    
+    if (!enif_is_empty_list(env, tail)) {
+        if (!get_ossl_param_from_bin_in_list(env, "rsa-factor1", &head, &params[i++]) || // p, Factor p
+            !get_ossl_param_from_bin_in_list(env, "rsa-factor2", &head, &params[i++]) || // q, Factor q
+            !get_ossl_param_from_bin_in_list(env, "rsa-exponent1", &head, &params[i++]) || // dmp1, D mod (p-1)
+            !get_ossl_param_from_bin_in_list(env, "rsa-exponent2", &head, &params[i++]) || // dmq1, D mod (q-1)
+            !get_ossl_param_from_bin_in_list(env, "rsa-coefficient1", &head, &params[i++]) ) // iqmp, (1/q) mod p
+            goto bad_arg;
+
+        tail = head;
+    
+        if (!enif_is_empty_list(env, tail))
+            goto bad_arg;
+    }
+
+    params[i++] = OSSL_PARAM_construct_end();
+
+    if ((ctx = EVP_PKEY_CTX_new_from_name(NULL, "RSA", NULL)) == NULL)
+        goto err;
+    if (EVP_PKEY_fromdata_init(ctx) <= 0)
+        goto err;
+    if (EVP_PKEY_fromdata(ctx, pkey, EVP_PKEY_KEYPAIR, params) <= 0)
+        goto bad_arg;
+
+    if (ctx) EVP_PKEY_CTX_free(ctx);
+    return 1;
+
+ bad_arg:
+ err:
+    if (ctx) EVP_PKEY_CTX_free(ctx);
+    return 0;
+}
+
+
+int get_rsa_public_key(ErlNifEnv* env, ERL_NIF_TERM key, EVP_PKEY **pkey)
+{
+    ERL_NIF_TERM head, tail;
+    OSSL_PARAM params[3];
+    EVP_PKEY_CTX *ctx = NULL;
+
+    head = key;
+    if (!get_ossl_param_from_bin_in_list(env, "e", &head, &params[0]) )
+        goto bad_arg;
+    
+    if (!get_ossl_param_from_bin_in_list(env, "n", &head, &params[1]) )
+        goto bad_arg;
+    
+    tail = head;
+    if (!enif_is_empty_list(env, tail))
+        goto bad_arg;
+
+    params[2] = OSSL_PARAM_construct_end();
+
+    if ((ctx = EVP_PKEY_CTX_new_from_name(NULL, "RSA", NULL)) == NULL)
+        goto err;
+    if (EVP_PKEY_fromdata_init(ctx) <= 0)
+        goto err;
+    if (EVP_PKEY_fromdata(ctx, pkey, EVP_PKEY_PUBLIC_KEY, params) <= 0)
+        goto bad_arg;
+
+    /* enif_fprintf(stderr, "pkey = %T\r\nn = %T\r\n", */
+    /*              debug_put_pkey(env,*pkey), */
+    /*              enif_make_binary(env,&tmp) */
+    /*              ); */
+    if (ctx) EVP_PKEY_CTX_free(ctx);
+    return 1;
+
+ bad_arg:
+ err:
+    if (ctx) EVP_PKEY_CTX_free(ctx);
+    return 0;
+}
+
 static ERL_NIF_TERM rsa_generate_key(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 {/* (ModulusSize, PublicExponent/binary, PublicExponent) */
     ERL_NIF_TERM ret;
@@ -378,58 +520,56 @@ static ERL_NIF_TERM rsa_generate_key(ErlNifEnv* env, int argc, const ERL_NIF_TER
             || ((result[7] = bin_from_bn(env, iqmp)) == atom_error)
             ) {
             ret = EXCP_ERROR(env, "Can't get RSA keys");
-            goto ret;
+            goto local_ret;
         }
-
         ret =  enif_make_list_from_array(env, result, 8);
-
-#ifdef CHK_RSA_3_0
-        {RSA *rsa = EVP_PKEY_get1_RSA(pkey);
-            if (!rsa)
-                ret = enif_make_tuple2(env, ret, atom_error);
-            else
-                ret = enif_make_tuple2(env, ret, put_rsa_private_key(env,rsa));
-        }
-#endif
+    local_ret:
+        if (e) BN_free(e);
+        if (n) BN_free(n);
+        if (d) BN_free(d);
+        if (p) BN_free(p);
+        if (q) BN_free(q);
+        if (dmp1) BN_free(dmp1);
+        if (dmq1) BN_free(dmq1);
+        if (iqmp) BN_free(iqmp);
     }
 
  ret:
+    if (pkey) EVP_PKEY_free(pkey);
     if (pctx) EVP_PKEY_CTX_free(pctx);
     return ret;
 }
 
-#endif /* #else-part of #if !defined(HAS_3_0_API) */
-
-
 int rsa_privkey_to_pubkey(ErlNifEnv* env,  EVP_PKEY *pkey, ERL_NIF_TERM *ret)
 {
-    const BIGNUM *n = NULL, *e = NULL, *d = NULL;
+    BIGNUM *e = NULL, *n = NULL;
     ERL_NIF_TERM result[2];
-    RSA *rsa = NULL;
-    
-    if ((rsa = EVP_PKEY_get1_RSA(pkey)) == NULL)
-        goto err;
-
-    RSA_get0_key(rsa, &n, &e, &d);
 
-    // Exponent E
-    if ((result[0] = bin_from_bn(env, e)) == atom_error)
-        goto err;
-    // Modulus N = p*q
-    if ((result[1] = bin_from_bn(env, n)) == atom_error)
+    /* https://www.openssl.org/docs/man3.0/man7/EVP_PKEY-RSA.html */
+    if (
+        !EVP_PKEY_get_bn_param(pkey, "e", &e)                       // Exponent E
+        || !EVP_PKEY_get_bn_param(pkey, "n", &n)                    // Modulus N = p*q
+        || ((result[0] = bin_from_bn(env, e)) == atom_error)
+        || ((result[1] = bin_from_bn(env, n)) == atom_error)
+        )
         goto err;
 
-    *ret = enif_make_list_from_array(env, result, 2);
-    RSA_free(rsa);
+    *ret =  enif_make_list_from_array(env, result, 2);
+    if (e) BN_free(e);
+    if (n) BN_free(n);
     return 1;
 
  err:
-    if (rsa)
-        RSA_free(rsa);
+    if (e) BN_free(e);
+    if (n) BN_free(n);
     return 0;
+
 }
 
 
+#endif /* #else-part of #if !defined(HAS_3_0_API)   (That is, end of defined(HAS_3_0_API)) */
+
+
 ERL_NIF_TERM rsa_generate_key_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
 {
     /* RSA key generation can take a long time (>1 sec for a large
diff --git a/lib/crypto/configure b/lib/crypto/configure
index 1def565a..14bda337 100755
--- a/lib/crypto/configure
+++ b/lib/crypto/configure
@@ -621,6 +621,7 @@ ac_includes_default="\
 
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
+CRYPTO_NO_DEPRECATE_WARN
 DISABLE_OTP_TEST_ENGINE
 DISABLE_EVP_HMAC
 DISABLE_EVP_DH
@@ -749,7 +750,6 @@ enable_dynamic_ssl_lib
 enable_evp_dh
 enable_evp_hmac
 enable_otp_test_engine
-enable_deprecated_warnings
 enable_fips
 '
       ac_precious_vars='build_alias
@@ -1426,10 +1426,6 @@ Optional Features:
                           Disable build of the otp_test_engine. (default is
                           --enable-otp-test-engine, unless for LibreSSL >=
                           3.5.0 where default is --disable-otp-test-engine)
-  --disable-deprecated-warnings
-                          disable warnings for deprecated functions in
-                          cryptolib (default is to warn, except for OpenSSL
-                          3.x where the default is not to warn)
   --enable-fips           enable OpenSSL FIPS mode support
   --disable-fips          disable OpenSSL FIPS mode support (default)
 
@@ -5024,7 +5020,21 @@ _ACEOF
 
 
 
-std_ssl_locations="/usr/local /usr/sfw /usr /opt/local /usr/pkg /usr/local/openssl /usr/local/opt/openssl /usr/lib/openssl /usr/openssl /usr/local/ssl /usr/lib/ssl /usr/ssl /"
+std_ssl_locations="\
+/usr/local \
+/usr/sfw \
+/usr \
+/opt/local \
+/usr/pkg \
+/usr/local/openssl \
+/usr/local/opt/openssl \
+/opt/homebrew/opt/openssl \
+/usr/lib/openssl \
+/usr/openssl \
+/usr/local/ssl \
+/usr/lib/ssl \
+/usr/ssl \
+/"
 
 
 # Check whether --with-ssl was given.
@@ -5132,17 +5142,6 @@ else
 fi
 
 
-# Check whether --enable-deprecated_warnings was given.
-if test "${enable_deprecated_warnings+set}" = set; then :
-  enableval=$enable_deprecated_warnings;  case "$enableval" in
-    no)   deprecated_warnings=no;;
-    *)    deprecated_warnings=yes;;
-  esac
-else
-  deprecated_warnings=default_yes
-fi
-
-
 
 
 
@@ -6398,11 +6397,6 @@ else
 fi
 
 if test "x$v3_include" = "xyes"; then
-   echo "Using OpenSSL 3.0 is not yet recommended for production code." >> ./CONF_INFO
-   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: ******************************************************************" >&5
-$as_echo "$as_me: WARNING: ******************************************************************" >&2;}
-   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: * Using OpenSSL 3.0 is not yet recommended for production code.  *" >&5
-$as_echo "$as_me: WARNING: * Using OpenSSL 3.0 is not yet recommended for production code.  *" >&2;}
 
    if test "x$SSL_DYNAMIC_ONLY" = "xno" ; then
       echo "Static linking with OpenSSL 3.0 *MAY* require special configuring of the cryptolib." >> ./CONF_INFO
@@ -6413,13 +6407,11 @@ $as_echo "$as_me: WARNING: * Static linking *MAY* require re-configuring the 3.0
 $as_echo "$as_me: WARNING: ******************************************************************" >&2;}
 fi
 
-if test "x$v3_include" = "xyes" && test "x$deprecated_warnings" = "xdefault_yes" && test "$CRYPTO_APP" != ""; then
-   deprecated_warnings=no
+CRYPTO_NO_DEPRECATE_WARN=
+if test "x$v3_include" = "xyes" && test "$CRYPTO_APP" != ""; then
+   CRYPTO_NO_DEPRECATE_WARN="-Wno-deprecated-declarations"
 fi
 
-if test "x$deprecated_warnings" = "xno"  &&  test "$CRYPTO_APP" != "" ; then
-   SSL_FLAGS="$SSL_FLAGS -Wno-deprecated-declarations"
-fi
 
 
 
diff --git a/lib/crypto/configure.in b/lib/crypto/configure.in
index 30575677..187f8bd9 100644
--- a/lib/crypto/configure.in
+++ b/lib/crypto/configure.in
@@ -82,7 +82,21 @@ dnl use "PATH/include" and "PATH/lib".
 
 AC_CHECK_SIZEOF(void *)
 
-std_ssl_locations="/usr/local /usr/sfw /usr /opt/local /usr/pkg /usr/local/openssl /usr/local/opt/openssl /usr/lib/openssl /usr/openssl /usr/local/ssl /usr/lib/ssl /usr/ssl /"
+std_ssl_locations="\
+/usr/local \
+/usr/sfw \
+/usr \
+/opt/local \
+/usr/pkg \
+/usr/local/openssl \
+/usr/local/opt/openssl \
+/opt/homebrew/opt/openssl \
+/usr/lib/openssl \
+/usr/openssl \
+/usr/local/ssl \
+/usr/lib/ssl \
+/usr/ssl \
+/"
 			
 AC_ARG_WITH(ssl,
 AS_HELP_STRING([--with-ssl=PATH], [base location of OpenSSL include and lib directories])
@@ -170,14 +184,6 @@ AS_HELP_STRING([--disable-otp-test-engine],
     *)    DISABLE_OTP_TEST_ENGINE=no;;
   esac ], DISABLE_OTP_TEST_ENGINE=default)
 
-AC_ARG_ENABLE(deprecated_warnings,
-AS_HELP_STRING([--disable-deprecated-warnings],
-	       [disable warnings for deprecated functions in cryptolib (default is to warn, except for OpenSSL 3.x where the default is not to warn)]),
-[ case "$enableval" in
-    no)   deprecated_warnings=no;;
-    *)    deprecated_warnings=yes;;
-  esac ], deprecated_warnings=default_yes)
-
 AC_DEFUN([ERL_LINK_CRYPTO_IFELSE], [
     test_cflags=$1
     test_ldflags=$2
@@ -838,9 +844,6 @@
 fi
 
 if test "x$v3_include" = "xyes"; then
-   echo "Using OpenSSL 3.0 is not yet recommended for production code." >> ./CONF_INFO
-   AC_MSG_WARN(******************************************************************)
-   AC_MSG_WARN(* Using OpenSSL 3.0 is not yet recommended for production code.  *)
 
    if test "x$SSL_DYNAMIC_ONLY" = "xno" ; then
       echo "Static linking with OpenSSL 3.0 *MAY* require special configuring of the cryptolib." >> ./CONF_INFO
@@ -849,12 +852,9 @@ if test "x$v3_include" = "xyes"; then
    AC_MSG_WARN(******************************************************************)
 fi
 
-if test "x$v3_include" = "xyes" && test "x$deprecated_warnings" = "xdefault_yes" && test "$CRYPTO_APP" != ""; then
-   deprecated_warnings=no
-fi
-
-if test "x$deprecated_warnings" = "xno"  &&  test "$CRYPTO_APP" != "" ; then
-   SSL_FLAGS="$SSL_FLAGS -Wno-deprecated-declarations"
+CRYPTO_NO_DEPRECATE_WARN=
+if test "x$v3_include" = "xyes" && test "$CRYPTO_APP" != ""; then
+   CRYPTO_NO_DEPRECATE_WARN="-Wno-deprecated-declarations"
 fi
 
 AC_SUBST(SSL_INCLUDE)
@@ -869,6 +869,7 @@ AC_SUBST(SSL_DYNAMIC_ONLY)
 AC_SUBST(DISABLE_EVP_DH)
 AC_SUBST(DISABLE_EVP_HMAC)
 AC_SUBST(DISABLE_OTP_TEST_ENGINE)
+AC_SUBST(CRYPTO_NO_DEPRECATE_WARN)
 
 AC_OUTPUT(c_src/$host/Makefile:c_src/Makefile.in)
 
diff --git a/lib/crypto/doc/src/algorithm_details.xml b/lib/crypto/doc/src/algorithm_details.xml
index dce04a1409..767fa3cd6f 100644
--- a/lib/crypto/doc/src/algorithm_details.xml
+++ b/lib/crypto/doc/src/algorithm_details.xml
@@ -4,7 +4,7 @@
 <chapter>
   <header>
     <copyright>
-      <year>2014</year><year>2021</year>
+      <year>2014</year><year>2022</year>
       <holder>Ericsson AB. All Rights Reserved.</holder>
     </copyright>
     <legalnotice>
@@ -111,6 +111,9 @@
 	<row><cell><c>aes_128_ctr</c></cell>   <cell>16</cell>      <cell>16</cell>      <cell>&nbsp;1</cell> <cell></cell></row>
 	<row><cell><c>aes_192_ctr</c></cell>   <cell>24</cell>      <cell>16</cell>      <cell>&nbsp;1</cell> <cell></cell></row>
 	<row><cell><c>aes_256_ctr</c></cell>   <cell>32</cell>      <cell>16</cell>      <cell>&nbsp;1</cell> <cell></cell></row>
+	<row><cell><c>aes_128_ofb</c></cell>   <cell>16</cell>      <cell>16</cell>      <cell>&nbsp;1</cell> <cell></cell></row>
+	<row><cell><c>aes_192_ofb</c></cell>   <cell>24</cell>      <cell>16</cell>      <cell>&nbsp;1</cell> <cell></cell></row>
+	<row><cell><c>aes_256_ofb</c></cell>   <cell>32</cell>      <cell>16</cell>      <cell>&nbsp;1</cell> <cell></cell></row>
 	<row><cell><c>blowfish_cbc</c></cell>  <cell>16</cell>      <cell>&nbsp;8</cell> <cell>&nbsp;8</cell> <cell></cell></row>
 	<row><cell><c>blowfish_cfb64</c></cell><cell>16</cell>      <cell>&nbsp;8</cell> <cell>&nbsp;1</cell> <cell></cell></row>
 	<row><cell><c>blowfish_ofb64</c></cell><cell>16</cell>      <cell>&nbsp;8</cell> <cell>&nbsp;1</cell> <cell></cell></row>
diff --git a/lib/crypto/doc/src/crypto.xml b/lib/crypto/doc/src/crypto.xml
index bcb37b12af..0d0ba07d8f 100644
--- a/lib/crypto/doc/src/crypto.xml
+++ b/lib/crypto/doc/src/crypto.xml
@@ -184,11 +184,6 @@
       </p>
     </note>
 
-    <note><p>Compiling, linking and running with OpenSSL 3.0 works although the
-    crypto app calls deprecated functions. We do not recommend it for other than
-    experimental purposes or alpha testing, since it is not extensively tested yet.</p>
-    </note>
-
     <p>The <seeguide marker="index">CRYPTO User's Guide</seeguide> has more information on
     FIPS, Engines and Algorithm Details like key lengths.
     </p>
@@ -547,72 +542,67 @@
       </desc>
     </datatype>
 
-    <datatype_title>Error types</datatype_title>
+  </datatypes>
 
-    <datatype>
-      <name name="run_time_error"/>
-      <desc>
-	<p>The exception <c>error:badarg</c> signifies that one or more arguments are of wrong data type,
-	or are otherwise badly formed.
-	</p>
-	<p>The exception <c>error:notsup</c> signifies that the algorithm is known but is not supported
-	by current underlying libcrypto or explicitly disabled when building that.
-	</p>
-	<p>For a list of supported algorithms, see <seemfa marker="#supports/1">supports(ciphers)</seemfa>.
-	</p>
-      </desc>
-    </datatype>
 
-    <datatype>
-      <name name="descriptive_error"/>
-      <desc>
-	<p>This is a more developed variant of the older
-	<seetype marker="#run_time_error">run_time_error()</seetype>.
-	</p>
-	<p>The exception is:</p>
-	<pre>
-	  {Tag, {C_FileName,LineNumber}, Description}
+  <section>
+    <title>Exceptions</title>
+    <section>
+      <title>Atoms - the older style</title>
+      <marker id="error_old"/>
+      <p>The exception <c>error:badarg</c> signifies that one or more arguments are of wrong data type,
+      or are otherwise badly formed.
+      </p>
+      <p>The exception <c>error:notsup</c> signifies that the algorithm is known but is not supported
+      by current underlying libcrypto or explicitly disabled when building that.
+      </p>
+      <p>For a list of supported algorithms, see <seemfa marker="#supports/1">supports(ciphers)</seemfa>.
+      </p>
+    </section>
 
-	   Tag = badarg | notsup | error
-	   C_FileName = string()
-	   LineNumber = integer()
-	   Description = string()
-	</pre>
+    <section>
+      <title>3-tuples - the new style</title>
+      <marker id="error_3tup"/>
+      <p>The exception is:</p>
+      <pre>
+error:{Tag, C_FileInfo, Description}
 
-	<p>It is like the older type an exception of the <c>error</c> class. In addition they contain
-	a descriptive text in English. That text is targeted to a developer. Examples are "Bad key size"
-	or "Cipher id is not an atom".
-	</p>
-	<p>The exception tags are:</p>
-	<taglist>
-	  <tag><c>badarg</c></tag>
-	  <item><p>Signifies that one or more arguments are of wrong data type or are otherwise badly formed.</p>
-	  </item>
+Tag = badarg | notsup | error
+C_FileInfo = term()    % Usually only useful for the OTP maintainer
+Description = string() % Clear text, sometimes only useful for the OTP maintainer
+      </pre>
 
-	  <tag><c>notsup</c></tag>
-	  <item><p>Signifies that the algorithm is known but is not supported by current underlying libcrypto
-	  or explicitly disabled when building that one.</p>
-	  </item>
+      <p>The exception tags are:</p>
+      <taglist>
+	<tag><c>badarg</c></tag>
+	<item><p>Signifies that one or more arguments are of wrong data type or are otherwise badly formed.</p>
+	</item>
 
-	  <tag><c>error</c></tag>
-	  <item><p>An error condition that should not occur, for example a memory allocation failed or
-	  the underlying cryptolib returned an error code, for example "Can't initialize context, step 1".
-	  Those text usually needs searching the C-code to be understood.</p>
-	  </item>
-	</taglist>
-	<p>To catch the exception, use for example:</p>
-	<code>
-	  try crypto:crypto_init(Ciph, Key, IV, true)
-	  catch
-	      error:{Tag, {C_FileName,LineNumber}, Description} ->
-	              do_something(......)
-	      .....
-	  end
-	</code>
-      </desc>
-    </datatype>
+	<tag><c>notsup</c></tag>
+	<item><p>Signifies that the algorithm is known but is not supported by current underlying libcrypto
+	or explicitly disabled when building that one.</p>
+	</item>
 
-  </datatypes>
+	<tag><c>error</c></tag>
+	<item><p>An error condition that should not occur, for example a memory allocation failed or
+	the underlying cryptolib returned an error code, for example <c>"Can't initialize context, step 1"</c>.
+	Those text usually needs searching the C-code to be understood.</p>
+	</item>
+      </taglist>
+
+      <p>Usually there are more information in the call stack about which argument caused the exception
+      and what the values where.</p>
+      <p>To catch the exception, use for example:</p>
+      <code>
+try crypto:crypto_init(Ciph, Key, IV, true)
+    catch
+        error:{Tag, _C_FileInfo, Description} ->
+            do_something(......)
+         .....
+end
+	</code>
+    </section>
+  </section>
 
   <!--================ FUNCTIONS ================-->
  
@@ -622,6 +612,7 @@
       <name name="crypto_init" arity="3" since="OTP 22.0"/>
       <fsummary>Initializes a series of encryptions or decryptions</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>Equivalent to the call
 	<seemfa marker="#crypto_init/4"><c>crypto_init(Cipher, Key, &lt;&lt;>>, FlagOrOptions)</c></seemfa>.
 	It is intended for ciphers without an IV (nounce).
@@ -633,6 +624,7 @@
       <name name="crypto_init" arity="4" since="OTP 22.0"/>
       <fsummary>Initializes a series of encryptions or decryptions</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>
 	Initializes a series of encryptions or decryptions and creates an internal state
 	with a reference that is returned.
@@ -689,6 +681,7 @@
       <name name="crypto_update" arity="2" since="OTP 22.0"/>
       <fsummary>Do an actual crypto operation on a part of the full text</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>
 	It does an actual crypto operation on a part of the full text. If the part is less
 	than a number of full blocks, only the full blocks (possibly none) are encrypted 
@@ -708,6 +701,7 @@
       <name name="crypto_dyn_iv_init" arity="3" since="OTP 22.0"/>
       <fsummary>Initializes a series of encryptions or decryptions where the IV is provided later</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>Initializes a series of encryptions or decryptions where the IV is provided later.
 	The actual encryption or decryption is done by
 	<seemfa marker="crypto#crypto_dyn_iv_update/3">crypto_dyn_iv_update/3</seemfa>.
@@ -722,6 +716,7 @@
       <name name="crypto_final" arity="1" since="OTP 23.0"/>
       <fsummary>Ends a series of encryptions or decryptions</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>
 	Finalizes a series of encryptions or decryptions and delivers the final bytes of the final block.
 	The data returned from this function may be empty if no padding was enabled in
@@ -735,6 +730,7 @@
       <name name="crypto_get_data" arity="1" since="OTP 23.0"/>
       <fsummary>Get information about crypto states</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>
 	  Returns information about the State in the argument. The information is the form of a map,
 	  which currently contains at least:
@@ -763,6 +759,7 @@
       <name name="crypto_dyn_iv_update" arity="3" since="OTP 22.0"/>
       <fsummary>Do an actual crypto operation on a part of the full text and the IV is supplied for each part</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>
 	Do an actual crypto operation on a part of the full text and the IV is supplied for each part.
 	The <c>State</c> should be created with
@@ -775,6 +772,7 @@
       <name name="crypto_one_time" arity="4" since="OTP 22.0"/>
       <fsummary>Do a complete encrypt or decrypt of the full text</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>As <seemfa marker="#crypto_one_time/5">crypto_one_time/5</seemfa> but for ciphers without IVs.</p>
       </desc>
     </func>
@@ -783,6 +781,7 @@
       <name name="crypto_one_time" arity="5" since="OTP 22.0"/>
       <fsummary>Do a complete encrypt or decrypt of the full text</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>
 	Do a complete encrypt or decrypt of the full text in the argument <c>Data</c>.
 	</p>
@@ -800,6 +799,7 @@
       <name name="crypto_one_time_aead" arity="7" since="OTP 22.0"/>
       <fsummary>Do a complete encrypt or decrypt with an AEAD cipher of the full text</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>
 	Do a complete encrypt or decrypt with an AEAD cipher of the full text.
 	</p>
@@ -846,6 +846,7 @@
       <name name="mac" arity="3" since="OTP 22.1"/>
       <fsummary></fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
         <p>Short for <seemfa marker="#mac/4">mac(Type, undefined, Key, Data)</seemfa>.
 	</p>
       </desc>
@@ -855,6 +856,7 @@
       <name name="mac" arity="4" since="OTP 22.1"/>
       <fsummary></fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
         <p>Computes a MAC (Message Authentication Code) of type <c>Type</c> from <c>Data</c>.
 	</p>
 
@@ -896,6 +898,7 @@
       <name name="macN" arity="4" since="OTP 22.1"/>
       <fsummary></fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
         <p>Short for <seemfa marker="#macN/5">macN(Type, undefined, Key, Data, MacLength)</seemfa>.
 	</p>
       </desc>
@@ -924,6 +927,7 @@
       <name name="mac_init" arity="2" since="OTP 22.1"/>
       <fsummary></fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
         <p>Short for <seemfa marker="#mac_init/3">mac_init(Type, undefined, Key)</seemfa>.
 	</p>
       </desc>
@@ -933,6 +937,7 @@
       <name name="mac_init" arity="3" since="OTP 22.1"/>
       <fsummary></fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
         <p>Initializes the context for streaming MAC operations.
 	</p>
 	<p><c>Type</c> determines which mac algorithm to use in the MAC operation.
@@ -979,6 +984,7 @@
       <name name="mac_update" arity="2" since="OTP 22.1"/>
       <fsummary></fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
         <p>Updates the MAC represented by <c>State0</c> using the given <c>Data</c> which
 	could be of any length.
 	</p>
@@ -995,6 +1001,7 @@
       <name name="mac_final" arity="1" since="OTP 22.1"/>
       <fsummary></fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
         <p>Finalizes the MAC operation referenced by <c>State</c>. The <c>Mac</c> result will have
 	a default length depending on the <c>Type</c> and <c>SubType</c> in the
 	<seemfa marker="#mac_init/3">mac_init/2,3</seemfa> call.
@@ -1010,6 +1017,7 @@
       <name name="mac_finalN" arity="2" since="OTP 22.1"/>
       <fsummary></fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
         <p>Finalizes the MAC operation referenced by <c>State</c>.
 	</p>
 	<p><c>Mac</c> will be a binary with at most <c>MacLength</c> bytes.
@@ -1037,6 +1045,7 @@
       <name name="compute_key" arity="4" since="OTP R16B01"/>
       <fsummary>Computes the shared secret</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>Computes the shared secret from the private key and the other party's public key.
 	 See also <seemfa marker="public_key:public_key#compute_key/2">public_key:compute_key/2</seemfa>
 	</p>
@@ -1057,19 +1066,34 @@
       <name name="generate_key" arity="3" since="OTP R16B01"/>
       <fsummary>Generates a public key of type <c>Type</c></fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>Generates a public key of type <c>Type</c>.
 	See also <seemfa marker="public_key:public_key#generate_key/1">public_key:generate_key/1</seemfa>.
-	May raise exception:
         </p>
-        <list type="bulleted">
-          <item><c>error:badarg</c>: an argument is of wrong type or has an illegal value,</item>
-	  <item><c>error:low_entropy</c>: the random generator failed due to lack of secure "randomness",</item>
-          <item><c>error:computation_failed</c>: the computation fails of another reason than <c>low_entropy</c>.</item>
-        </list>
+	<note>
+	  <p>If the linked version of cryptolib is OpenSSL 3.0</p>
+	  <list type="bulleted">
+	    <item>
+	    <p>and the <c>Type</c> is <c>dh</c> (diffie-hellman)</p>
+	    </item>
+	    <item>
+	      <p>and the parameter <c>P</c> (in <seetype marker="#dh_params">dh_params()</seetype>)
+	      is one of the MODP groups (see <url href="https://tools.ietf.org/html/rfc3526">RFC 3526</url>)</p>
+	    </item>
+	    <item>
+	      <p>and the optional <c>PrivateKeyBitLength</c> parameter
+	      (in <seetype marker="#dh_params">dh_params()</seetype>)
+	      is present,</p>
+	    </item>
+	  </list>
+	  <p>then the optional key length parameter must be at least
+	  224, 256, 302, 352 and 400 for group sizes of
+	  2048, 3072, 4096, 6144 and 8192, respectively.</p>
+	</note>
 	<note>
 	  <p>RSA key generation is only available if the runtime was
 	  built with dirty scheduler support. Otherwise, attempting to
-	  generate an RSA key will raise exception <c>error:notsup</c>.</p>
+	  generate an RSA key will raise the exception <c>error:notsup</c>.</p>
 	</note>
       </desc>
     </func>
@@ -1078,9 +1102,8 @@
       <name name="hash" arity="2" since="OTP R15B02"/>
       <fsummary></fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
         <p>Computes a message digest of type <c>Type</c> from <c>Data</c>.</p>
-	<p>May raise exception <c>error:notsup</c> in case the chosen <c>Type</c>
-	is not supported by the underlying libcrypto implementation.</p>
       </desc>
     </func>
 
@@ -1088,11 +1111,10 @@
       <name name="hash_init" arity="1" since="OTP R15B02"/>
       <fsummary></fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
         <p>Initializes the context for streaming hash operations. <c>Type</c> determines
         which digest to use. The returned context should be used as argument
 	to <seemfa marker="#hash_update/2">hash_update</seemfa>.</p>
-	<p>May raise exception <c>error:notsup</c> in case the chosen <c>Type</c>
-	is not supported by the underlying libcrypto implementation.</p>
       </desc>
     </func>
 
@@ -1100,6 +1122,7 @@
       <name name="hash_update" arity="2" since="OTP R15B02"/>
       <fsummary></fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
         <p>Updates the digest represented by <c>Context</c> using the given <c>Data</c>. <c>Context</c>
         must have been generated using <seemfa marker="#hash_init/1">hash_init</seemfa>
 	or a previous call to this function. <c>Data</c> can be any length. <c>NewContext</c>
@@ -1112,6 +1135,7 @@
       <name name="hash_final" arity="1" since="OTP R15B02"/>
       <fsummary></fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
         <p>Finalizes the hash operation referenced by <c>Context</c> returned
 	from a previous call to <seemfa marker="#hash_update/2">hash_update</seemfa>.
 	The size of <c>Digest</c> is determined by the type of hash
@@ -1244,6 +1268,7 @@
       <name name="private_decrypt" arity="4" since="OTP R16B01"/>
       <fsummary>Decrypts CipherText using the private Key.</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>Decrypts the <c>CipherText</c>, encrypted with
 	<seemfa marker="#public_encrypt/4">public_encrypt/4</seemfa> (or equivalent function)
 	  using the <c>PrivateKey</c>, and returns the
@@ -1258,6 +1283,7 @@
       <name name="private_encrypt" arity="4" since="OTP R16B01"/>
       <fsummary>Encrypts PlainText using the private Key.</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>Encrypts the <c>PlainText</c> using the <c>PrivateKey</c>
 	and returns the ciphertext. This is a low level signature operation
 	used for instance by older versions of the SSL protocol. See
@@ -1271,6 +1297,7 @@
       <name name="public_decrypt" arity="4" since="OTP R16B01"/>
       <fsummary>Decrypts CipherText using the public Key.</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>Decrypts the <c>CipherText</c>, encrypted with
 	<seemfa marker="#private_encrypt/4">private_encrypt/4</seemfa>(or equivalent function)
 	  using the <c>PrivateKey</c>, and returns the
@@ -1285,6 +1312,7 @@
       <name name="public_encrypt" arity="4" since="OTP R16B01"/>
       <fsummary>Encrypts PlainText using the public Key.</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>Encrypts the <c>PlainText</c> (message digest) using the <c>PublicKey</c>
 	and returns the <c>CipherText</c>. This is a low level signature operation
 	used for instance by older versions of the SSL protocol. See also <seemfa
@@ -1621,6 +1649,7 @@ FloatValue = rand:uniform().     % again
       <name name="sign" arity="5" since="OTP 20.1"/>
       <fsummary> Create digital signature.</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>Creates a digital signature.</p>
 	<p>The msg is either the binary "cleartext" data to be
 	signed or it is the hashed value of "cleartext" i.e. the
@@ -1636,6 +1665,7 @@ FloatValue = rand:uniform().     % again
       <name name="verify" arity="6" since="OTP 20.1"/>
       <fsummary>Verifies a digital signature.</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
 	<p>Verifies a digital signature</p>
 	<p>The msg is either the binary "cleartext" data to be
 	signed or it is the hashed value of "cleartext" i.e. the
@@ -1808,7 +1838,7 @@ FloatValue = rand:uniform().     % again
     </func>
 
     <func>
-      <name name="engine_register" arity="2" since="OTP 24.3.4.3"/>
+      <name name="engine_register" arity="2" since="OTP 25.1"/>
       <fsummary>Register engine for some methods</fsummary>
       <desc>
 	<p>Register engine to handle some type of methods, for example engine_method_digests.</p>
@@ -1821,7 +1851,7 @@ FloatValue = rand:uniform().     % again
     </func>
 
     <func>
-      <name name="engine_unregister" arity="2" since="OTP 24.3.4.3"/>
+      <name name="engine_unregister" arity="2" since="OTP 25.1"/>
       <fsummary>Unregister engine for some methods</fsummary>
       <desc>
 	<p>Unregister engine so it don't handle some type of methods.</p>
@@ -1913,16 +1943,28 @@ FloatValue = rand:uniform().     % again
       </desc>
     </func>
 
+    <func>
+      <name name="hash_equals" arity="2" since="OTP 25.0"/>
+      <fsummary>Constant time memory comparison for fixed length binaries</fsummary>
+      <desc>
+        <p>
+          Constant time memory comparison for fixed length binaries, such as results of HMAC computations.
+        </p>
+        <p>
+          Returns true if the binaries are identical, false if they are of the same length but not identical.
+          The function raises an <c>error:badarg</c> exception if the binaries are of different size.
+	</p>
+      </desc>
+    </func>
+
     <func>
       <name name="pbkdf2_hmac" arity="5" since="OTP 24.2"/>
       <fsummary>PBKDF2 in combination with HMAC</fsummary>
       <desc>
+	<p>Uses the <seeerl marker="#error_3tup">3-tuple style</seeerl> for error handling.</p>
         <p>
           PKCS #5 PBKDF2 (Password-Based Key Derivation Function 2) in combination with HMAC.
         </p>
-        <p>
-          The function raises a <c>error:badarg</c> if the parameters are in wrong format.
-        </p>
       </desc>
     </func>
 
diff --git a/lib/crypto/doc/src/crypto_app.xml b/lib/crypto/doc/src/crypto_app.xml
index 84fad2f5b8..dcc86cd49c 100644
--- a/lib/crypto/doc/src/crypto_app.xml
+++ b/lib/crypto/doc/src/crypto_app.xml
@@ -50,12 +50,9 @@
     LibreSSL should also work.</p>
 
     <p>The crypto app is tested daily with at least one version of each of the
-    OpenSSL 0.9.8, 1.0.0, 1.0.1, 1.0.2, 1.1.0 and 1.1.1. FIPS mode is also tested.</p>
+    OpenSSL 1.0.1, 1.0.2, 1.1.0, 1.1.1 and 3.0. FIPS mode is also tested for 1.0.1 and 1.0.2.</p>
     
-    <note><p>Compiling, linking and running with OpenSSL 3.0 works although the
-    crypto app calls deprecated functions. We do not recommend it for other than
-    experimental purposes or alpha testing, since it is not extensively tested yet.</p>
-    </note>
+    <p>Using OpenSSL 3.0 with Engines or in FIPS mode is not yet supported by the OTP/crypto app.</p>
 
     <p>Source releases of OpenSSL can be downloaded from the <url href="http://www.openssl.org">OpenSSL</url> project home page,
     or mirror sites listed there.
diff --git a/lib/crypto/doc/src/notes.xml b/lib/crypto/doc/src/notes.xml
index 53d9b71dce..cfe135808b 100644
--- a/lib/crypto/doc/src/notes.xml
+++ b/lib/crypto/doc/src/notes.xml
@@ -4,7 +4,7 @@
 <chapter>
   <header>
     <copyright>
-      <year>1999</year><year>2021</year>
+      <year>1999</year><year>2022</year>
       <holder>Ericsson AB. All Rights Reserved.</holder>
     </copyright>
     <legalnotice>
@@ -31,6 +31,291 @@
   </header>
   <p>This document describes the changes made to the Crypto application.</p>
 
+<section><title>Crypto 5.1.2</title>
+
+    <section><title>Fixed Bugs and Malfunctions</title>
+      <list>
+        <item>
+	    <p>Fix configure with <c>--with-ssl</c> and
+	    <c>--disable-dynamic-ssl-lib</c> on Windows.</p>
+          <p>
+	    Own Id: OTP-18147 Aux Id: GH-6024, PR-6056 </p>
+        </item>
+        <item>
+	    <p> Remove all references correctly in the garbage
+	    collection if an engine handle was not explicit unloaded.
+	    </p>
+          <p>
+	    Own Id: OTP-18152</p>
+        </item>
+        <item>
+	    <p>Changed the behaviour of the engine load/unload
+	    functions</p> <p> The engine load/unload functions have
+	    got changed semantics to get a more consistent behaviour
+	    and work correct when variables are garbage collected.
+	    </p> <p> The load functions now don't register the
+	    methods for the engine to replace. That will now be
+	    handled with the new functions
+	    engine_register/engine_unregister if needed. </p> <p>
+	    Some functions are removed from the documentation and
+	    therefor the API, but they are left in the code for
+	    compatibility. </p> <list> <item>engine_load/4: is now
+	    the same as engine_load/3</item> <item>engine_unload/2:
+	    is now the same as engine_unload/1</item>
+	    <item>ensure_engine_loaded/3: is now the same as
+	    ensure_engine_loaded/2</item>
+	    <item>ensure_engine_unloaded/1, ensure_engine_unloaded/2:
+	    is now the same as engine_unload/1</item> </list>
+          <p>
+	    *** POTENTIAL INCOMPATIBILITY ***</p>
+          <p>
+	    Own Id: OTP-18172 Aux Id: ERIERL-826 </p>
+        </item>
+        <item>
+          <p>
+	    Fixed a naming bug for AES-CFB and Blowfish-CFB/OFB when
+	    linked with OpenSSL 3.0 cryptolib.</p>
+          <p>
+	    Own Id: OTP-18200</p>
+        </item>
+        <item>
+          <p>
+	    Sign/verify does now behave as in OTP-24 and earlier for
+	    eddsa.</p>
+          <p>
+	    Own Id: OTP-18205 Aux Id: GH-6219 </p>
+        </item>
+      </list>
+    </section>
+
+
+    <section><title>Improvements and New Features</title>
+      <list>
+        <item>
+          <p>
+	    Pass elliptic curve names from crypto.erl to crypto's
+	    nif.</p>
+          <p>
+	    Own Id: OTP-18037</p>
+        </item>
+        <item>
+          <p>
+	    The configure option <c>--disable-deprecated-warnings</c>
+	    is removed. It was used for some releases when the
+	    support for OpenSSL 3.0 was not completed. It is not
+	    needed in OTP 25.</p>
+          <p>
+	    Own Id: OTP-18133</p>
+        </item>
+        <item>
+          <p>
+	    Crypto is now considered to be usable with the OpenSSL
+	    3.0 cryptolib for production code.</p>
+          <p>
+	    ENGINE and FIPS are not yet fully functional.</p>
+          <p>
+	    Own Id: OTP-18153</p>
+        </item>
+        <item>
+          <p>
+	    Do not exit if the legacy provider is missing in
+	    libcrypto 3.0.</p>
+          <p>
+	    Own Id: OTP-18217</p>
+        </item>
+      </list>
+    </section>
+
+</section>
+
+<section><title>Crypto 5.1.1</title>
+
+    <section><title>Fixed Bugs and Malfunctions</title>
+      <list>
+        <item>
+          <p>
+	    Note in the documentation that MODP (rfc3526) groups and
+	    OpenSSL 3.0 can give an error if a call to
+	    <c>crypto:generate_key/2</c> specifies a key length, and
+	    that length is to small.</p>
+          <p>
+	    Own Id: OTP-18046</p>
+        </item>
+      </list>
+    </section>
+
+
+    <section><title>Improvements and New Features</title>
+      <list>
+        <item>
+          <p>
+	    The cmac now uses only the 3.0 API</p>
+          <p>
+	    Own Id: OTP-18010</p>
+        </item>
+        <item>
+          <p>
+	    Documentation is now updated with which OpenSSL cryptolib
+	    versions that OTP currently is tested.</p>
+          <p>
+	    Own Id: OTP-18132</p>
+        </item>
+      </list>
+    </section>
+
+</section>
+
+<section><title>Crypto 5.1</title>
+
+    <section><title>Fixed Bugs and Malfunctions</title>
+      <list>
+        <item>
+	    <p>Fix timing bug in ensure_engine_loaded</p> <p>When two
+	    ensure_engine_loaded() calls were done in parallel there
+	    was a possibility that a crypto lib function was called
+	    by both instead of just one of them which resulted in an
+	    error. This is solved by moving the implementation from
+	    erlang down into a NIF function that uses a mutex to
+	    protect the sensitive part.</p>
+          <p>
+	    Own Id: OTP-17858 Aux Id: ERIERL-728 </p>
+        </item>
+        <item>
+          <p>
+	    Remove faulty types <c>run_time_error()</c> and
+	    <c>descriptive_error()</c>.</p>
+          <p>
+	    Own Id: OTP-17984</p>
+        </item>
+      </list>
+    </section>
+
+
+    <section><title>Improvements and New Features</title>
+      <list>
+        <item>
+          <p>
+	    Input for <c>configure</c> scripts adapted to
+	    <c>autoconf</c> 2.71.</p>
+          <p>
+	    Own Id: OTP-17414 Aux Id: PR-4967 </p>
+        </item>
+        <item>
+          <p>
+	    Add crypto:hash_equals/2</p>
+          <p>
+	    Own Id: OTP-17471 Aux Id: PR-4750 </p>
+        </item>
+        <item>
+          <p>
+	    Add /opt/homebrew/opt/openssl to standard locations to
+	    search for OpenSSL cryptolib.</p>
+          <p>
+	    Own Id: OTP-17561</p>
+        </item>
+        <item>
+          <p>
+	    <c>crypto_dyn_iv_init/3</c> and
+	    <c>crypto_dyn_iv_update/3</c> are deprecated.</p>
+          <p>
+	    Own Id: OTP-17870</p>
+        </item>
+        <item>
+          <p>
+	    The information in error messages are increased.</p>
+          <p>
+	    Previously the error was signaled with en error class
+	    exception <c>badarg</c>, <c>notsup</c> or <c>error</c>,
+	    and also in some more ways like an other exception or a
+	    return value in a non-standardized format.</p>
+          <p>
+	    Now it is an error-class exception
+	    <c>{notsup|badarg|error, InfoFromCfile,
+	    Description::string()}</c>.</p>
+          <p>
+	    The <c>InfoFromCfile</c> is a term with name and line
+	    number of the C-file where the error was found. This is
+	    primarily intended for a crypto maintainer or an advanced
+	    user to find the cause of complicated errors - maybe in
+	    crypto itself. The contents of that term might be changed
+	    in the future.</p>
+          <p>
+	    The <c>Description</c> is a clear text string that
+	    describes the error. In case of <c>badarg</c> and
+	    <c>notsup</c> the intention is that it should help the
+	    user to find the cause ("Bad key size" as an example).
+	    Specially for some <c>error</c> that are unlikely, the
+	    string may not be possible to understand without deep
+	    knowledge of the underlying cryptolib. Such messages are
+	    intended for a crypto maintainer.</p>
+          <p>
+	    The first element on call stack (the <c>S</c> in <c>try
+	    ... catch error:E:S .... end</c>) gives more information
+	    like the actual argument list in the call of crypto and
+	    the argument number (if possible) in the call to the NIF
+	    inside crypto.</p>
+          <p>
+	    The functions in crypto affected by this change are:</p>
+          <p>
+	    sign/4, sign/5, verify/5, verify/6,</p>
+          <p>
+	    generate_key/2, generate_key/3, compute_key/4,</p>
+          <p>
+	    hash/2, hash/4, hash_init/1, hash_update/4, hash_final/1,</p>
+          <p>
+	    mac/3,4, mac_init/3, mac_update/2, mac_final/2,</p>
+          <p>
+	    pbkdf2_hmac/5,</p>
+          <p>
+	    public_encrypt/4, private_decrypt/4, private_encrypt/4,
+	    public_decrypt/4</p>
+          <p>
+	    This schema was introduced earlier in:</p>
+          <p>
+	    crypto_init/3, crypto_init/4, crypto_update/2,
+	    crypto_final/1, crypto_get_data/1,</p>
+          <p>
+	    crypto_one_time/4, crypto_one_time/5,
+	    crypto_one_time_aead/6, crypto_one_time_aead/7</p>
+          <p>
+	    *** POTENTIAL INCOMPATIBILITY ***</p>
+          <p>
+	    Own Id: OTP-17965</p>
+        </item>
+        <item>
+          <p>
+	    Add Output Feedback mode (OFB) support for AES encryption
+	    / decryption for key sizes of 128, 192 and 256 bits.</p>
+          <p>
+	    Own Id: OTP-18067 Aux Id: PR-5866 </p>
+        </item>
+        <item>
+          <p>
+	    The cryptolib API deprecated in OpenSSL 3.0 is now no
+	    longer used with a few exceptions listed below.</p>
+          <p>
+	    Although OpenSSL 3.0.x itself is stable, its usage in
+	    OTP/crypto should still not be considered suitable for
+	    production code.</p>
+          <p>
+	    The use of ENGINEs is still disabled by default when
+	    using 3.0.</p>
+          <p>
+	    Deprecated functions are still called in the
+	    otp_test_engine.c (only used in tests), in mac.c
+	    (EVP_PKEY_new_CMAC_key) and five function calls in ec.c
+	    (EVP_PKEY_assign, EC_KEY_get_conv_form,
+	    EVP_PKEY_get1_EC_KEY, EC_KEY_get0_group and
+	    EC_KEY_set_public_key).</p>
+          <p>
+	    Own Id: OTP-18086 Aux Id: OTP-16282, OTP-16643,
+	    OTP-16644, OTP-17701, OTP-17702, OTP-17704 </p>
+        </item>
+      </list>
+    </section>
+
+</section>
+
 <section><title>Crypto 5.0.6.3</title>
 
     <section><title>Fixed Bugs and Malfunctions</title>
@@ -479,6 +764,66 @@
 
 </section>
 
+<section><title>Crypto 4.9.0.4</title>
+
+    <section><title>Fixed Bugs and Malfunctions</title>
+      <list>
+        <item>
+	    <p>Changed the behaviour of the engine load/unload
+	    functions</p> <p> The engine load/unload functions have
+	    got changed semantics to get a more consistent behaviour
+	    and work correct when variables are garbage collected.
+	    </p> <p> The load functions now don't register the
+	    methods for the engine to replace. That will now be
+	    handled with the new functions
+	    engine_register/engine_unregister if needed. </p> <p>
+	    Some functions functions are removed from the
+	    documentation and therefor the API, but they are left in
+	    the code for compatibility. </p> <list>
+	    <item>engine_load/4: is now the same as
+	    engine_load/3</item> <item>engine_unload/2: is now the
+	    same as engine_unload/1</item>
+	    <item>ensure_engine_loaded/3: is now the same as
+	    ensure_engine_loaded/2</item>
+	    <item>ensure_engine_unloaded/1, ensure_engine_unloaded/2:
+	    is now the same as engine_unload/1</item> </list>
+          <p>
+	    *** POTENTIAL INCOMPATIBILITY ***</p>
+          <p>
+	    Own Id: OTP-18172 Aux Id: ERIERL-826 </p>
+        </item>
+      </list>
+    </section>
+
+</section>
+
+<section><title>Crypto 4.9.0.3</title>
+
+    <section><title>Fixed Bugs and Malfunctions</title>
+      <list>
+        <item>
+	    <p>Fix timing bug in ensure_engine_loaded</p> <p>When two
+	    ensure_engine_loaded() calls were done in parallel there
+	    was a possibility that a crypto lib function was called
+	    by both instead of just one of them which resulted in an
+	    error. This is solved by moving the implementation from
+	    erlang down into a NIF function that uses a mutex to
+	    protect the sensitive part.</p>
+          <p>
+	    Own Id: OTP-17858 Aux Id: ERIERL-728 </p>
+        </item>
+        <item>
+	    <p> Remove all references correctly in the garbage
+	    collection if an engine handle was not explicit unloaded.
+	    </p>
+          <p>
+	    Own Id: OTP-18152</p>
+        </item>
+      </list>
+    </section>
+
+</section>
+
 <section><title>Crypto 4.9.0.2</title>
 
     <section><title>Fixed Bugs and Malfunctions</title>
diff --git a/lib/crypto/src/Makefile b/lib/crypto/src/Makefile
index fea32dc4e3..893f679390 100644
--- a/lib/crypto/src/Makefile
+++ b/lib/crypto/src/Makefile
@@ -1,7 +1,7 @@
 #
 # %CopyrightBegin%
 #
-# Copyright Ericsson AB 1999-2021. All Rights Reserved.
+# Copyright Ericsson AB 1999-2022. All Rights Reserved.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -61,7 +61,7 @@ ERL_COMPILE_FLAGS += -DCRYPTO_VSN=\"$(VSN)\" -Werror -I../include
 # Targets
 # ----------------------------------------------------
 
-debug opt valgrind asan: $(TARGET_FILES) $(APP_TARGET) $(APPUP_TARGET)
+$(TYPES): $(TARGET_FILES) $(APP_TARGET) $(APPUP_TARGET)
 
 clean:
 	rm -f $(TARGET_FILES) $(APP_TARGET) $(APPUP_TARGET)
diff --git a/lib/crypto/src/crypto.app.src b/lib/crypto/src/crypto.app.src
index 492aa10e51..30e804c7e2 100644
--- a/lib/crypto/src/crypto.app.src
+++ b/lib/crypto/src/crypto.app.src
@@ -1,7 +1,7 @@
 %%
 %% %CopyrightBegin%
 %%
-%% Copyright Ericsson AB 1999-2017. All Rights Reserved.
+%% Copyright Ericsson AB 1999-2021. All Rights Reserved.
 %%
 %% Licensed under the Apache License, Version 2.0 (the "License");
 %% you may not use this file except in compliance with the License.
@@ -25,6 +25,6 @@
     {registered, []},
     {applications, [kernel, stdlib]},
     {env, [{fips_mode, false}, {rand_cache_size, 896}]},
-    {runtime_dependencies, ["erts-9.0","stdlib-3.4","kernel-5.3"]}]}.
+    {runtime_dependencies, ["erts-9.0","stdlib-3.9","kernel-5.3"]}]}.
 
 
diff --git a/lib/crypto/src/crypto.erl b/lib/crypto/src/crypto.erl
index 07d3036359..53cdc76830 100644
--- a/lib/crypto/src/crypto.erl
+++ b/lib/crypto/src/crypto.erl
@@ -45,6 +45,12 @@
 -export([format_error/2]).
 -export([pbkdf2_hmac/5]).
 
+%%%----------------------------------------------------------------
+%% Deprecated functions
+-deprecated([crypto_dyn_iv_init/3,
+             crypto_dyn_iv_update/3
+           ]).
+
 %%%----------------------------------------------------------------
 %% Removed functions.
 %%
@@ -98,6 +104,8 @@
          crypto_final/1,
          crypto_get_data/1,
 
+         hash_equals/2,
+
          supports/1,
          mac/3, mac/4, macN/4, macN/5,
          mac_init/2, mac_init/3, mac_update/2, mac_final/1, mac_finalN/2
@@ -127,6 +135,30 @@
          ensure_engine_unloaded/2
         ]).
 
+-nifs([info_nif/0, info_lib/0, info_fips/0, enable_fips_mode_nif/1,
+       hash_algorithms/0, pubkey_algorithms/0, cipher_algorithms/0,
+       mac_algorithms/0, curve_algorithms/0, rsa_opts_algorithms/0,
+       hash_info/1, hash_nif/2, hash_init_nif/1, hash_update_nif/2,
+       hash_final_nif/1, mac_nif/4, mac_init_nif/3, mac_update_nif/2,
+       mac_final_nif/1, cipher_info_nif/1, ng_crypto_init_nif/4,
+       ng_crypto_update_nif/2, ng_crypto_update_nif/3, ng_crypto_final_nif/1,
+       ng_crypto_get_data_nif/1, ng_crypto_one_time_nif/5,
+       strong_rand_bytes_nif/1, strong_rand_range_nif/1, rand_uniform_nif/2,
+       mod_exp_nif/4, do_exor/2, hash_equals_nif/2, pbkdf2_hmac_nif/5,
+       pkey_sign_nif/5, pkey_verify_nif/6, pkey_crypt_nif/6,
+       rsa_generate_key_nif/2, dh_generate_key_nif/4, dh_compute_key_nif/3,
+       evp_compute_key_nif/3, evp_generate_key_nif/2, privkey_to_pubkey_nif/2,
+       srp_value_B_nif/5, srp_user_secret_nif/7, srp_host_secret_nif/5,
+       ec_generate_key_nif/2, ecdh_compute_key_nif/3, rand_seed_nif/1,
+       aead_cipher_nif/7, engine_by_id_nif/1, engine_init_nif/1,
+       engine_free_nif/1, engine_load_dynamic_nif/0,
+       engine_ctrl_cmd_strings_nif/3, engine_register_nif/2,
+       engine_unregister_nif/2, engine_add_nif/1, engine_remove_nif/1,
+       engine_get_first_nif/0, engine_get_next_nif/1, engine_get_id_nif/1,
+       engine_get_name_nif/1, engine_get_all_methods_nif/0,
+       ensure_engine_loaded_nif/2
+      ]).
+
 -export_type([ %% A minimum exported: only what public_key needs.
                dh_private/0,
                dh_public/0,
@@ -339,6 +371,10 @@
                    | aes_256_cbc
                    | aes_cbc
 
+                   | aes_128_ofb
+                   | aes_192_ofb
+                   | aes_256_ofb
+
                    | aes_128_cfb128
                    | aes_192_cfb128
                    | aes_256_cfb128
@@ -394,18 +430,20 @@
 
 -type crypto_integer() :: binary() | integer().
 
-%%%
-%% Exceptions
-%%   error:badarg
-%%   error:notsup
--type run_time_error() :: any().
+%% %%%--------------------------------------------------------------------
+%% %%% Exceptions
+%% %%%
+%% %% Exceptions
+%% %%   error:badarg
+%% %%   error:notsup
+%% -type run_time_error() :: badarg | notsup.
 
-%% Exceptions
-%%   error:{badarg,Reason::term()}
-%%   error:{notsup,Reason::term()}
-%%   error:{error,Reason::term()}
--type descriptive_error() :: any() .
 
+%% %% Exceptions
+%% %%   error:{badarg, file_line_info, Reason::term()}
+%% %%   error:{notsup,Reason::term()}
+%% %%   error:{error,Reason::term()}
+%% -type descriptive_error() :: {badarg | notsup | error, FileLineInfo::any, Reason::string()}.
 
 %%--------------------------------------------------------------------
 %% Compilation and loading
@@ -573,7 +611,7 @@ enable_fips_mode_nif(_) -> ?nif_stub.
                KeyLen :: pos_integer(),
                Result :: binary().
 pbkdf2_hmac(Digest, Pass, Salt, Iter, KeyLen) ->
-  pbkdf2_hmac_nif(Digest, Pass, Salt, Iter, KeyLen).
+    ?nif_call(pbkdf2_hmac_nif(Digest, Pass, Salt, Iter, KeyLen)).
 
 pbkdf2_hmac_nif(_, _, _, _, _) -> ?nif_stub.
 
@@ -585,7 +623,7 @@ pbkdf2_hmac_nif(_, _, _, _, _) -> ?nif_stub.
 
 -type hash_algorithm() :: sha1() | sha2() | sha3() | blake2() | ripemd160 | compatibility_only_hash() .
 
--spec hash_info(Type) -> Result | run_time_error()
+-spec hash_info(Type) -> Result
                              when Type :: hash_algorithm(),
                                   Result :: #{size := integer(),
                                               block_size := integer(),
@@ -607,7 +645,7 @@ hash(Type, Data) ->
 -spec hash_init(Type) -> State when Type :: hash_algorithm(),
                                     State :: hash_state().
 hash_init(Type) ->
-    notsup_to_error(hash_init_nif(Type)).
+    ?nif_call(hash_init_nif(Type)).
 
 -spec hash_update(State, Data) -> NewState when State :: hash_state(),
                                                 NewState :: hash_state(),
@@ -620,7 +658,7 @@ hash_update(Context, Data) ->
 -spec hash_final(State) -> Digest when  State :: hash_state(),
                                         Digest :: binary().
 hash_final(Context) ->
-    notsup_to_error(hash_final_nif(Context)).
+    ?nif_call(hash_final_nif(Context)).
 
 %%%================================================================
 %%%
@@ -641,7 +679,7 @@ hash_final(Context) ->
 %%%----------------------------------------------------------------
 %%% Calculate MAC for the whole text at once
 
--spec mac(Type :: poly1305, Key, Data) -> Mac | descriptive_error()
+-spec mac(Type :: poly1305, Key, Data) -> Mac
                      when Key :: iodata(),
                           Data :: iodata(),
                           Mac :: binary().
@@ -649,7 +687,7 @@ hash_final(Context) ->
 mac(poly1305, Key, Data) -> mac(poly1305, undefined, Key, Data).
 
 
--spec mac(Type, SubType, Key, Data) -> Mac | descriptive_error()
+-spec mac(Type, SubType, Key, Data) -> Mac
                      when Type :: hmac | cmac | poly1305,
                           SubType :: hmac_hash_algorithm() | cmac_cipher_algorithm() | undefined,
                           Key :: iodata(),
@@ -658,11 +696,10 @@ mac(poly1305, Key, Data) -> mac(poly1305, undefined, Key, Data).
 
 mac(Type, SubType, Key0, Data) ->
     Key = iolist_to_binary(Key0),
-    mac_nif(Type, alias(SubType,Key), Key, Data).
-
+    ?nif_call(mac_nif(Type, alias(SubType,Key), Key, Data)).
 
 
--spec macN(Type :: poly1305, Key, Data, MacLength) -> Mac | descriptive_error()
+-spec macN(Type :: poly1305, Key, Data, MacLength) -> Mac
                      when Key :: iodata(),
                           Data :: iodata(),
                           Mac :: binary(),
@@ -672,7 +709,7 @@ macN(Type, Key, Data, MacLength) ->
     macN(Type, undefined, Key, Data, MacLength).
 
 
--spec macN(Type, SubType, Key, Data, MacLength) -> Mac | descriptive_error()
+-spec macN(Type, SubType, Key, Data, MacLength) -> Mac
                      when Type :: hmac | cmac | poly1305,
                           SubType :: hmac_hash_algorithm() | cmac_cipher_algorithm() | undefined,
                           Key :: iodata(),
@@ -689,40 +726,40 @@ macN(Type, SubType, Key, Data, MacLength) ->
 
 -opaque mac_state() :: reference() .
 
--spec mac_init(Type :: poly1305, Key) -> State | descriptive_error()
+-spec mac_init(Type :: poly1305, Key) -> State
                           when Key :: iodata(),
                                State :: mac_state() .
 mac_init(poly1305, Key) ->
-    mac_init_nif(poly1305, undefined, Key).
+    ?nif_call(mac_init_nif(poly1305, undefined, Key)).
 
 
--spec mac_init(Type, SubType, Key) -> State | descriptive_error()
+-spec mac_init(Type, SubType, Key) -> State
                           when Type :: hmac | cmac | poly1305,
                                SubType :: hmac_hash_algorithm() | cmac_cipher_algorithm() | undefined,
                                Key :: iodata(),
                                State :: mac_state() .
 mac_init(Type, SubType, Key0) ->
     Key = iolist_to_binary(Key0),
-    mac_init_nif(Type, alias(SubType,Key), Key).
+    ?nif_call(mac_init_nif(Type, alias(SubType,Key), Key)).
 
 
--spec mac_update(State0, Data) -> State | descriptive_error()
+-spec mac_update(State0, Data) -> State
                      when Data :: iodata(),
                           State0 :: mac_state(),
                           State :: mac_state().
 mac_update(Ref, Data) ->
-    mac_update_nif(Ref, Data).
+    ?nif_call(mac_update_nif(Ref, Data)).
 
 
 
--spec mac_final(State) -> Mac | descriptive_error()
+-spec mac_final(State) -> Mac
                               when State :: mac_state(),
                                    Mac :: binary().
 mac_final(Ref) ->
-    mac_final_nif(Ref).
+    ?nif_call(mac_final_nif(Ref)).
 
 
--spec mac_finalN(State, MacLength) -> Mac | descriptive_error()
+-spec mac_finalN(State, MacLength) -> Mac
                               when State :: mac_state(),
                                    MacLength :: pos_integer(),
                                    Mac :: binary().
@@ -750,7 +787,7 @@ mac_final_nif(_Ref) -> ?nif_stub.
 
 
 %%%---- Cipher info
--spec cipher_info(Type) -> Result | run_time_error()
+-spec cipher_info(Type) -> Result
                                when Type :: cipher(),
                                     Result :: #{key_length := integer(),
                                                 iv_length := integer(),
@@ -819,7 +856,7 @@ cipher_info(Type) ->
 %%% Create and initialize a new state for encryption or decryption
 %%%
 
--spec crypto_init(Cipher, Key, FlagOrOptions) -> State | descriptive_error()
+-spec crypto_init(Cipher, Key, FlagOrOptions) -> State
                                                    when Cipher :: cipher_no_iv(),
                                                         Key :: iodata(),
                                                         FlagOrOptions :: crypto_opts() | boolean(),
@@ -829,7 +866,7 @@ crypto_init(Cipher, Key, FlagOrOptions) ->
               {1,2,-1,3}
              ).
 
--spec crypto_init(Cipher, Key, IV, FlagOrOptions) -> State | descriptive_error()
+-spec crypto_init(Cipher, Key, IV, FlagOrOptions) -> State
                                                        when Cipher :: cipher_iv(),
                                                             Key :: iodata(),
                                                             IV :: iodata(),
@@ -839,7 +876,7 @@ crypto_init(Cipher, Key, IV, FlagOrOptions) ->
     ?nif_call(ng_crypto_init_nif(alias(Cipher,Key), Key, IV, FlagOrOptions)).
 
 %%%----------------------------------------------------------------
--spec crypto_dyn_iv_init(Cipher, Key, FlagOrOptions) -> State | descriptive_error()
+-spec crypto_dyn_iv_init(Cipher, Key, FlagOrOptions) -> State
                                                           when Cipher :: cipher_iv(),
                                                                Key :: iodata(),
                                                                FlagOrOptions :: crypto_opts() | boolean(),
@@ -858,7 +895,7 @@ crypto_dyn_iv_init(Cipher, Key, FlagOrOptions) ->
 %%% blocksize.
 %%%
 
--spec crypto_update(State, Data) -> Result | descriptive_error()
+-spec crypto_update(State, Data) -> Result
                             when State :: crypto_state(),
                                  Data :: iodata(),
                                  Result :: binary() .
@@ -866,7 +903,7 @@ crypto_update(State, Data) ->
     ?nif_call(ng_crypto_update_nif(State, Data)).
 
 %%%----------------------------------------------------------------
--spec crypto_dyn_iv_update(State, Data, IV) -> Result | descriptive_error()
+-spec crypto_dyn_iv_update(State, Data, IV) -> Result
                                                    when State :: crypto_state(),
                                                         Data :: iodata(),
                                                         IV :: iodata(),
@@ -880,7 +917,7 @@ crypto_dyn_iv_update(State, Data, IV) ->
 %%% to crypto_uptate was not an integer number of blocks, the rest
 %%% is returned from this function.
 
--spec crypto_final(State) -> FinalResult | descriptive_error()
+-spec crypto_final(State) -> FinalResult
                             when State :: crypto_state(),
                                  FinalResult :: binary() .
 crypto_final(State) ->
@@ -903,7 +940,7 @@ crypto_get_data(State) ->
 %%%
 
 -spec crypto_one_time(Cipher, Key, Data, FlagOrOptions) ->
-                             Result | descriptive_error()
+                             Result
                                  when Cipher :: cipher_no_iv(),
                                       Key :: iodata(),
                                       Data :: iodata(),
@@ -918,7 +955,7 @@ crypto_one_time(Cipher, Key, Data, FlagOrOptions) ->
 
 
 -spec crypto_one_time(Cipher, Key, IV, Data, FlagOrOptions) ->
-                             Result | descriptive_error()
+                             Result
                                  when Cipher :: cipher_iv(),
                                       Key :: iodata(),
                                       IV :: iodata(),
@@ -933,7 +970,7 @@ crypto_one_time(Cipher, Key, IV, Data, FlagOrOptions) ->
 
 %%%----------------------------------------------------------------
 -spec crypto_one_time_aead(Cipher, Key, IV, InText, AAD, EncFlag::true) ->
-                             Result | descriptive_error()
+                             Result
                                  when Cipher :: cipher_aead(),
                                       Key :: iodata(),
                                       IV :: iodata(),
@@ -951,7 +988,7 @@ crypto_one_time_aead(Cipher, Key, IV, PlainText, AAD, true) ->
 
 
 -spec crypto_one_time_aead(Cipher, Key, IV, InText, AAD, TagOrTagLength, EncFlag) ->
-                             Result | descriptive_error()
+                             Result
                                  when Cipher :: cipher_aead(),
                                       Key :: iodata(),
                                       IV :: iodata(),
@@ -1418,11 +1455,9 @@ sign(Algorithm, Type, Data, Key) ->
 
 sign(Algorithm0, Type0, Data, Key, Options) ->
     {Algorithm, Type} = sign_verify_compatibility(Algorithm0, Type0, Data),
-    case pkey_sign_nif(Algorithm, Type, Data, format_pkey(Algorithm, Key), Options) of
-	error -> erlang:error(badkey, [Algorithm, Type, Data, Key, Options]);
-	notsup -> erlang:error(notsup);
-	Signature -> Signature
-    end.
+    ?nif_call(pkey_sign_nif(Algorithm, Type, Data, format_pkey(Algorithm, Key), Options),
+              {1, 2, 3, 4, 5},
+              [Algorithm0, Type0, Data, Key, Options]).
 
 pkey_sign_nif(_Algorithm, _Type, _Digest, _Key, _Options) -> ?nif_stub.
 
@@ -1467,10 +1502,9 @@ verify(Algorithm, Type, Data, Signature, Key) ->
 
 verify(Algorithm0, Type0, Data, Signature, Key, Options) ->
     {Algorithm, Type} = sign_verify_compatibility(Algorithm0, Type0, Data),
-    case pkey_verify_nif(Algorithm, Type, Data, Signature, format_pkey(Algorithm, Key), Options) of
-	notsup -> erlang:error(notsup);
-	Boolean -> Boolean
-    end.
+    ?nif_call(pkey_verify_nif(Algorithm, Type, Data, Signature, format_pkey(Algorithm, Key), Options),
+              {1,2,3,4,5},
+              [Algorithm0, Type0, Data, Signature, Key, Options]).
 
 pkey_verify_nif(_Algorithm, _Type, _Data, _Signature, _Key, _Options) -> ?nif_stub.
 
@@ -1556,12 +1590,7 @@ pkey_crypt(rsa, Text, Key, Padding, PubPriv, EncDec) when is_atom(Padding) ->
     pkey_crypt(rsa, Text, Key, [{rsa_padding, Padding}], PubPriv, EncDec);
 
 pkey_crypt(Alg, Text, Key, Options, PubPriv, EncDec) ->
-    case pkey_crypt_nif(Alg, Text, format_pkey(Alg,Key), Options, PubPriv, EncDec) of
-	error when EncDec==true  -> erlang:error(encrypt_failed, [Alg, Text, Key, Options]);
-	error when EncDec==false -> erlang:error(decrypt_failed, [Alg, Text, Key, Options]);
-	notsup -> erlang:error(notsup);
-	Out -> Out
-    end.
+    ?nif_call(pkey_crypt_nif(Alg, Text, format_pkey(Alg,Key), Options, PubPriv, EncDec)).
 
 pkey_crypt_nif(_Algorithm, _In, _Key, _Options, _IsPrivate, _IsEncrypt) -> ?nif_stub.
 
@@ -1596,9 +1625,11 @@ generate_key(dh, DHParameters0, PrivateKey) ->
             [P,G,L] -> {[P,G], L};
             [P,G] -> {[P,G], 0}
         end,
-    dh_generate_key_nif(ensure_int_as_bin(PrivateKey),
-			map_ensure_int_as_bin(DHParameters),
-                        0, Len);
+    ?nif_call(dh_generate_key_nif(ensure_int_as_bin(PrivateKey),
+                                  map_ensure_int_as_bin(DHParameters),
+                                  0, Len),
+              {3, 2, -1, 2},
+              [dh, DHParameters0, PrivateKey]);
 
 generate_key(srp, {host, [Verifier, Generator, Prime, Version]}, PrivArg)
   when is_binary(Verifier), is_binary(Generator), is_binary(Prime), is_atom(Version) ->
@@ -1642,14 +1673,20 @@ generate_key(ecdh, Curve, PrivKey) when Curve == x448 ;
     generate_key(eddh, Curve, PrivKey);
 generate_key(eddh, Curve, PrivKey) when Curve == x448 ;
                                         Curve == x25519 ->
-    evp_generate_key_nif(Curve, ensure_int_as_bin(PrivKey));
+    ?nif_call(evp_generate_key_nif(Curve, ensure_int_as_bin(PrivKey)),
+              {2, 3},
+              [eddh, Curve, PrivKey]
+             );
 
 generate_key(ecdh, Curve, PrivKey) ->
-    ec_key_generate(nif_curve_params(Curve), ensure_int_as_bin(PrivKey));
+    ?nif_call(ec_generate_key_nif(nif_curve_params(Curve), ensure_int_as_bin(PrivKey)));
 
 generate_key(eddsa, Curve, PrivKey) when Curve == ed448 ;
                                          Curve == ed25519 ->
-    evp_generate_key_nif(Curve, ensure_int_as_bin(PrivKey)).
+    ?nif_call(evp_generate_key_nif(Curve, ensure_int_as_bin(PrivKey)),
+              {2, 3},
+              [eddsa, Curve, PrivKey]
+             ).
 
 evp_generate_key_nif(_Curve, _PrivKey) -> ?nif_stub.
 
@@ -1664,13 +1701,11 @@ evp_generate_key_nif(_Curve, _PrivKey) -> ?nif_stub.
                                        .
 
 compute_key(dh, OthersPublicKey, MyPrivateKey, DHParameters) ->
-    case dh_compute_key_nif(ensure_int_as_bin(OthersPublicKey),
-			    ensure_int_as_bin(MyPrivateKey),
-			    map_ensure_int_as_bin(DHParameters)) of
-	error -> erlang:error(computation_failed,
-			      [dh,OthersPublicKey,MyPrivateKey,DHParameters]);
-	Ret -> Ret
-    end;
+    ?nif_call(dh_compute_key_nif(ensure_int_as_bin(OthersPublicKey),
+                                 ensure_int_as_bin(MyPrivateKey),
+                                 map_ensure_int_as_bin(DHParameters)),
+              {2, 3, 4},
+              [dh, OthersPublicKey, MyPrivateKey, DHParameters]);
 
 compute_key(srp, HostPublic, {UserPublic, UserPrivate},
 	    {user, [DerivedKey, Prime, Generator, Version | ScramblerArg]}) when
@@ -1709,12 +1744,16 @@ compute_key(ecdh, Others, My, Curve) when Curve == x448 ;
 
 compute_key(eddh, Others, My, Curve) when Curve == x448 ;
                                           Curve == x25519 ->
-    evp_compute_key_nif(Curve, ensure_int_as_bin(Others), ensure_int_as_bin(My));
+    ?nif_call(evp_compute_key_nif(Curve, ensure_int_as_bin(Others), ensure_int_as_bin(My)),
+              {2, 3, 4},
+              [eddh, Others, My, Curve]);
 
 compute_key(ecdh, Others, My, Curve) ->
-    ecdh_compute_key_nif(ensure_int_as_bin(Others),
-			 nif_curve_params(Curve),
-			 ensure_int_as_bin(My)).
+    ?nif_call(ecdh_compute_key_nif(ensure_int_as_bin(Others),
+                                   nif_curve_params(Curve),
+                                   ensure_int_as_bin(My)),
+              {2, 4, 3},
+              [ecdh, Others, My, Curve]).
 
 
 evp_compute_key_nif(_Curve, _OthersBin, _MyBin) -> ?nif_stub.
@@ -2139,17 +2178,17 @@ notsup_to_error(Other) ->
 
 %% HASH --------------------------------------------------------------------
 hash(Hash, Data, Size, Max) when Size =< Max ->
-    notsup_to_error(hash_nif(Hash, Data));
+    ?nif_call(hash_nif(Hash, Data));
 hash(Hash, Data, Size, Max) ->
     State0 = hash_init(Hash),
     State1 = hash_update(State0, Data, Size, Max),
     hash_final(State1).
 
 hash_update(State, Data, Size, MaxBytes)  when Size =< MaxBytes ->
-    notsup_to_error(hash_update_nif(State, Data));
+    ?nif_call(hash_update_nif(State, Data), {1,2});
 hash_update(State0, Data, _, MaxBytes) ->
     <<Increment:MaxBytes/binary, Rest/binary>> = Data,
-    State = notsup_to_error(hash_update_nif(State0, Increment)),
+    State = ?nif_call(hash_update_nif(State0, Increment), {1,2}),
     hash_update(State, Rest, erlang:byte_size(Rest), MaxBytes).
 
 hash_info_nif(_Hash) -> ?nif_stub.
@@ -2243,7 +2282,7 @@ dh_generate_key_nif(_PrivateKey, _DHParameters, _Mpint, _Length) -> ?nif_stub.
 %% MyPrivKey, OthersPublicKey = mpint()
 dh_compute_key_nif(_OthersPublicKey, _MyPrivateKey, _DHParameters) -> ?nif_stub.
 
-ec_key_generate(_Curve, _Key) -> ?nif_stub.
+ec_generate_key_nif(_Curve, _Key) -> ?nif_stub.
 
 ecdh_compute_key_nif(_Others, _Curve, _My) -> ?nif_stub.
 
@@ -2264,16 +2303,15 @@ ec_curve(X) ->
                                                                      EnginePrivateKeyRef :: engine_key_ref(),
                                                                      PublicKey ::  rsa_public() | dss_public() .
 privkey_to_pubkey(Alg, EngineMap) when Alg == rsa; Alg == dss; Alg == ecdsa ->
-    try privkey_to_pubkey_nif(Alg, format_pkey(Alg,EngineMap))
-    of
+    try ?nif_call(privkey_to_pubkey_nif(Alg, format_pkey(Alg,EngineMap))) of
         [_|_]=L -> map_ensure_bin_as_int(L);
         X -> X
     catch
-        error:badarg when Alg==ecdsa ->
+        error:{badarg,_,_} when Alg==ecdsa ->
             {error, notsup};
-        error:badarg ->
+        error:{badarg,_,_} ->
             {error, not_found};
-        error:notsup ->
+        error:{notsup,_,_} ->
             {error, notsup}
     end.
 
@@ -2293,17 +2331,29 @@ term_to_nif_curve({A, B, Seed}) ->
     {ensure_int_as_bin(A), ensure_int_as_bin(B), Seed}.
 
 nif_curve_params({PrimeField, Curve, BasePoint, Order, CoFactor}) ->
-    {term_to_nif_prime(PrimeField),
-     term_to_nif_curve(Curve),
-     ensure_int_as_bin(BasePoint),
-     ensure_int_as_bin(Order),
-     ensure_int_as_bin(CoFactor)};
-nif_curve_params(Curve) when is_atom(Curve) ->
-    %% named curve
-    case Curve of
-        x448 -> {evp,Curve};
-        x25519 -> {evp,Curve};
-        _ -> crypto_ec_curves:curve(Curve)
+    {
+      {term_to_nif_prime(PrimeField),
+       term_to_nif_curve(Curve),
+       ensure_int_as_bin(BasePoint),
+       ensure_int_as_bin(Order),
+       ensure_int_as_bin(CoFactor)
+      },
+      undefined %% The curve name
+    };
+nif_curve_params(CurveName) when is_atom(CurveName) ->
+    %% A named curve
+    case CurveName of
+        x448   -> {evp,CurveName};
+        x25519 -> {evp,CurveName};
+        _ ->
+            Spec =
+                try
+                    crypto_ec_curves:curve(CurveName)
+                catch
+                    _:_ ->
+                        undefined
+                end,
+            {Spec, CurveName}
     end.
 
 
@@ -2322,6 +2372,15 @@ exor(Data1, Data2, _Size, MaxByts, Acc) ->
 
 do_exor(_A, _B) -> ?nif_stub.
 
+-spec hash_equals(BinA, BinB) -> Result
+          when BinA :: binary(),
+               BinB :: binary(),
+               Result :: boolean().
+hash_equals(A, B) ->
+  hash_equals_nif(A, B).
+
+hash_equals_nif(_A, _B) -> ?nif_stub.
+
 hash_algorithms() -> ?nif_stub.
 pubkey_algorithms() -> ?nif_stub.
 cipher_algorithms() -> ?nif_stub.
diff --git a/lib/crypto/test/Makefile b/lib/crypto/test/Makefile
index aaa2df0534..a018b794c5 100644
--- a/lib/crypto/test/Makefile
+++ b/lib/crypto/test/Makefile
@@ -17,6 +17,7 @@ TARGET_FILES= $(MODULES:%=$(EBIN)/%.$(EMULATOR))
 
 SPEC_FILES = \
 	crypto.spec \
+	crypto_gh.spec \
 	crypto_bench.spec
 
 COVER_FILE = crypto.cover
@@ -35,7 +36,7 @@ EBIN = .
 # ----------------------------------------------------
 # Targets
 # ----------------------------------------------------
-tests debug opt: $(TARGET_FILES)
+tests $(TYPES): $(TARGET_FILES)
 
 clean:
 	rm -f $(TARGET_FILES)
diff --git a/lib/crypto/test/crypto.spec b/lib/crypto/test/crypto.spec
index 4a95275687..690374b099 100644
--- a/lib/crypto/test/crypto.spec
+++ b/lib/crypto/test/crypto.spec
@@ -1,6 +1,4 @@
 {suites,"../crypto_test",all}.
-
-{skip_suites, "../crypto_test", [crypto_bench_SUITE
-	],
+{skip_suites, "../crypto_test", [crypto_bench_SUITE],
  "Benchmarks run separately"}.
 
diff --git a/lib/crypto/test/crypto_SUITE.erl b/lib/crypto/test/crypto_SUITE.erl
index 503961ebf9..959e1a09a0 100644
--- a/lib/crypto/test/crypto_SUITE.erl
+++ b/lib/crypto/test/crypto_SUITE.erl
@@ -53,7 +53,9 @@
          bad_key_length/1,
          bad_cipher_name/1,
          bad_generate_key_name/1,
+         bad_cmac_name/1,
          bad_hash_name/1,
+         bad_hmac_name/1,
          bad_mac_name/1,
          bad_sign_name/1,
          bad_verify_name/1,
@@ -62,6 +64,10 @@
          cipher_info_prop_aead_attr/0,
          cipher_info_prop_aead_attr/1,
          cipher_padding/1,
+         cmac/0,
+         cmac/1,
+         cmac_update/0,
+         cmac_update/1,
          compute/0,
          compute/1,
          compute_bug/0,
@@ -78,6 +84,10 @@
          hash/1,
          hash_info/0,
          hash_info/1,
+         hmac/0,
+         hmac/1,
+         hmac_update/0,
+         hmac_update/1,
          info/1,
          mod_pow/0,
          mod_pow/1,
@@ -87,11 +97,17 @@
          no_generate_compute/1,
          no_hash/0,
          no_hash/1,
+         no_hmac/0,
+         no_hmac/1,
+         no_poly1305/0,
+         no_poly1305/1,
          no_sign_verify/0,
          no_sign_verify/1,
          no_support/0,
          no_support/1,
          node_supports_cache/1,
+         poly1305/0,
+         poly1305/1,
          private_encrypt/0,
          private_encrypt/1,
          public_encrypt/0,
@@ -104,6 +120,8 @@
          rand_threads/1,
          rand_uniform/0,
          rand_uniform/1,
+         hash_equals/0,
+         hash_equals/1,
          sign_verify/0,
          sign_verify/1,
          ec_key_padding/1,
@@ -122,6 +140,7 @@
          aes_128_ctr/1,
          aes_128_ecb/1,
          aes_128_gcm/1,
+         aes_128_ofb/1,
          aes_192_cbc/1,
          aes_192_ccm/1,
          aes_192_cfb128/1,
@@ -129,6 +148,7 @@
          aes_192_ctr/1,
          aes_192_ecb/1,
          aes_192_gcm/1,
+         aes_192_ofb/1,
          aes_256_cbc/1,
          aes_256_ccm/1,
          aes_256_cfb128/1,
@@ -136,6 +156,7 @@
          aes_256_ctr/1,
          aes_256_ecb/1,
          aes_256_gcm/1,
+         aes_256_ofb/1,
          aes_cbc/1,
          aes_cbc128/1,
          aes_cbc256/1,
@@ -168,6 +189,11 @@
          rsa_oaep_label/0
         ]).
 
+
+-compile({nowarn_deprecated_function, [{crypto, crypto_dyn_iv_init, 3},
+                                       {crypto, crypto_dyn_iv_update, 3}
+                                      ]}).
+
 %%--------------------------------------------------------------------
 %% Common Test interface functions -----------------------------------
 %%--------------------------------------------------------------------
@@ -195,6 +221,7 @@ all() ->
      info,
      cipher_info,
      hash_info,
+     hash_equals,
      pbkdf2_hmac
     ].
 
@@ -205,6 +232,7 @@ groups() ->
     [{non_fips, [], [
                      {group, blake2b},
                      {group, blake2s},
+                     {group, poly1305},
                      {group, dss},
                      {group, ecdsa},
                      {group, ed25519},
@@ -265,11 +293,15 @@ groups() ->
                      {group, aes_256_cfb128},
                      {group, aes_128_cfb8},
                      {group, aes_192_cfb8},
-                     {group, aes_256_cfb8}
+                     {group, aes_256_cfb8},
+                     {group, aes_128_ofb},
+                     {group, aes_192_ofb},
+                     {group, aes_256_ofb}
                     ]},
      {fips, [], [
                  {group, no_blake2b},
                  {group, no_blake2s},
+                 {group, no_poly1305},
                  {group, dss},
                  {group, ecdsa},
                  {group, no_ed25519},
@@ -325,25 +357,28 @@ groups() ->
                  {group, aes_256_cfb128},
                  {group, aes_128_cfb8},
                  {group, aes_192_cfb8},
-                 {group, aes_256_cfb8}
+                 {group, aes_256_cfb8},
+                 {group, aes_128_ofb},
+                 {group, aes_192_ofb},
+                 {group, aes_256_ofb}
                 ]},
 
      {md4,                  [], [hash]},
-     {md5,                  [], [hash]},
+     {md5,                  [], [hash, hmac, hmac_update]},
      {ripemd160,            [], [hash]},
-     {sha,                  [], [hash]},
-     {sha224,               [], [hash]},
-     {sha256,               [], [hash]},
-     {sha384,               [], [hash]},
-     {sha512,               [], [hash]},
-     {sha3_224,             [], [hash]},
-     {sha3_256,             [], [hash]},
-     {sha3_384,             [], [hash]},
-     {sha3_512,             [], [hash]},
-     {blake2b,              [], [hash]},
-     {blake2s,              [], [hash]},
-     {no_blake2b,           [], [no_hash]},
-     {no_blake2s,           [], [no_hash]},
+     {sha,                  [], [hash, hmac, hmac_update]},
+     {sha224,               [], [hash, hmac, hmac_update]},
+     {sha256,               [], [hash, hmac, hmac_update]},
+     {sha384,               [], [hash, hmac, hmac_update]},
+     {sha512,               [], [hash, hmac, hmac_update]},
+     {sha3_224,             [], [hash, hmac, hmac_update]},
+     {sha3_256,             [], [hash, hmac, hmac_update]},
+     {sha3_384,             [], [hash, hmac, hmac_update]},
+     {sha3_512,             [], [hash, hmac, hmac_update]},
+     {blake2b,              [], [hash, hmac, hmac_update]},
+     {blake2s,              [], [hash, hmac, hmac_update]},
+     {no_blake2b,           [], [no_hash, no_hmac]},
+     {no_blake2s,           [], [no_hash, no_hmac]},
      {rsa,                  [], [sign_verify,
                                  public_encrypt,
                                  private_encrypt,
@@ -372,7 +407,7 @@ groups() ->
      {srp,                  [], [generate_compute]},
      {des_cbc,              [], [api_ng, api_ng_one_shot, api_ng_tls]},
      {des_cfb,              [], [api_ng, api_ng_one_shot, api_ng_tls]},
-     {des_ede3_cbc,         [], [api_ng, api_ng_one_shot, api_ng_tls]},
+     {des_ede3_cbc,         [], [api_ng, api_ng_one_shot, api_ng_tls, cmac]},
      {des_ede3_cfb,         [], [api_ng, api_ng_one_shot, api_ng_tls]},
      {rc2_cbc,              [], [api_ng, api_ng_one_shot, api_ng_tls]},
      {aes_cfb8,             [], []},
@@ -392,9 +427,11 @@ groups() ->
      {rc4,                  [], [api_ng, api_ng_one_shot, api_ng_tls]},
      {chacha20_poly1305,    [], [aead_ng, aead_bad_tag]},
      {chacha20,             [], [api_ng, api_ng_one_shot, api_ng_tls]},
+     {poly1305,             [], [poly1305]},
+     {no_poly1305,          [], [no_poly1305]},
      {no_aes_cfb128,        [], [no_support]},
      {no_md4,               [], [no_support, no_hash]},
-     {no_md5,               [], [no_support, no_hash]},
+     {no_md5,               [], [no_support, no_hash, no_hmac]},
      {no_ed25519,           [], [no_support, no_sign_verify
                                  %% Does not work yet:  ,public_encrypt, private_encrypt
                                 ]},
@@ -420,6 +457,8 @@ groups() ->
                                  bad_generate_key_name,
                                  bad_hash_name,
                                  bad_mac_name,
+                                 bad_hmac_name,
+                                 bad_cmac_name,
                                  bad_sign_name,
                                  bad_verify_name
                                 ]},
@@ -427,21 +466,24 @@ groups() ->
      %% New cipher nameing schema
      {des_ede3_cbc, [], [api_ng, api_ng_one_shot, api_ng_tls]},
      {des_ede3_cfb, [], [api_ng, api_ng_one_shot, api_ng_tls]},
-     {aes_128_cbc,  [], [api_ng, api_ng_one_shot, api_ng_tls]},
+     {aes_128_cbc,  [], [api_ng, api_ng_one_shot, api_ng_tls, cmac, cmac_update]},
      {aes_192_cbc,  [], [api_ng, api_ng_one_shot, api_ng_tls]},
-     {aes_256_cbc,  [], [api_ng, api_ng_one_shot, api_ng_tls]},
+     {aes_256_cbc,  [], [api_ng, api_ng_one_shot, api_ng_tls, cmac]},
      {aes_128_ctr,  [], [api_ng, api_ng_one_shot, api_ng_tls]},
      {aes_192_ctr,  [], [api_ng, api_ng_one_shot, api_ng_tls]},
      {aes_256_ctr,  [], [api_ng, api_ng_one_shot, api_ng_tls]},
      {aes_128_ccm,  [], [aead_ng, aead_bad_tag]},
      {aes_192_ccm,  [], [aead_ng, aead_bad_tag]},
      {aes_256_ccm,  [], [aead_ng, aead_bad_tag]},
-     {aes_128_ecb,  [], [api_ng, api_ng_one_shot]},
+     {aes_128_ecb,  [], [api_ng, api_ng_one_shot, cmac_update]},
      {aes_192_ecb,  [], [api_ng, api_ng_one_shot]},
      {aes_256_ecb,  [], [api_ng, api_ng_one_shot]},
      {aes_128_gcm,  [], [aead_ng, aead_bad_tag]},
      {aes_192_gcm,  [], [aead_ng, aead_bad_tag]},
-     {aes_256_gcm,  [], [aead_ng, aead_bad_tag]}
+     {aes_256_gcm,  [], [aead_ng, aead_bad_tag]},
+     {aes_128_ofb,  [], [api_ng, api_ng_one_shot]},
+     {aes_192_ofb,  [], [api_ng, api_ng_one_shot]},
+     {aes_256_ofb,  [], [api_ng, api_ng_one_shot]}
     ].
 
 %%-------------------------------------------------------------------
@@ -535,6 +577,13 @@ init_per_testcase(cmac, Config) ->
         false ->
             {skip, "CMAC is not supported"}
     end;
+init_per_testcase(cmac_update, Config) ->
+    case {is_supported(cmac),
+          maps:get(cryptolib_version_linked, crypto:info(), "")} of
+        {true, "OpenSSL 1.0."++_} -> {skip, "cmac_update is not supported"};
+        {false,                _} -> {skip, "CMAC is not supported"};
+        _ -> Config
+    end;
 init_per_testcase(generate, Config) ->
     case proplists:get_value(type, Config) of
 	rsa ->
@@ -700,36 +749,21 @@ make_crypto_key(String) ->
     {[K1,K2,K3],IVec,8}.
 %%--------------------------------------------------------------------
 %% Test that a spawned node has initialized the cache
--define(at_node, 
-        (fun(N, M, F, As) ->
-                 R = rpc:call(N, M, F, As),
-                 ct:log("~p ~p ~p:~p(~s) = ~p", [?LINE,N,M,F,args2list(As), R]),
-                 R
-         end) ).
-args2list(As) -> lists:join(", ", [io_lib:format("~p",[A]) || A <- As]).
 
 node_supports_cache(_Config) ->
     ECs = crypto:supports(curves),
-    {ok,Node} = start_slave_node(random_node_name(?MODULE)),
-    case ?at_node(Node, crypto, supports, [curves]) of
+    {ok,Peer,Node} = ?CT_PEER(),
+    case erpc:call(Node, crypto, supports, [curves]) of
         ECs ->
-            test_server:stop_node(Node);
+            peer:stop(Peer);
         OtherECs ->
+            peer:stop(Peer),
             ct:log("At master:~p~nAt slave:~p~n"
                    "Missing at slave: ~p~nmissing at master: ~p",
                    [ECs, OtherECs, ECs--OtherECs, OtherECs--ECs]),
             {fail, "different support at slave"}
     end.
 
-
-start_slave_node(Name) ->
-    Pa = filename:dirname(code:which(?MODULE)),
-    test_server:start_node(Name, slave, [{args, " -pa " ++ Pa}]).
-
-random_node_name(BaseName) ->
-    L = integer_to_list(erlang:unique_integer([positive])),
-    lists:concat([BaseName,"___",L]).
-
 %%--------------------------------------------------------------------
 hash() ->
     [{doc, "Test all different hash functions"}].
@@ -749,6 +783,62 @@ no_hash(Config) when is_list(Config) ->
     Type = ?config(type, Config),
     notsup(fun crypto:hash/2, [Type, <<"Hi There">>]),
     notsup(fun crypto:hash_init/1, [Type]).
+%%--------------------------------------------------------------------
+hmac() ->
+     [{doc, "Test hmac function"}].
+hmac(Config) when is_list(Config) ->
+    Tuples = lazy_eval(proplists:get_value(hmac, Config)),
+    do_cipher_tests(fun mac_check/1, Tuples++mac_listify(Tuples)).
+%%--------------------------------------------------------------------
+no_hmac() ->
+     [{doc, "Test all disabled hmac functions"}].
+no_hmac(Config) when is_list(Config) ->
+    Type = ?config(type, Config),
+    notsup(fun crypto:mac/4, [hmac, Type, <<"Key">>, <<"Hi There">>]).
+%%--------------------------------------------------------------------
+hmac_update() ->
+     [{doc, "Test all incremental hmac functions"}].
+hmac_update(Config) ->
+    SubType = ?config(type, Config),
+    Key = hmac_key(SubType),
+    Increments = hmac_inc(SubType),
+    mac_increment(hmac, SubType, Key, Increments).
+%%--------------------------------------------------------------------
+cmac() ->
+     [{doc, "Test all different cmac functions"}].
+cmac(Config) when is_list(Config) ->
+    Pairs = lazy_eval(proplists:get_value(cmac, Config)),
+    do_cipher_tests(fun mac_check/1, Pairs ++ mac_listify(Pairs)).
+%%--------------------------------------------------------------------
+cmac_update() ->
+     [{doc, "Test all incremental cmac functions"}].
+cmac_update(Config) ->
+    SubType = ?config(type, Config),
+    Key = cmac_key(SubType),
+    Increments = cmac_inc(SubType),
+    mac_increment(cmac, SubType, Key, Increments).
+%%--------------------------------------------------------------------
+poly1305() ->
+    [{doc, "Test poly1305 function"}].
+poly1305(Config) ->
+    lists:foreach(
+      fun({Key, Txt, Expect}) ->
+              case crypto:mac(poly1305,Key,Txt) of
+                  Expect ->
+                      ok;
+                  Other ->
+                      ct:fail({{crypto, mac, [poly1305, Key, Txt]}, {expected, Expect}, {got, Other}})
+              end
+      end, proplists:get_value(poly1305, Config)).
+
+%%--------------------------------------------------------------------
+no_poly1305() ->
+    [{doc, "Test disabled poly1305 function"}].
+no_poly1305(_Config) ->
+    Key = <<133,214,190,120,87,85,109,51,127,68,82,254,66,213,6,168,1,
+            3,128,138,251,13,178,253,74,191,246,175,65,73,245,27>>,
+    Txt = <<"Cryptographic Forum Research Group">>,
+    notsup(fun crypto:mac/3, [poly1305,Key,Txt]).
 
 %%--------------------------------------------------------------------
 api_ng() ->
@@ -1189,6 +1279,18 @@ use_all_ec_sign_verify(_Config) ->
             ok;
         _ ->
             ct:log("Fails:~n~p",[Fails]),
+            Errors = lists:usort([Err || {_,Err} <- Fails]),
+            FailedCurves = [Curve || {Curve,_} <- Fails],
+            FailedCurvesPerError = [{E, [C || {C,E0} <- Fails,
+                                              E0 == E]}
+                                    || E <- Errors],
+            ct:pal("~p failed curves: ~p", [length(FailedCurves), FailedCurves]),
+            ct:pal("Failed curves per error:~n~s", 
+                   [
+                    [io_lib:format("  Error: ~p~n Curves: ~p~n~n", [E,Cs])
+                     || {E,Cs} <- FailedCurvesPerError]
+                   ]
+                  ), 
             ct:fail("Bad curve(s)",[])
     end.
 
@@ -1233,13 +1335,31 @@ do_dh_curves(_Config, Curves) ->
                         (_) -> true
                      end, Results),
 
+    Succedes =
+        lists:filter(fun({_,true}) -> true;
+                        (_) -> false
+                     end, Results),
+
     case Fails of
         [] ->
             ct:comment("All ~p passed",[length(Results)]),
             ok;
         _ ->
-            ct:comment("passed: ~p, failed: ~p",[length(Results),length(Fails)]),
+            ct:comment("passed: ~p, failed: ~p",[length(Results)-length(Fails),length(Fails)]),
+            ct:log("Succedes:~n~p",[Succedes]),
             ct:log("Fails:~n~p",[Fails]),
+            Errors = lists:usort([Err || {_,Err} <- Fails]),
+            FailedCurves = [C || {C,_} <- Fails],
+            FailedCurvesPerError = [{E, [C || {C,E0} <- Fails,
+                                              E == E0]}
+                                    || E <- Errors],
+            ct:pal("~p (~p) failed curves: ~p", [length(FailedCurves), length(Results), FailedCurves]),
+            ct:pal("Failed curves per error:~n~s", 
+                   [
+                    [io_lib:format("  Error: ~p~n Curves: ~p~n~n", [E,Cs])
+                     || {E,Cs} <- FailedCurvesPerError]
+                   ]
+                  ), 
             ct:fail("Bad curve(s)",[])
     end.
 
@@ -1261,6 +1381,18 @@ exor(Config) when is_list(Config) ->
     do_exor(<<1, 2, 3, 4, 5, 6, 7, 8, 9, 10>>),
     do_exor(term_to_binary(lists:seq(1, 1000000))).
 %%--------------------------------------------------------------------
+hash_equals() ->
+    [{doc, "Test the hash_equals function"}].
+hash_equals(Config) when is_list(Config) ->
+    try
+        true = crypto:hash_equals(<<>>, <<>>),
+        true = crypto:hash_equals(<<"abc">>, <<"abc">>),
+        false = crypto:hash_equals(<<"abc">>, <<"abe">>)
+    catch
+        error:{notsup,{"hash_equals.c",_Line},"Unsupported CRYPTO_memcmp"++_} ->
+            {skip, "No CRYPTO_memcmp"}
+    end.
+%%--------------------------------------------------------------------
 rand_uniform() ->
     [{doc, "rand_uniform and random_bytes testing"}].
 rand_uniform(Config) when is_list(Config) ->
@@ -1430,9 +1562,27 @@ mac_check({MacType, SubType, Key, Text, Mac}=T) ->
 mac_check({MacType, SubType, Key, Text, Size, Mac}=T) ->
     ExpMac = iolist_to_binary(Mac),
     cipher_test(T,
-                fun() -> crypto:mac(MacType, SubType, Key, Text, Size) end,
+                fun() -> crypto:macN(MacType, SubType, Key, Text, Size) end,
                 ExpMac).
 
+mac_increment(Type, SubType, Key, Increments) ->
+    Expected = crypto:mac(Type, SubType, Key, Increments),
+    State = crypto:mac_init(Type, SubType, Key),
+    case do_mac_increment(State, Increments) of
+	Expected ->
+	    ok;
+	Other ->
+	    ct:fail({{crypto, "mac_init/update/final", [Type, SubType, Increments]},
+                     {expected, Expected},
+                     {got, Other}})  
+    end.
+
+do_mac_increment(State, []) ->
+    crypto:mac_final(State);
+do_mac_increment(State0, [Increment | Rest]) ->
+    State = crypto:mac_update(State0, Increment),
+    do_mac_increment(State, Rest).
+
 aead_cipher_ng({Type, Key, PlainText, IV, AAD, CipherText, CipherTag, _Info}=T) ->
     Plain = iolist_to_binary(PlainText),
     cipher_test(T,
@@ -1482,7 +1632,7 @@ cipher_test(Tag, T, F, E) ->
         E -> ok;
         Other -> {other, {Tag,T,Other}}
     catch
-        error:Error -> {error, {Tag,T,Error}}
+        error:Error -> ct:pal("Tag = ~p,~n T = ~p,~n F = ~p,~n E = ~p,~n Error = ~p", [Tag, T, F, E, Error]), {error, {Tag,T,Error}}
     end.
 
 do_cipher_tests(F, TestVectors) when is_function(F,1) ->
@@ -1579,6 +1729,13 @@ do_sign_verify({Type, Hash, Public, Private, Msg, Options}) ->
             ct:log("notsup but OK in old cryptolib crypto:sign(~p, ~p, ..., ..., ..., ~p)",
                    [Type,Hash,Options]),
             true;
+        error:{notsup,_,_} when NotSupLow == true,
+                          is_integer(LibVer),
+                          LibVer < 16#10001000 ->
+            %% Those opts where introduced in 1.0.1
+            ct:log("notsup but OK in old cryptolib crypto:sign(~p, ~p, ..., ..., ..., ~p)",
+                   [Type,Hash,Options]),
+            true;
         C:E ->
             ct:log("~p:~p  crypto:sign(~p, ~p, ..., ..., ..., ~p)", [C,E,Type,Hash,Options]),
             ct:fail({{crypto, sign_verify, [LibVer, Type, Hash, Msg, Public, Options]}})
@@ -1760,6 +1917,16 @@ decstr2int(S) ->
 is_supported(Group) ->
     lists:member(Group, lists:append([Algo ||  {_, Algo}  <- crypto:supports()])). 
 
+
+mac_listify(Blocks) ->
+    lists:map(fun do_mac_listify/1, Blocks).
+
+do_mac_listify({MType, Type, Key, Text, CMac}) ->
+    {MType, Type, iolistify(Key), iolistify(Text), CMac};
+do_mac_listify({MType, Type, Key, Text, Size, CMac}) ->
+    {MType, Type, iolistify(Key), iolistify(Text), Size, CMac}.
+
+
 iolistify(X) ->
     iolistify1(lazy_eval(X)).
 
@@ -2093,6 +2260,15 @@ group_config(eddh, Config) ->
 group_config(dh, Config) ->
     GenerateCompute = [dh()],
     [{generate_compute, GenerateCompute} | Config];
+group_config(poly1305, Config) ->
+    V = [%% {Key, Txt, Expect}
+         {%% RFC7539 2.5.2
+           hexstr2bin("85d6be7857556d337f4452fe42d506a80103808afb0db2fd4abff6af4149f51b"),
+           <<"Cryptographic Forum Research Group">>,
+           hexstr2bin("a8061dc1305136c6c22b8baf0c0127a9")
+         }
+        ],
+    [{poly1305,V} | Config];
 
 group_config(F, Config) ->
     TestVectors = fun() -> ?MODULE:F(Config) end,
@@ -2102,7 +2278,7 @@ group_config(F, Config) ->
 configure_mac(MacType, SubType, Config) ->
     case do_configure_mac(MacType, SubType, Config) of
         undefined ->
-            {skip, io:format("No ~p test vectors for ~p", [MacType, SubType])};
+            {skip, io_lib:format("No ~p test vectors for ~p", [MacType, SubType])};
         Pairs ->
             [{MacType, Pairs} | Config]
     end.
@@ -2160,15 +2336,23 @@ do_configure_mac(cmac, Cipher, Config) ->
             fun() -> read_rsp(Config, Cipher,  ["CMACGenAES128.rsp", "CMACVerAES128.rsp"]) end;
         aes_256_cbc ->
             fun() -> read_rsp(Config, Cipher,  ["CMACGenAES256.rsp", "CMACVerAES256.rsp"]) end;
+        des_ede3_cbc ->
+            fun() -> read_rsp(Config, Cipher,  ["CMACGenTDES3.rsp", "CMACVerTDES3.rsp"]) end;
         _ ->
             undefined
     end.
 
 
 zip3_special(Type, SubType, As, Bs, Cs) ->
-    [{Type, SubType, A, B, C}
+    [mk_zip3_special_elem(Type, SubType, A, B, C)
      || {A,B,C} <- lists:zip3(As, Bs, Cs)].
 
+mk_zip3_special_elem(hmac, sha, Key, <<"Test With Truncation">>=Data, Expected) ->
+    {hmac, sha, Key, Data, 20, Expected};
+mk_zip3_special_elem(hmac, SubType, Key, <<"Test With Truncation">>=Data, Expected) ->
+    {hmac, SubType, Key, Data, 16, Expected};
+mk_zip3_special_elem(Type, SubType, A, B, C) ->
+    {Type, SubType, A, B, C}.
 
 rsa_sign_verify_tests(Config, Msg, Public, Private, PublicS, PrivateS, OptsToTry) ->
         case ?config(fips, Config) of
@@ -2595,6 +2779,26 @@ rfc_2202_msgs()->
      <<"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data">>
     ].
 
+hmac_key(md5) ->
+    [<<"A fine speach">>, <<"by a fine man!">>];
+hmac_key(_) ->
+    hexstr2bin("00010203101112132021222330313233"
+	       "04050607141516172425262734353637"
+	       "08090a0b18191a1b28292a2b38393a3b"
+	       "0c0d0e0f1c1d1e1f2c2d2e2f3c3d3e3f").
+hmac_inc(_) ->
+    [<<"Sampl">>, <<"e #1">>].
+
+
+cmac_key(aes_128_cbc) ->
+    hexstr2bin("8eeca0d146fd09ffbbe0d47edcddfcec");
+cmac_key(aes_128_ecb) ->
+    hexstr2bin("8eeca0d146fd09ffbbe0d47edcddfcec").
+
+cmac_inc(_) ->
+    [<<"Sampl">>, <<"e #1">>].
+
+
 %% https://www.cosic.esat.kuleuven.be/nessie/testvectors/
 long_hmac_key(Type) when Type == sha384;
 			 Type == sha512 ->
@@ -2861,6 +3065,21 @@ aes_256_cbc(Config) ->
              ["CBCVarTxt256.rsp", "CBCVarKey256.rsp", "CBCGFSbox256.rsp", "CBCKeySbox256.rsp",
               "CBCMMT256.rsp"]).
 
+aes_128_ofb(Config) ->
+    read_rsp(Config, aes_128_ofb,
+             ["OFBVarTxt128.rsp", "OFBVarKey128.rsp", "OFBGFSbox128.rsp", "OFBKeySbox128.rsp",
+              "OFBMMT128.rsp"]).
+
+aes_192_ofb(Config) ->
+    read_rsp(Config, aes_192_ofb,
+             ["OFBVarTxt192.rsp", "OFBVarKey192.rsp", "OFBGFSbox192.rsp", "OFBKeySbox192.rsp",
+              "OFBMMT192.rsp"]).
+
+aes_256_ofb(Config) ->
+    read_rsp(Config, aes_256_ofb,
+             ["OFBVarTxt256.rsp", "OFBVarKey256.rsp", "OFBGFSbox256.rsp", "OFBKeySbox256.rsp",
+              "OFBMMT256.rsp"]).
+
 aes_ecb(Config) ->
     read_rsp(Config, aes_ecb,
              ["ECBVarTxt128.rsp", "ECBVarKey128.rsp", "ECBGFSbox128.rsp", "ECBKeySbox128.rsp",
@@ -4166,6 +4385,23 @@ parse_rsp(Type, [<<"Count = ", _/binary>>,
         _ ->
             parse_rsp_cmac(Type, Key, Msg, Mlen, Tlen, MAC, Rest, State, Acc)
     end;
+parse_rsp(Type, [<<"Count = ", _/binary>>,
+                 <<"Klen = ", _/binary>>,
+                 <<"Mlen = ", Mlen/binary>>,
+                 <<"Tlen = ", Tlen/binary>>,
+                 <<"Key1 = ", Key1/binary>>,
+                 <<"Key2 = ", Key2/binary>>,
+                 <<"Key3 = ", Key3/binary>>,
+                 <<"Msg = ", Msg/binary>>,
+                 <<"Mac = ", MAC/binary>>|Rest], State, Acc) ->
+    case Rest of
+        [<<"Result = P">>|Next] ->
+            parse_rsp_cmac(Type, [Key1,Key2,Key3], Msg, Mlen, Tlen, MAC, Next, State, Acc);
+        [<<"Result = ", _/binary>>|Next] ->
+            parse_rsp(Type, Next, State, Acc);
+        _ ->
+            parse_rsp_cmac(Type, [Key1,Key2,Key3], Msg, Mlen, Tlen, MAC, Rest, State, Acc)
+    end;
 %% GCM format decode format
 parse_rsp(Type, [<<"Count = ", Count/binary>>,
                  <<"Key = ", Key/binary>>,
@@ -4283,7 +4519,9 @@ parse_rsp(Type, [_|Next], State, Acc) ->
 
 
 parse_rsp_cmac(Type, Key0, Msg0, Mlen0, Tlen, MAC0, Next, State, Acc) ->
-    Key = hexstr2bin(Key0),
+    Key = if is_list(Key0) -> lists:map(fun hexstr2bin/1, Key0);
+             true -> hexstr2bin(Key0)
+          end,
     Mlen = binary_to_integer(Mlen0),
     <<Msg:Mlen/bytes, _/binary>> = hexstr2bin(Msg0),
     MAC = hexstr2bin(MAC0),
@@ -4307,13 +4545,12 @@ api_errors_ecdh(Config) when is_list(Config) ->
 
 
 %%%----- Tests for bad algorithm name as argument
--define(chk_api_name(Call, Expect),
-        %% Check that we don't segfault on bad names
+-define(chk_api_name_helper(Call, ExpectPart),
         (fun() -> % avoid binding vars
                  try
                      Call
                  catch 
-                     Expect -> ok;
+                     ExpectPart
 
                      Class:Reason:Stack ->
                          ct:log("~p:~p~n~p", [Class,Reason,Stack]),
@@ -4322,6 +4559,19 @@ api_errors_ecdh(Config) when is_list(Config) ->
          end)()
        ).
 
+-define(chk_api_name(Call, Expect),
+        ?chk_api_name_helper(Call,  Expect -> ok;)
+       ).
+
+-define(chk_api_name(Call, Expect1, Expect2),
+        ?chk_api_name_helper(Call,  Expect1 -> ok; Expect2 -> ok; )
+       ).
+
+-define(chk_api_name(Call, Expect1, Expect2, Expect3),
+        ?chk_api_name_helper(Call,  Expect1 -> ok; Expect2 -> ok; Expect3 -> ok; )
+       ).
+
+
 bad_combo(_Config) ->
     ?chk_api_name(crypto:crypto_dyn_iv_init(des_ede3_cbc, <<>>, []),
                   error:_).
@@ -4340,23 +4590,34 @@ bad_generate_key_name(_Config) ->
 
 bad_hash_name(_Config) ->
     ?chk_api_name(crypto:hash_init(foobar),
-                  error:badarg).
+                  error:{badarg,{"hash.c",_},"Bad digest type"++_}).
 
 bad_mac_name(_Config) ->
     ?chk_api_name(crypto:mac(foobar, <<1:1024>>, "nothing"),
                   error:function_clause).
 
+bad_hmac_name(_Config) ->
+    ?chk_api_name(crypto:mac(hmac, foobar, <<1:1024>>, "nothing"),
+                  error:{badarg,{"mac.c",_},"Bad digest algorithm"++_}).
+
+bad_cmac_name(_Config) ->
+    ?chk_api_name(crypto:mac(cmac, foobar, <<1:1024>>, "nothing"),
+                  error:{badarg,{"mac.c",_},"Unknown cipher"++_},
+                  error:{notsup,_,          "Unsupported mac algorithm"++_},
+                  error:{badarg,#{},        "Unknown cipher"++_}
+                 ).
+
 bad_sign_name(_Config) ->
     ?chk_api_name(crypto:sign(rsa, foobar, "nothing", <<1:1024>>),
-                  error:badarg),
+                  error:{badarg, {"pkey.c",_}, "Bad digest type"++_}),
     ?chk_api_name(crypto:sign(foobar, sha, "nothing", <<1:1024>>),
-                  error:badarg).
+                  error:{badarg, {"pkey.c",_}, "Bad algorithm"++_}).
     
 bad_verify_name(_Config) ->
-    ?chk_api_name(crypto:verify(rsa, foobar, "nothing","nothing",  <<1:1024>>),
-                  error:badarg),
-    ?chk_api_name(crypto:verify(foobar, sha, "nothing", "nothing", <<1:1024>>),
-                  error:badarg).
+    ?chk_api_name(crypto:verify(rsa, foobar, "nothing", <<"nothing">>,  <<1:1024>>),
+                  error:{badarg,{"pkey.c",_},"Bad digest type"++_}),
+    ?chk_api_name(crypto:verify(foobar, sha, "nothing", <<"nothing">>, <<1:1024>>),
+                  error:{badarg, {"pkey.c",_}, "Bad algorithm"++_}).
 
 
 %%%----------------------------------------------------------------
@@ -4446,7 +4707,7 @@ pbkdf2_hmac(Config) when is_list(Config) ->
     <<"6B9CF26D45455A43A5B8BB276A403B39E7FE37A0C41E02C281FF3069E1E94F52">> =
       F(binary:encode_unsigned(16#f09d849e), <<"EXAMPLE.COMpianist">>, 50, 32)
   catch
-    error:{notsup, _, "Unsupported CRYPTO_PKCS5_PBKDF2_HMAC"} ->
+    error:{notsup, _, "Unsupported CRYPTO_PKCS5_PBKDF2_HMAC"++_} ->
             {skip, "No CRYPTO_PKCS5_PBKDF2_HMAC"}
   end.
 
diff --git a/lib/crypto/test/crypto_gh.spec b/lib/crypto/test/crypto_gh.spec
new file mode 100644
index 0000000000..a1119373cd
--- /dev/null
+++ b/lib/crypto/test/crypto_gh.spec
@@ -0,0 +1,5 @@
+{suites,"../crypto_test",all}.
+{skip_suites, "../crypto_test", [crypto_bench_SUITE],
+ "Benchmarks run separately"}.
+{skip_cases, "../crypto_test", engine_SUITE,
+ [multiple_engine_load],"Broken with openssl 1.1.1f and docker"}.
diff --git a/lib/crypto/test/engine_SUITE.erl b/lib/crypto/test/engine_SUITE.erl
index 8efe7e39d4..24e1da7aca 100644
--- a/lib/crypto/test/engine_SUITE.erl
+++ b/lib/crypto/test/engine_SUITE.erl
@@ -212,18 +212,22 @@ end_per_group(_, Config) ->
 
 %%--------------------------------------------------------------------
 init_per_testcase(Case, Config) ->
-    case string:tokens(atom_to_list(Case),"_") of
-        ["sign","verify",Type|_] ->
-            skip_if_unsup(list_to_atom(Type), Config);
-
-        ["priv","encrypt","pub","decrypt",Type|_] ->
-            skip_if_unsup(list_to_atom(Type), Config);
-
-        ["get","pub","from","priv","key",Type|_] ->
-            skip_if_unsup(list_to_atom(Type), Config);
-
+    HasMD5 = lists:member(md5, crypto:supports(hashs)),
+    case Case of
+        ensure_load                 when HasMD5==false -> {skip, "md5 not available"};
+	engine_load_register_method when HasMD5==false -> {skip, "md5 not available"};
+	gc_clean                    when HasMD5==false -> {skip, "md5 not available"};
         _ ->
-            Config
+            case string:tokens(atom_to_list(Case),"_") of
+                ["sign","verify",Type|_] ->
+                    skip_if_unsup(list_to_atom(Type), Config);
+                ["priv","encrypt","pub","decrypt",Type|_] ->
+                    skip_if_unsup(list_to_atom(Type), Config);
+                ["get","pub","from","priv","key",Type|_] ->
+                    skip_if_unsup(list_to_atom(Type), Config);
+                _ ->
+                    Config
+            end
     end.
 
 end_per_testcase(_Case, _Config) ->
@@ -828,7 +832,7 @@ sign_verify_rsa_pwd_bad_pwd(Config) ->
     try sign_verify(rsa, sha, Priv, Pub) of
         _ -> {fail, "PWD prot pubkey sign succeeded with no pwd!"}
     catch
-        error:badarg -> ok
+        error:{badarg,_,_} -> ok
     end.
 
 priv_encrypt_pub_decrypt_rsa(Config) ->
diff --git a/lib/crypto/vsn.mk b/lib/crypto/vsn.mk
index 507e24094e..d9fae2abd7 100644
--- a/lib/crypto/vsn.mk
+++ b/lib/crypto/vsn.mk
@@ -1 +1 @@
-CRYPTO_VSN = 5.0.6.3
+CRYPTO_VSN = 5.1.2
